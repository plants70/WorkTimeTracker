================================================================================
PROJECT SNAPSHOT
Generated:   2025-09-02 17:12:59
Root:        C:\moy python\projects vs code\roma
Python:      3.13.5
================================================================================

================================================================================
PROJECT TREE
================================================================================
‚îú‚îÄ‚îÄ .env
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ admin_app
‚îÇ   ‚îú‚îÄ‚îÄ gui_admin.py
‚îÇ   ‚îú‚îÄ‚îÄ main_admin.py
‚îÇ   ‚îú‚îÄ‚îÄ repo.py
‚îÇ   ‚îî‚îÄ‚îÄ schedule_parser.py
‚îú‚îÄ‚îÄ archiver.py
‚îú‚îÄ‚îÄ auto_sync.py
‚îú‚îÄ‚îÄ build_admin.py
‚îú‚îÄ‚îÄ build_user.py
‚îú‚îÄ‚îÄ bundle_project.py
‚îú‚îÄ‚îÄ config.py
‚îú‚îÄ‚îÄ credentials
‚îÇ   ‚îî‚îÄ‚îÄ secret_creds.zip
‚îú‚îÄ‚îÄ diagnose_sync.log
‚îú‚îÄ‚îÄ diagnose_user_log.log
‚îú‚îÄ‚îÄ diagnostics_report.json
‚îú‚îÄ‚îÄ libcrypto-1_1-x64.dll
‚îú‚îÄ‚îÄ libcrypto-1_1.dll
‚îú‚îÄ‚îÄ libssl-1_1-x64.dll
‚îú‚îÄ‚îÄ libssl-1_1.dll
‚îú‚îÄ‚îÄ local_backup.db
‚îú‚îÄ‚îÄ logging_setup.py
‚îú‚îÄ‚îÄ logs

‚îú‚îÄ‚îÄ map_project.py
‚îú‚îÄ‚îÄ project_report.txt
‚îú‚îÄ‚îÄ pyproject.toml
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ secret_creds.zip
‚îú‚îÄ‚îÄ sheets_api.py
‚îú‚îÄ‚îÄ sync
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ network.py
‚îÇ   ‚îú‚îÄ‚îÄ notifications.py
‚îÇ   ‚îî‚îÄ‚îÄ sync_queue.py
‚îú‚îÄ‚îÄ telegram_bot
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ main.py
‚îÇ   ‚îî‚îÄ‚îÄ notifier.py
‚îú‚îÄ‚îÄ tools
‚îÇ   ‚îú‚îÄ‚îÄ doctor.py
‚îÇ   ‚îú‚îÄ‚îÄ tg_envcheck.py
‚îÇ   ‚îî‚îÄ‚îÄ tg_send.py
‚îú‚îÄ‚îÄ user_app
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ api.py
‚îÇ   ‚îú‚îÄ‚îÄ app.log
‚îÇ   ‚îú‚îÄ‚îÄ db_local.py
‚îÇ   ‚îú‚îÄ‚îÄ db_migrations.py
‚îÇ   ‚îú‚îÄ‚îÄ gui.py
‚îÇ   ‚îú‚îÄ‚îÄ login_window.py
‚îÇ   ‚îú‚îÄ‚îÄ main.py
‚îÇ   ‚îú‚îÄ‚îÄ sberhealf.ico
‚îÇ   ‚îú‚îÄ‚îÄ sberhealf.png
‚îÇ   ‚îú‚îÄ‚îÄ signals.py
‚îÇ   ‚îî‚îÄ‚îÄ ui_helpers.py
‚îî‚îÄ‚îÄ work_time_tracker.egg-info
    ‚îú‚îÄ‚îÄ PKG-INFO
    ‚îú‚îÄ‚îÄ SOURCES.txt
    ‚îú‚îÄ‚îÄ dependency_links.txt
    ‚îú‚îÄ‚îÄ entry_points.txt
    ‚îú‚îÄ‚îÄ requires.txt
    ‚îî‚îÄ‚îÄ top_level.txt

================================================================================
LOCAL SQLITE OVERVIEW
DB Path: c:\moy python\projects vs code\roma\local_backup.db
================================================================================
database_list: [(0, 'main', 'c:\\moy python\\projects vs code\\roma\\local_backup.db')]
--------------------------------------------------------------------------------
[TABLE] app_logs
schema: CREATE TABLE app_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ts TEXT NOT NULL,
                level TEXT NOT NULL,
                message TEXT NOT NULL
            )
columns:
  - id INTEGER NOTNULL=0 PK=1 DEFAULT=None
  - ts TEXT NOTNULL=1 PK=0 DEFAULT=None
  - level TEXT NOTNULL=1 PK=0 DEFAULT=None
  - message TEXT NOTNULL=1 PK=0 DEFAULT=None
indexes:
  - idx_app_logs_ts UNIQUE=0
      * 1: ts
rows_count: 0
--------------------------------------------------------------------------------
[TABLE] app_logs_legacy_20250826175446
schema: CREATE TABLE "app_logs_legacy_20250826175446" (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ts TEXT NOT NULL,
                level TEXT NOT NULL,
                message TEXT NOT NULL
            )
columns:
  - id INTEGER NOTNULL=0 PK=1 DEFAULT=None
  - ts TEXT NOTNULL=1 PK=0 DEFAULT=None
  - level TEXT NOTNULL=1 PK=0 DEFAULT=None
  - message TEXT NOTNULL=1 PK=0 DEFAULT=None
indexes:
  - idx_logs_ts UNIQUE=0
      * 1: ts
rows_count: 0
--------------------------------------------------------------------------------
[TABLE] logs
schema: CREATE TABLE logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                session_id TEXT NOT NULL,
                email TEXT NOT NULL,
                name TEXT NOT NULL,
                status TEXT,
                action_type TEXT NOT NULL,
                comment TEXT,
                timestamp TEXT NOT NULL,
                synced INTEGER DEFAULT 0,
                sync_attempts INTEGER DEFAULT 0,
                last_sync_attempt TEXT,
                priority INTEGER DEFAULT 1,
                status_start_time TEXT,
                status_end_time TEXT,
                reason TEXT,
                user_group TEXT
            )
columns:
  - id INTEGER NOTNULL=0 PK=1 DEFAULT=None
  - session_id TEXT NOTNULL=1 PK=0 DEFAULT=None
  - email TEXT NOTNULL=1 PK=0 DEFAULT=None
  - name TEXT NOTNULL=1 PK=0 DEFAULT=None
  - status TEXT NOTNULL=0 PK=0 DEFAULT=None
  - action_type TEXT NOTNULL=1 PK=0 DEFAULT=None
  - comment TEXT NOTNULL=0 PK=0 DEFAULT=None
  - timestamp TEXT NOTNULL=1 PK=0 DEFAULT=None
  - synced INTEGER NOTNULL=0 PK=0 DEFAULT=0
  - sync_attempts INTEGER NOTNULL=0 PK=0 DEFAULT=0
  - last_sync_attempt TEXT NOTNULL=0 PK=0 DEFAULT=None
  - priority INTEGER NOTNULL=0 PK=0 DEFAULT=1
  - status_start_time TEXT NOTNULL=0 PK=0 DEFAULT=None
  - status_end_time TEXT NOTNULL=0 PK=0 DEFAULT=None
  - reason TEXT NOTNULL=0 PK=0 DEFAULT=None
  - user_group TEXT NOTNULL=0 PK=0 DEFAULT=None
indexes:
  - idx_logs_session UNIQUE=0
      * 1: session_id
  - idx_logs_timestamp UNIQUE=0
      * 7: timestamp
  - idx_logs_synced UNIQUE=0
      * 8: synced
  - idx_logs_email UNIQUE=0
      * 2: email
triggers:
  - check_comment_length: CREATE TRIGGER check_comment_length
            BEFORE INSERT ON logs
            FOR EACH ROW
            WHEN length(NEW.comment) > 500
            BEGIN
                SELECT RAISE(ABORT, 'Comment too long');
            END
  - prevent_duplicate_logout: CREATE TRIGGER prevent_duplicate_logout
            BEFORE INSERT ON logs
            FOR EACH ROW
            WHEN LOWER(NEW.action_type) = 'logout' AND EXISTS (
                SELECT 1 FROM logs
                WHERE session_id = NEW.session_id
                  AND LOWER(action_type) = 'logout'
                  AND timestamp > datetime('now', '-5 minutes')
            )
            BEGIN
                SELECT RAISE(ABORT, 'Duplicate LOGOUT action');
            END
rows_count: 26
sample rows (last):
  ‚Ä¢ (26, '10@ya.ru_20250902102558', '10@ya.ru', '—Ç–µ—Å—Ç —Å—Ç–æ–º 3', '–ó–∞–≤–µ—Ä—à–µ–Ω–æ', 'LOGOUT', '–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Å–º–µ–Ω—ã (–Ω–æ—Ä–º–∞–ª—å–Ω–æ–µ)', '2025-09-02T07:31:20.622314+00:00', 0, 0, None, 1, '2025-09-02T10:31:20.622249', '2025-09-02T10:31:20.622249', 'user', '–°—Ç–æ–º–∞—Ç–æ–ª–æ–≥–∏—è')
  ‚Ä¢ (25, '10@ya.ru_20250902102558', '10@ya.ru', '—Ç–µ—Å—Ç —Å—Ç–æ–º 3', '–ê—É–¥–∏–æ', 'STATUS_CHANGE', None, '2025-09-02T07:30:03.200596+00:00', 1, 1, '2025-09-02T07:30:05.016279+00:00', 1, '2025-09-02T10:30:03.197439', '2025-09-02T07:31:20.619894+00:00', None, None)
  ‚Ä¢ (24, '10@ya.ru_20250902102558', '10@ya.ru', '—Ç–µ—Å—Ç —Å—Ç–æ–º 3', '–ß–∞—Ç', 'STATUS_CHANGE', None, '2025-09-02T07:29:57.160421+00:00', 1, 2, '2025-09-02T07:30:03.496395+00:00', 1, '2025-09-02T10:29:57.156445', '2025-09-02T10:30:03.197439', None, None)
  ‚Ä¢ (23, '10@ya.ru_20250902102558', '10@ya.ru', '—Ç–µ—Å—Ç —Å—Ç–æ–º 3', '–í —Ä–∞–±–æ—Ç–µ', 'LOGIN', '–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã', '2025-09-02T07:25:58.866299+00:00', 1, 2, '2025-09-02T07:29:57.501512+00:00', 1, '2025-09-02T10:25:58.866228', '2025-09-02T10:29:57.156445', None, None)
  ‚Ä¢ (22, '10@ya.ru_20250901175741', '10@ya.ru', '—Ç–µ—Å—Ç —Å—Ç–æ–º 3', '–ó–∞–≤–µ—Ä—à–µ–Ω–æ', 'LOGOUT', '–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ —á–µ—Ä–µ–∑ –∫—Ä–µ—Å—Ç–∏–∫', '2025-09-02T05:58:06.182047+00:00', 0, 0, None, 1, '2025-09-02T08:58:06.181994', '2025-09-02T08:58:06.181994', 'user', '–°—Ç–æ–º–∞—Ç–æ–ª–æ–≥–∏—è')
--------------------------------------------------------------------------------
[TABLE] offline_actions
schema: CREATE TABLE offline_actions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ts TEXT NOT NULL,
                action_type TEXT NOT NULL,
                payload TEXT NOT NULL,  -- JSON-—Å—Ç—Ä–æ–∫–∞
                status TEXT NOT NULL DEFAULT 'pending'  -- pending|synced|failed
            )
columns:
  - id INTEGER NOTNULL=0 PK=1 DEFAULT=None
  - ts TEXT NOTNULL=1 PK=0 DEFAULT=None
  - action_type TEXT NOTNULL=1 PK=0 DEFAULT=None
  - payload TEXT NOTNULL=1 PK=0 DEFAULT=None
  - status TEXT NOTNULL=1 PK=0 DEFAULT='pending'
indexes:
  - idx_offline_actions_status_ts UNIQUE=0
      * 4: status
      * 1: ts
rows_count: 0
--------------------------------------------------------------------------------
[TRIGGERS GLOBAL]
  - check_comment_length on logs: CREATE TRIGGER check_comment_length
            BEFORE INSERT ON logs
            FOR EACH ROW
            WHEN length(NEW.comment) > 500
            BEGIN
                SELECT RAISE(ABORT, 'Comment too long');
            END
  - prevent_duplicate_logout on logs: CREATE TRIGGER prevent_duplicate_logout
            BEFORE INSERT ON logs
            FOR EACH ROW
            WHEN LOWER(NEW.action_type) = 'logout' AND EXISTS (
                SELECT 1 FROM logs
                WHERE session_id = NEW.session_id
                  AND LOWER(action_type) = 'logout'
                  AND timestamp > datetime('now', '-5 minutes')
            )
            BEGIN
                SELECT RAISE(ABORT, 'Duplicate LOGOUT action');
            END
================================================================================
GOOGLE SHEETS OVERVIEW
================================================================================
Spreadsheet: WorkLog
--------------------------------------------------------------------------------
[SHEET] Admins
header: ['Login', 'Password']
rows_count (non-empty): 1
sample rows (first 3):
  ‚Ä¢ ['Admin', 'qwerty']
--------------------------------------------------------------------------------
[SHEET] Users
header: ['Email', 'Name', 'Phone', 'Role', 'Telegram', 'ShiftHours', 'Hours', 'NotifyTelegram', 'Group']
rows_count (non-empty): 12
sample rows (first 3):
  ‚Ä¢ ['1@ya.ru', '—Ç–µ—Å—Ç–æ–≤—ã–π —á–µ–ª', '888', '–°–ø–µ—Ü–∏–∞–ª–∏—Å—Ç', '', '5/2', '8', '', '']
  ‚Ä¢ ['2@ya.ru', '–¢–µ—Å—Ç–æ–≤—ã–π –í–∞—Å—è', '111', '', '', '', '', '', '']
  ‚Ä¢ ['3@ya.ru', '—Ç—Ä–µ—Ç–∏–π —á–µ–ª', '3333', '', '', '', '', '', '']
--------------------------------------------------------------------------------
[SHEET] Groups
header: ['Group', 'Sheet', 'Statuses', '–í–æ–∑–º–æ–∂–Ω—ã–µ —Å—Ç–∞—Ç—É—Å—ã: "–í —Ä–∞–±–æ—Ç–µ",\n    "–ß–∞—Ç",\n    "–ê—É–¥–∏–æ",\n    "–ó–∞–ø–∏—Å—å",\n    "–ê–Ω–∫–µ—Ç—ã",\n    "–ü–µ—Ä–µ—Ä—ã–≤",\n    "–û–±–µ–¥",\n    "–¶–ò–¢–û",\n    "–û–±—É—á–µ–Ω–∏–µ" \n–£–∫–∞–∑—ã–≤–∞—Ç—å —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é, –±–µ–∑ –∫–æ–≤—ã—á–µ–∫']
rows_count (non-empty): 4
sample rows (first 3):
  ‚Ä¢ ['–í—Ö–æ–¥—è—â–∏–µ', 'WorkLog_–í—Ö–æ–¥—è—â–∏–µ', '–í —Ä–∞–±–æ—Ç–µ,–ß–∞—Ç,–ê—É–¥–∏–æ,–ü–µ—Ä–µ—Ä—ã–≤,–û–±–µ–¥,–¶–ò–¢–û', '']
  ‚Ä¢ ['–ó–∞–ø–∏—Å—å', 'WorkLog_–ó–∞–ø–∏—Å—å', '–í —Ä–∞–±–æ—Ç–µ,–ß–∞—Ç,–ê—É–¥–∏–æ,–ü–µ—Ä–µ—Ä—ã–≤,–û–±–µ–¥,–¶–ò–¢–û', '']
  ‚Ä¢ ['–°—Ç–æ–º–∞—Ç–æ–ª–æ–≥–∏—è', 'WorkLog_–°—Ç–æ–º–∞—Ç–æ–ª–æ–≥–∏—è', '–í —Ä–∞–±–æ—Ç–µ,–ß–∞—Ç,–ê—É–¥–∏–æ,–ü–µ—Ä–µ—Ä—ã–≤,–û–±–µ–¥,–¶–ò–¢–û', '']
--------------------------------------------------------------------------------
[SHEET] WorkLog_–ó–∞–ø–∏—Å—å
header: ['123@ya.ru', '—Ç–µ—Å—Ç –∑–∞–ø–∏—Å–∏', '–í —Ä–∞–±–æ—Ç–µ', 'LOGIN', '–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã', '2025-08-25T17:49:24.965579', '123@ya.r_20250825174924', '2025-08-25T17:49:24.965517']
rows_count (non-empty): 6
sample rows (first 3):
  ‚Ä¢ ['123@ya.ru', '—Ç–µ—Å—Ç –∑–∞–ø–∏—Å–∏', '–í —Ä–∞–±–æ—Ç–µ', 'LOGIN', '–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã', '2025-08-25T17:49:24.965579', '123@ya.r_20250825174924', '2025-08-25T17:49:24.965517', '', '']
  ‚Ä¢ ['123@ya.ru', '—Ç–µ—Å—Ç –∑–∞–ø–∏—Å–∏', '–í —Ä–∞–±–æ—Ç–µ', 'LOGIN', '–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã', '2025-08-25T17:49:24.965579', '123@ya.r_20250825174924', '2025-08-25T17:49:24.965517', '2025-08-25T17:49:56.465386', '']
  ‚Ä¢ ['123@ya.ru', '—Ç–µ—Å—Ç –∑–∞–ø–∏—Å–∏', '–ó–∞–≤–µ—Ä—à–µ–Ω–æ', 'LOGOUT', '–†–∞–∑–ª–æ–≥–∏–Ω–µ–Ω –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º (—É–¥–∞–ª—ë–Ω–Ω–æ)', '2025-08-25T17:49:56.505634', '123@ya.r_20250825174924', '2025-08-25T17:49:56.505530', '2025-08-25T17:49:56.505530', 'admin']
--------------------------------------------------------------------------------
[SHEET] WorkLog_–í—Ö–æ–¥—è—â–∏–µ
header: ['Email', 'Name', 'Status', 'ActionType', 'Comment', 'Timestamp', 'SessionID', 'StatusStartTime', 'StatusEndTime']
rows_count (non-empty): 27
sample rows (first 3):
  ‚Ä¢ ['7@ya.ru_20250823171203', '7@ya.ru', '–¢–µ—Å—Ç –ø–æ—á—Ç—ã', '–í —Ä–∞–±–æ—Ç–µ', 'LOGIN', '–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã', '2025-08-23T17:12:03.958642', '2025-08-23T17:12:03.958610', '2025-08-23T17:12:11.051848', '']
  ‚Ä¢ ['pid:dkuj4sai7negjt4x', 'PID-dkuj4s', '–í —Ä–∞–±–æ—Ç–µ', 'LOGIN', '–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã', '2025-08-27 14:41:46', 'pid:dkuj_20250827144146', '2025-08-27 17:41:46', '2025-08-27 14:41:52', '']
  ‚Ä¢ ['pid:dkuj4sai7negjt4x', 'PID-dkuj4s', '–í —Ä–∞–±–æ—Ç–µ', 'LOGIN', '–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã', '2025-08-27 14:41:46', 'pid:dkuj_20250827144146', '2025-08-27 17:41:46', '2025-08-27 14:57:43', '']
--------------------------------------------------------------------------------
[SHEET] ActiveSessions
header: ['Email', 'Name', 'SessionID', 'LoginTime', 'Status', 'LogoutTime', 'RemoteCommand']
rows_count (non-empty): 158
sample rows (first 3):
  ‚Ä¢ ['5@ya.ru', '–ì–æ–ª—É–±–µ–≤–∞ –Æ–ª–∏—è –í–∏–∫—Ç–æ—Ä–æ–≤–Ω–∞', '5@ya.ru_20250731150702', '2025-07-31T15:07:02', 'finished', '2025-08-15 14:38:22', '']
  ‚Ä¢ ['5@ya.ru', '–ì–æ–ª—É–±–µ–≤–∞ –Æ–ª–∏—è –í–∏–∫—Ç–æ—Ä–æ–≤–Ω–∞', '5@ya.ru_20250731152815', '2025-07-31T15:28:15', 'finished', '2025-07-31T15:28:49.376478', '']
  ‚Ä¢ ['5@ya.ru', '–ì–æ–ª—É–±–µ–≤–∞ –Æ–ª–∏—è –í–∏–∫—Ç–æ—Ä–æ–≤–Ω–∞', '5@ya.ru_20250731154231', '2025-07-31T15:42:31', 'finished', '2025-07-31T15:43:08.484935', '']
--------------------------------------------------------------------------------
[SHEET] WorkLog_–°—Ç–æ–º–∞—Ç–æ–ª–æ–≥–∏—è
header: ['10@ya.ru', '—Ç–µ—Å—Ç —Å—Ç–æ–º 3', '–í —Ä–∞–±–æ—Ç–µ', 'LOGIN', '–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã', '2025-09-01 16:05:14', '10@ya.ru_20250901160514', '2025-09-01 19:05:14', '2025-09-01 16:05:20']
rows_count (non-empty): 19
sample rows (first 3):
  ‚Ä¢ ['10@ya.ru', '—Ç–µ—Å—Ç —Å—Ç–æ–º 3', '–ß–∞—Ç', 'STATUS_CHANGE', '', '2025-09-01 16:05:31', '10@ya.ru_20250901160514', '2025-09-01 19:05:31', '2025-09-01 16:05:31']
  ‚Ä¢ ['10@ya.ru', '—Ç–µ—Å—Ç —Å—Ç–æ–º 3', '–í —Ä–∞–±–æ—Ç–µ', 'LOGIN', '–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã', '2025-09-01 16:05:14', '10@ya.ru_20250901160514', '2025-09-01 19:05:14', '2025-09-01 19:05:31']
  ‚Ä¢ ['10@ya.ru', '—Ç–µ—Å—Ç —Å—Ç–æ–º 3', '–í —Ä–∞–±–æ—Ç–µ', 'LOGIN', '–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã', '2025-09-01 16:48:28', '10@ya.ru_20250901164828', '2025-09-01 19:48:28', '2025-09-01 16:48:33']
--------------------------------------------------------------------------------
[SHEET] WorkLog_–ü–æ—á—Ç–∞
header: ['7@ya.ru', '–¢–µ—Å—Ç –ø–æ—á—Ç—ã', '–í —Ä–∞–±–æ—Ç–µ', 'LOGIN', '–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã', '2025-08-25T14:21:50.941225', '7@ya.ru_20250825142150', '2025-08-25T14:21:50.941160']
rows_count (non-empty): 18
sample rows (first 3):
  ‚Ä¢ ['7@ya.ru', '–¢–µ—Å—Ç –ø–æ—á—Ç—ã', '–í —Ä–∞–±–æ—Ç–µ', 'LOGIN', '–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã', '2025-08-25T14:21:50.941225', '7@ya.ru_20250825142150', '2025-08-25T14:21:50.941160', '2025-08-25T14:23:04.217964', '']
  ‚Ä¢ ['7@ya.ru', '–¢–µ—Å—Ç –ø–æ—á—Ç—ã', '–ß–∞—Ç', 'STATUS_CHANGE', '', '2025-08-25T14:23:04.223693', '7@ya.ru_20250825142150', '2025-08-25T14:23:04.217964', '', '']
  ‚Ä¢ ['7@ya.ru', '–¢–µ—Å—Ç –ø–æ—á—Ç—ã', '–ß–∞—Ç', 'STATUS_CHANGE', '', '2025-08-25T14:23:04.223693', '7@ya.ru_20250825142150', '2025-08-25T14:23:04.217964', '2025-08-25T14:25:21.425490', '']
--------------------------------------------------------------------------------
[SHEET] AccessControl
header: ['KeyType', 'KeyValue', 'AccessStatus', 'BlockUntil', 'Reason', 'UpdatedAt']
rows_count (non-empty): 0
================================================================================
PROJECT REPORT
Generated:   2025-09-02 17:14:32
Root:        C:\moy python\projects vs code\roma
Python:      3.13.5
Files:       43
================================================================================


--------------------------------------------------------------------------------
# FILE: .gitignore
# SIZE: 437 bytes | SHA256(text): 927018a20d479a444e2d7d6b4836885f02432e4616c8f83dfb3e523ef6051a83
--------------------------------------------------------------------------------
# Python
__pycache__/
*.pyc
*.pyo
*.pyd

# SQLite (–ª–æ–∫–∞–ª—å–Ω—ã–µ –ë–î)
*.db
*.db-shm
*.db-wal

# –õ–æ–≥–∏
*.log
logs/
*.bak

# –°–µ–∫—Ä–µ—Ç—ã –∏ –∫–ª—é—á–∏
.env
secret_creds.zip

# PyInstaller
*.spec
dist/
build/
*.exe
*.dll

# IDE/Editor
.vscode/
.idea/
.DS_Store

# GCP creds ‚Äî –∑–∞–ø—Ä–µ—â–µ–Ω–æ —Ö—Ä–∞–Ω–∏—Ç—å –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏
credentials/*.json
*.secret.json
service_account.json

--------------------------------------------------------------------------------
# FILE: __init__.py
# SIZE: 343 bytes | SHA256(text): 423245e097df4d9c26b80058efa8bc9635eddc1ac1b1a2482e90816d7b154ca6
--------------------------------------------------------------------------------
# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–∞–∫–µ—Ç–∞ user_app
from .version import __version__

__all__ = [
    'main',
    'gui', 
    'login_window',
    'db_local',
    'sheets_api',
    'sync'
]

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—É—Ç–µ–π
import os
import sys

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

--------------------------------------------------------------------------------
# FILE: admin_app\gui_admin.py
# SIZE: 0 bytes | SHA256(text): e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
# FILE: admin_app\main_admin.py
# SIZE: 21626 bytes | SHA256(text): df255496219eed226297ec882cfe813e8cf046f5e231999a37080a23114343a7
--------------------------------------------------------------------------------
# admin_app/main_admin.py
from __future__ import annotations

import sys
import logging
import time
from pathlib import Path
from typing import Optional, Dict, List, Tuple

from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit,
    QPushButton, QTableWidget, QTableWidgetItem, QCheckBox, QComboBox, QMessageBox,
    QTabWidget, QGroupBox
)

# --- –ï–¥–∏–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –∞–¥–º–∏–Ω–∫–∏ ---
from logging_setup import setup_logging
from config import LOG_DIR

# --- –î–æ–º–µ–Ω–Ω–∞—è –ª–æ–≥–∏–∫–∞/—Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π ---
from admin_app.repo import AdminRepo

# =================== –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã UI ===================
FIELDS = ["Email", "Name", "Phone", "Role", "Telegram", "Group", "NotifyTelegram"]
ROLES = ["—Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç", "—Å—Ç–∞—Ä—à–∏–π —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç", "–≤–µ–¥—É—â–∏–π —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç", "—Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å –≥—Ä—É–ø–ø—ã"]

# –ó–∞–≥—Ä—É–∑–∫–∞ GROUP_MAPPING —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫
try:
    # —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∞—è –∫–∞—Ä—Ç–∞ –≥—Ä—É–ø–ø, –µ—Å–ª–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –≤ config.py
    from config import GROUP_MAPPING
except Exception:
    GROUP_MAPPING = {}

# =================== –î–∏–∞–ª–æ–≥ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ===================
from PyQt5.QtWidgets import QDialog

class UserDialog(QDialog):
    def __init__(self, parent=None, user: Optional[Dict[str, str]] = None, groups: List[str] = None):
        super().__init__(parent)
        self.setWindowTitle("–ö–∞—Ä—Ç–æ—á–∫–∞ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞")
        self.user = user or {}
        self.groups = groups or []
        self._build()

    def _build(self):
        layout = QVBoxLayout(self)

        self.email_input = QLineEdit(str(self.user.get("Email", "")))
        self.fio_input = QLineEdit(str(self.user.get("Name", "")))
        self.phone_input = QLineEdit(str(self.user.get("Phone", "")))
        self.tg_input = QLineEdit(str(self.user.get("Telegram", "")))

        self.role_combo = QComboBox()
        self.role_combo.addItems(ROLES)
        role_val = str(self.user.get("Role", "")).strip()
        if role_val in ROLES:
            self.role_combo.setCurrentText(role_val)

        self.group_combo = QComboBox()
        self.group_combo.addItems(self.groups)
        group_val = str(self.user.get("Group", "")).strip()
        if group_val in self.groups:
            self.group_combo.setCurrentText(group_val)

        self.tg_notify_chk = QCheckBox("–û—Ç–ø—Ä–∞–≤–ª—è—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ Telegram")
        chk = str(self.user.get("NotifyTelegram", "")).strip().lower()
        self.tg_notify_chk.setChecked(chk in ("yes", "true", "1", "–¥–∞"))

        layout.addWidget(QLabel("Email:"))
        layout.addWidget(self.email_input)
        layout.addWidget(QLabel("–§–ò–û:"))
        layout.addWidget(self.fio_input)
        layout.addWidget(QLabel("–¢–µ–ª–µ—Ñ–æ–Ω:"))
        layout.addWidget(self.phone_input)
        layout.addWidget(QLabel("Telegram:"))
        layout.addWidget(self.tg_input)
        layout.addWidget(QLabel("–î–æ–ª–∂–Ω–æ—Å—Ç—å:"))
        layout.addWidget(self.role_combo)
        layout.addWidget(QLabel("–ì—Ä—É–ø–ø–∞:"))
        layout.addWidget(self.group_combo)
        layout.addWidget(self.tg_notify_chk)

        btns = QHBoxLayout()
        btn_save = QPushButton("–°–æ—Ö—Ä–∞–Ω–∏—Ç—å")
        btn_save.clicked.connect(self.accept)
        btn_cancel = QPushButton("–û—Ç–º–µ–Ω–∞")
        btn_cancel.clicked.connect(self.reject)
        btns.addWidget(btn_save)
        btns.addWidget(btn_cancel)
        layout.addLayout(btns)

    def get_user(self) -> Dict[str, str]:
        return {
            "Email": self.email_input.text().strip().lower(),
            "Name": self.fio_input.text().strip(),
            "Phone": self.phone_input.text().strip(),
            "Role": self.role_combo.currentText().strip(),
            "Telegram": self.tg_input.text().strip(),
            "Group": self.group_combo.currentText().strip(),
            "NotifyTelegram": "Yes" if self.tg_notify_chk.isChecked() else "No",
        }

# =================== –ì–ª–∞–≤–Ω–æ–µ –æ–∫–Ω–æ ===================

class AdminWindow(QMainWindow):
    def __init__(self, groups: List[str]):
        super().__init__()
        self.setWindowTitle("–ê–¥–º–∏–Ω–∫–∞ WorkTimeTracker")
        self.resize(1400, 780)
        
        # –ì—Ä—É–ø–ø—ã
        self.groups = groups

        # –†–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π
        self.repo = AdminRepo()

        # –ö—ç—à –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏ –∞–∫—Ç–∏–≤–Ω—ã—Ö e-mail
        self.users: List[Dict[str, str]] = []
        self._active_cache: Tuple[float, set[str]] = (0.0, set())  # (ts, {emails})
        self._active_ttl_sec = 30.0

        self._build_ui()
        self.refresh_users()
        self.load_shift_calendar()

    # ---------- UI ----------
    def _build_ui(self):
        self.tabs = QTabWidget(self)

        # --- –í–∫–ª–∞–¥–∫–∞ "–°–æ—Ç—Ä—É–¥–Ω–∏–∫–∏" ---
        self.tab_users = QWidget()
        users_layout = QVBoxLayout(self.tab_users)

        # –§–∏–ª—å—Ç—Ä—ã
        filter_layout = QHBoxLayout()
        filter_layout.addWidget(QLabel("–ì—Ä—É–ø–ø–∞:"))
        self.group_filter_combo = QComboBox()
        self.group_filter_combo.addItem("–í—Å–µ –≥—Ä—É–ø–ø—ã")
        self.group_filter_combo.addItems(self.groups)
        self.group_filter_combo.currentIndexChanged.connect(self.apply_user_search)
        filter_layout.addWidget(self.group_filter_combo)

        self.only_active_chk = QCheckBox("–¢–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ")
        self.only_active_chk.stateChanged.connect(self.apply_user_search)
        filter_layout.addWidget(self.only_active_chk)

        filter_layout.addStretch()
        users_layout.addLayout(filter_layout)

        # –ü–æ–∏—Å–∫ –∏ –∫–Ω–æ–ø–∫–∏
        top_layout = QHBoxLayout()
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("–ü–æ–∏—Å–∫ –ø–æ –§–ò–û –∏–ª–∏ email")
        self.search_input.textChanged.connect(self.apply_user_search)
        top_layout.addWidget(self.search_input)

        btn_add = QPushButton("–î–æ–±–∞–≤–∏—Ç—å")
        btn_add.clicked.connect(self.add_user)
        btn_edit = QPushButton("–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å")
        btn_edit.clicked.connect(self.edit_user)
        btn_delete = QPushButton("–£–¥–∞–ª–∏—Ç—å")
        btn_delete.clicked.connect(self.on_delete_user_clicked)
        btn_kick = QPushButton("–†–∞–∑–ª–æ–≥–∏–Ω–∏—Ç—å")
        btn_kick.clicked.connect(self.on_force_logout_clicked)

        for b in (btn_add, btn_edit, btn_delete, btn_kick):
            top_layout.addWidget(b)
        users_layout.addLayout(top_layout)

        # –¢–∞–±–ª–∏—Ü–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        self.users_table = QTableWidget(0, len(FIELDS))
        self.users_table.setHorizontalHeaderLabels(
            ["Email", "–§–ò–û", "–¢–µ–ª–µ—Ñ–æ–Ω", "–î–æ–ª–∂–Ω–æ—Å—Ç—å", "Telegram", "–ì—Ä—É–ø–ø–∞", "Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è"]
        )
        self.users_table.setSelectionBehavior(QTableWidget.SelectRows)
        users_layout.addWidget(self.users_table)

        self.tabs.addTab(self.tab_users, "–°–æ—Ç—Ä—É–¥–Ω–∏–∫–∏")

        # --- –í–∫–ª–∞–¥–∫–∞ "–ì—Ä–∞—Ñ–∏–∫" ---
        self.tab_schedule = QWidget()
        schedule_layout = QVBoxLayout(self.tab_schedule)

        header_layout = QHBoxLayout()
        header_layout.addWidget(QLabel("–°–æ—Ç—Ä—É–¥–Ω–∏–∫:"))
        self.schedule_user_combo = QComboBox()
        self.schedule_user_combo.addItem("–í—ã–±–µ—Ä–∏—Ç–µ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞")
        self.schedule_user_combo.currentIndexChanged.connect(self.on_schedule_user_change)
        header_layout.addWidget(self.schedule_user_combo)
        header_layout.addStretch()
        schedule_layout.addLayout(header_layout)

        self.info_group = QGroupBox("–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–µ")
        info_layout = QVBoxLayout()
        self.login_status_lbl = QLabel("–ó–∞–ª–æ–≥–∏–Ω–µ–Ω: –ù–µ—Ç")
        self.btn_force_logout = QPushButton("–†–∞–∑–ª–æ–≥–∏–Ω–∏—Ç—å")
        self.btn_force_logout.setEnabled(False)
        self.btn_force_logout.clicked.connect(self.force_logout_from_schedule)
        status_row = QHBoxLayout()
        status_row.addWidget(self.login_status_lbl)
        status_row.addWidget(self.btn_force_logout)
        status_row.addStretch()
        info_layout.addLayout(status_row)

        self.info_label = QLabel("")
        self.info_label.setWordWrap(True)
        info_layout.addWidget(self.info_label)
        self.info_group.setLayout(info_layout)
        schedule_layout.addWidget(self.info_group)

        self.schedule_table = QTableWidget()
        schedule_layout.addWidget(self.schedule_table)

        self.tabs.addTab(self.tab_schedule, "–ì—Ä–∞—Ñ–∏–∫")

        # --- –í–∫–ª–∞–¥–∫–∞ "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ" (–ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä) ---
        self.tab_extra = QWidget()
        extra_layout = QVBoxLayout(self.tab_extra)
        extra_layout.addWidget(QLabel("–¢—É—Ç –±—É–¥–µ—Ç —á—Ç–æ-—Ç–æ –µ—â—ë"))
        self.tabs.addTab(self.tab_extra, "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ")

        self.setCentralWidget(self.tabs)

    # ---------- Helpers ----------
    def _selected_email(self) -> Optional[str]:
        items = self.users_table.selectedItems()
        if not items:
            return None
        val = items[0].text().strip()
        return val[2:] if val.startswith("üü¢ ") else val

    def _confirm(self, msg: str) -> bool:
        return QMessageBox.question(self, "–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ", msg, QMessageBox.Yes | QMessageBox.No, QMessageBox.No) == QMessageBox.Yes

    def _info(self, msg: str):
        QMessageBox.information(self, "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è", msg)

    def _warn(self, msg: str):
        QMessageBox.warning(self, "–û—à–∏–±–∫–∞", msg)

    # ---------- –ê–∫—Ç–∏–≤–Ω—ã–µ —Å–µ—Å—Å–∏–∏ (–∫—ç—à) ----------
    def _get_active_emails_cached(self) -> set[str]:
        ts, emails = self._active_cache
        if time.monotonic() - ts < self._active_ttl_sec:
            return emails
        try:
            sessions = self.repo.get_active_sessions()
            emails = {str(s.get("Email", "")).strip().lower() for s in sessions if str(s.get("Status", "")).strip().lower() == "active"}
            self._active_cache = (time.monotonic(), emails)
            return emails
        except Exception as e:
            logger.warning("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–µ —Å–µ—Å—Å–∏–∏: %s", e)
            return set()

    # =================== –¢–∞–± "–°–æ—Ç—Ä—É–¥–Ω–∏–∫–∏" ===================

    def refresh_users(self):
        try:
            rows = self.repo.list_users()
        except Exception as e:
            logger.exception("refresh_users failed: %s", e)
            rows = []

        self.users = []
        for r in rows:
            nt = str(r.get("NotifyTelegram", "")).strip().lower()
            nt_norm = "Yes" if nt in ("yes", "true", "1", "–¥–∞") else "No"
            self.users.append({
                "Email": str(r.get("Email", "")),
                "Name": str(r.get("Name", "")),
                "Phone": str(r.get("Phone", "")),
                "Role": str(r.get("Role", "")),
                "Telegram": str(r.get("Telegram", "")),
                "Group": str(r.get("Group", "")),
                "NotifyTelegram": nt_norm,
            })

        # –∑–∞–ø–æ–ª–Ω—è–µ–º —Ç–∞–±–ª–∏—Ü—É
        self.refresh_users_table()

        # –∏ –≤—ã–ø–∞–¥–∞—é—â–∏–π —Å–ø–∏—Å–æ–∫ –Ω–∞ –≤–∫–ª–∞–¥–∫–µ "–ì—Ä–∞—Ñ–∏–∫"
        self.schedule_user_combo.blockSignals(True)
        self.schedule_user_combo.clear()
        self.schedule_user_combo.addItem("–í—ã–±–µ—Ä–∏—Ç–µ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞")
        for u in self.users:
            fio = u.get("Name", "")
            if fio:
                self.schedule_user_combo.addItem(fio)
        self.schedule_user_combo.blockSignals(False)

    def refresh_users_table(self, filter_text: str = ""):
        self.users_table.setRowCount(0)
        selected_group = self.group_filter_combo.currentText()
        only_active = self.only_active_chk.isChecked()
        active_emails = self._get_active_emails_cached() if only_active else set()

        for u in self.users:
            email = u.get("Email", "").strip().lower()
            group = u.get("Group", "").strip()
            is_active = email in active_emails

            # –ø–æ–∏—Å–∫
            if filter_text:
                q = filter_text.lower()
                if q not in email and q not in u.get("Name", "").lower():
                    continue
            # —Ñ–∏–ª—å—Ç—Ä –ø–æ –≥—Ä—É–ø–ø–µ
            if selected_group != "–í—Å–µ –≥—Ä—É–ø–ø—ã" and group != selected_group:
                continue
            # —Ñ–∏–ª—å—Ç—Ä –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
            if only_active and not is_active:
                continue

            row = self.users_table.rowCount()
            self.users_table.insertRow(row)
            for col, key in enumerate(FIELDS):
                val = u.get(key, "")
                if key == "Email" and is_active:
                    val = f"üü¢ {val}"
                item = QTableWidgetItem(str(val))
                item.setFlags(Qt.ItemIsEnabled | Qt.ItemIsSelectable)
                self.users_table.setItem(row, col, item)

    def apply_user_search(self):
        self.refresh_users_table(self.search_input.text())

    # --- CRUD/Actions ---

    def add_user(self):
        dlg = UserDialog(self, groups=self.groups)
        if dlg.exec_():
            data = dlg.get_user()
            if self.repo.add_or_update_user(data):
                self._info("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–æ–±–∞–≤–ª–µ–Ω")
                self.refresh_users()
            else:
                self._warn("–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")

    def edit_user(self):
        row = self.users_table.currentRow()
        if row < 0 or row >= len(self.users):
            self._warn("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ —Å—Ç—Ä–æ–∫—É –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.")
            return
        user = self.users[row]
        dlg = UserDialog(self, user=user, groups=self.groups)
        if dlg.exec_():
            data = dlg.get_user()
            if self.repo.add_or_update_user(data):
                self._info("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ–±–Ω–æ–≤–ª—ë–Ω")
                self.refresh_users()
            else:
                self._warn("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")

    def on_delete_user_clicked(self):
        email = self._selected_email()
        if not email:
            self._warn("–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
            return
        if not self._confirm(f"–£–¥–∞–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {email}?"):
            return
        if self.repo.delete_user(email):
            self._info("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–¥–∞–ª—ë–Ω")
            self.refresh_users()
        else:
            self._warn("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ —É–¥–∞–ª—ë–Ω")

    def on_force_logout_clicked(self):
        email = self._selected_email()
        if not email:
            self._warn("–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ —Å–ø–∏—Å–∫–∞.")
            return

        # –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º –§–ò–û –¥–ª—è –∫—Ä–∞—Å–æ—Ç—ã
        fio = ""
        sel = self.users_table.selectedItems()
        if sel and len(sel) > 1:
            fio = sel[1].text()

        if not self._confirm(f"–†–∞–∑–ª–æ–≥–∏–Ω–∏—Ç—å {fio or email}?"):
            return

        if self.repo.force_logout(email=email):
            self._info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {fio or email} –±—ã–ª —Ä–∞–∑–ª–æ–≥–∏–Ω–µ–Ω.")
            # —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –∫—ç—à –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–µ–π, —á—Ç–æ–±—ã —Ç–∞–±–ª–∏—Ü–∞ –æ–±–Ω–æ–≤–∏–ª–∞—Å—å –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
            self._active_cache = (0.0, set())
            self.refresh_users()
        else:
            self._warn("–ê–∫—Ç–∏–≤–Ω–∞—è —Å–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")

    # =================== –¢–∞–± "–ì—Ä–∞—Ñ–∏–∫" ===================

    def load_shift_calendar(self):
        """–ü–æ–¥—Ç—è–≥–∏–≤–∞–µ–º —Ç–∞–±–ª–∏—Ü—É –≥—Ä–∞—Ñ–∏–∫–∞. –ï—Å–ª–∏ –µ—ë –Ω–µ—Ç ‚Äî –æ—Ç–∫–ª—é—á–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã."""
        try:
            data = self.repo.get_shift_calendar()
        except Exception as e:
            logger.exception("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –≥—Ä–∞—Ñ–∏–∫–∞: %s", e)
            data = []

        self.shift_calendar_data: List[List[str]] = data
        self.shift_headers: List[str] = data[0] if data else []

        if not data:
            self.info_label.setText("–õ–∏—Å—Ç –≥—Ä–∞—Ñ–∏–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –ø—É—Å—Ç.")
            self.login_status_lbl.setText("–ó–∞–ª–æ–≥–∏–Ω–µ–Ω: –ù–µ—Ç")
            self.btn_force_logout.setEnabled(False)
            self.schedule_table.setRowCount(0)
            self.schedule_table.setColumnCount(0)
            self.schedule_user_combo.setEnabled(bool(self.users))
            return

        self.schedule_user_combo.setEnabled(True)

    def on_schedule_user_change(self):
        idx = self.schedule_user_combo.currentIndex()
        if idx <= 0 or not self.shift_calendar_data:
            self.schedule_table.setRowCount(0)
            self.schedule_table.setColumnCount(0)
            self.info_label.setText("")
            self.login_status_lbl.setText("–ó–∞–ª–æ–≥–∏–Ω–µ–Ω: –ù–µ—Ç")
            self.btn_force_logout.setEnabled(False)
            return

        fio = self.schedule_user_combo.currentText()
        email = ""
        for u in self.users:
            if u.get("Name", "") == fio:
                email = u.get("Email", "")
                break

        # —Å—Ç–∞—Ç—É—Å –ª–æ–≥–∏–Ω–∞
        active = self._get_active_emails_cached()
        is_logged_in = email.strip().lower() in active
        self.login_status_lbl.setText(f"–ó–∞–ª–æ–≥–∏–Ω–µ–Ω: {'–î–∞' if is_logged_in else '–ù–µ—Ç'}")
        self.btn_force_logout.setEnabled(is_logged_in)
        self.btn_force_logout.setProperty("user_email", email)
        self.btn_force_logout.setProperty("user_fio", fio)

        # –∏–Ω—Ñ–æ –ø–æ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫—É
        info_parts = [f"<b>–§–ò–û:</b> {fio}", f"<b>Email:</b> {email}"]
        self.info_label.setText("<br>".join(info_parts))

        # —Ç–∞–±–µ–ª—å –ø–æ –¥–Ω—è–º (–∏—â–µ–º –ø–µ—Ä–≤—ã–µ —á–∏—Å–ª–æ–≤—ã–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏ –∫–∞–∫ –¥–Ω–∏ –º–µ—Å—è—Ü–∞)
        headers = self.shift_headers
        row_for_user: Optional[List[str]] = None
        for r in self.shift_calendar_data[1:]:
            if r and r[0].strip() == fio:
                row_for_user = r
                break

        day_indices = [(i, h) for i, h in enumerate(headers) if str(h).isdigit()]
        self.schedule_table.setRowCount(0)
        self.schedule_table.setColumnCount(len(day_indices))
        self.schedule_table.setHorizontalHeaderLabels([str(h) for _, h in day_indices])

        if row_for_user:
            self.schedule_table.setRowCount(1)
            for col, (i, _) in enumerate(day_indices):
                val = row_for_user[i] if i < len(row_for_user) else ""
                self.schedule_table.setItem(0, col, QTableWidgetItem(str(val)))
            self.schedule_table.resizeColumnsToContents()

    def force_logout_from_schedule(self):
        email = self.btn_force_logout.property("user_email")
        fio = self.btn_force_logout.property("user_fio")
        if not email:
            self._warn("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å Email –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.")
            return
        if not self._confirm(f"–†–∞–∑–ª–æ–≥–∏–Ω–∏—Ç—å {fio or email}?"):
            return

        if self.repo.force_logout(email=email):
            self._info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {fio or email} —Ä–∞–∑–ª–æ–≥–∏–Ω–µ–Ω.")
            self.btn_force_logout.setEnabled(False)
            self.login_status_lbl.setText("–ó–∞–ª–æ–≥–∏–Ω–µ–Ω: –ù–µ—Ç")
            # —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –∫—ç—à –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–µ–π
            self._active_cache = (0.0, set())
            self.refresh_users()
        else:
            self._warn("–ê–∫—Ç–∏–≤–Ω–∞—è —Å–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")

# =================== –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ ===================

def get_available_groups(repo: AdminRepo) -> list[str]:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –≥—Ä—É–ø–ø"""
    if GROUP_MAPPING:
        return sorted(set(GROUP_MAPPING.values()))
    return repo.list_groups_from_sheet()

# =================== Entrypoint ===================

def main():
    # –ï–¥–∏–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –∞–¥–º–∏–Ω–∫–∏
    log_path = setup_logging(app_name="wtt-admin", log_dir=LOG_DIR)
    logger = logging.getLogger(__name__)
    logger.info("Admin app logging initialized (path=%s)", log_path)
    
    # –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –≥—Ä—É–ø–ø
    repo = AdminRepo()
    groups = get_available_groups(repo)
    logger.info("Groups: %s", ", ".join(groups) if groups else "<none>")
    
    # –ó–∞–ø—É—Å–∫ GUI —Å –ø–µ—Ä–µ–¥–∞—á–µ–π —Å–ø–∏—Å–∫–∞ –≥—Ä—É–ø–ø
    app = QApplication(sys.argv)
    win = AdminWindow(groups=groups)
    win.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()

--------------------------------------------------------------------------------
# FILE: admin_app\repo.py
# SIZE: 8954 bytes | SHA256(text): 4a8ef84d5b996624f84258294e093fd05e5cc30c7b2ab55b47d86761e409c0ed
--------------------------------------------------------------------------------
# admin_app/repo.py
from __future__ import annotations

import logging
from typing import List, Dict, Optional
from datetime import datetime, timezone

from sheets_api import SheetsAPI, SheetsAPIError
from config import (
    GOOGLE_SHEET_NAME,
    USERS_SHEET,
    ACTIVE_SESSIONS_SHEET,
)

logger = logging.getLogger(__name__)

# –í–æ–∑–º–æ–∂–Ω—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è –ª–∏—Å—Ç–∞ —Å –≥—Ä–∞—Ñ–∏–∫–æ–º (–ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—É)
CANDIDATE_SCHEDULE_TITLES = ["ShiftCalendar", "Schedule", "–ì—Ä–∞—Ñ–∏–∫"]


class AdminRepo:
    """
    –†–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π.
    –í—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –∏–¥—É—Ç —á–µ—Ä–µ–∑ —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π SheetsAPI (—Ä–µ—Ç—Ä–∞–∏/–∫–≤–æ—Ç—ã/–ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ).
    """

    def __init__(self, sheets: Optional[SheetsAPI] = None):
        self.sheets = sheets or SheetsAPI()

    # -------------------------------------------------------------------------
    # Users
    # -------------------------------------------------------------------------
    def list_users(self) -> List[Dict[str, str]]:
        """
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∫–∞–∫ —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤–∞—Ä–µ–π (–∫–æ–ª–æ–Ω–∫–∏ –ø–æ –∑–∞–≥–æ–ª–æ–≤–∫—É –ª–∏—Å—Ç–∞ Users).
        """
        try:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤—ã—Å–æ–∫–æ—É—Ä–æ–≤–Ω–µ–≤—ã–π –º–µ—Ç–æ–¥ SheetsAPI, —á—Ç–æ–±—ã –Ω–µ –¥—É–±–ª–∏—Ä–æ–≤–∞—Ç—å –ª–æ–≥–∏–∫—É
            users = self.sheets.get_users()  # type: ignore[attr-defined]
            return users or []
        except AttributeError:
            # –§–æ–ª–±—ç–∫, –µ—Å–ª–∏ –≤–¥—Ä—É–≥ –Ω–µ—Ç get_users() (—Å—Ç–∞—Ä—ã–π SheetsAPI)
            ws = self.sheets.get_worksheet(USERS_SHEET)
            values = self.sheets._request_with_retry(ws.get_all_values)
            if not values:
                return []
            header = values[0]
            out: List[Dict[str, str]] = []
            for row in values[1:]:
                if any((c or "").strip() for c in row):
                    out.append({header[i]: (row[i] if i < len(header) else "") for i in range(len(header))})
            return out
        except Exception as e:
            logger.exception("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: %s", e)
            return []

    def add_or_update_user(self, user: Dict[str, str]) -> bool:
        """
        –î–æ–±–∞–≤–ª—è–µ—Ç –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–ø–æ Email).
        """
        try:
            self.sheets.upsert_user(user)  # type: ignore[attr-defined]
            return True
        except AttributeError:
            # –§–æ–ª–±—ç–∫ –Ω–∞ —Å—Ç–∞—Ä—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å ‚Äî –ø—Ä–æ–±—É–µ–º –æ–±–Ω–æ–≤–∏—Ç—å –Ω–∞–±–æ—Ä –ø–æ–ª–µ–π
            try:
                email = user.get("Email") or user.get("email")
                if not email:
                    raise ValueError("user.Email is required")
                fields = {k: v for k, v in user.items() if k != "Email"}
                self.sheets.update_user_fields(email=email, fields=fields)  # type: ignore[attr-defined]
                return True
            except Exception as e:
                logger.exception("Fallback upsert_user failed: %s", e)
                return False
        except Exception as e:
            logger.exception("add_or_update_user error: %s", e)
            return False

    def delete_user(self, email: str) -> bool:
        """
        –£–¥–∞–ª—è–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ Email.
        """
        try:
            return bool(self.sheets.delete_user(email))  # type: ignore[attr-defined]
        except Exception as e:
            logger.exception("delete_user error for %s: %s", email, e)
            return False

    # -------------------------------------------------------------------------
    # Groups
    # -------------------------------------------------------------------------
    def list_groups_from_sheet(self) -> list[str]:
        """
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –≥—Ä—É–ø–ø –∏–∑ –ª–∏—Å—Ç–∞ 'Groups' (–∫–æ–ª–æ–Ω–∫–∞ 'Group').
        –ü—É—Å—Ç—ã–µ/–¥—É–±–ª–∏–∫–∞—Ç—ã —Ñ–∏–ª—å—Ç—Ä—É—é—Ç—Å—è.
        """
        try:
            ws = self.sheets.get_worksheet("Groups")
            values = self.sheets._request_with_retry(ws.get_all_values)
            groups = []
            for row in values[1:]:  # –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫
                if not row:
                    continue
                g = (row[0] or "").strip()
                if g:
                    groups.append(g)
            return sorted(set(groups))
        except Exception as e:
            logger.warning("list_groups_from_sheet failed: %s", e)
            return []

    # -------------------------------------------------------------------------
    # Active sessions
    # -------------------------------------------------------------------------
    def get_active_sessions(self) -> List[Dict]:
        """
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Å–µ –∑–∞–ø–∏—Å–∏ –ª–∏—Å—Ç–∞ ActiveSessions (—Å–ª–æ–≤–∞—Ä–∏ –∫–æ–ª–æ–Ω–æ–∫).
        """
        try:
            sessions = self.sheets.get_all_active_sessions()  # type: ignore[attr-defined]
            return sessions or []
        except Exception as e:
            logger.exception("get_active_sessions error: %s", e)
            return []

    def force_logout(self, email: str) -> bool:
        """
        –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∑–∞–≤–µ—Ä—à–∞–µ—Ç –ü–û–°–õ–ï–î–ù–Æ–Æ –∞–∫—Ç–∏–≤–Ω—É—é —Å–µ—Å—Å–∏—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç True, –µ—Å–ª–∏ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å —Å—Ç—Ä–æ–∫—É.
        """
        try:
            ok = self.sheets.kick_active_session(email=email)  # type: ignore[attr-defined]
            if ok:
                logger.info("Force logout success for %s", email)
            else:
                logger.info("Force logout: –∞–∫—Ç–∏–≤–Ω–∞—è —Å–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –¥–ª—è %s", email)
            return bool(ok)
        except Exception as e:
            logger.exception("force_logout error for %s: %s", email, e)
            return False

    # -------------------------------------------------------------------------
    # Schedule (Shift calendar)
    # -------------------------------------------------------------------------
    def _list_titles(self) -> List[str]:
        """
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –Ω–∞–∑–≤–∞–Ω–∏–π –ª–∏—Å—Ç–æ–≤ –∫–Ω–∏–≥–∏.
        """
        try:
            if hasattr(self.sheets, "list_worksheet_titles"):
                return list(self.sheets.list_worksheet_titles())  # type: ignore[attr-defined]
        except Exception:
            pass

        # –§–æ–ª–±—ç–∫ —á–µ—Ä–µ–∑ –æ—Ç–∫—Ä—ã—Ç—É—é –∫–Ω–∏–≥—É
        try:
            spreadsheet = self.sheets._request_with_retry(self.sheets.client.open, GOOGLE_SHEET_NAME)
            worksheets = self.sheets._request_with_retry(spreadsheet.worksheets)
            return [ws.title for ws in worksheets]
        except Exception as e:
            logger.warning("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ª–∏—Å—Ç–æ–≤: %s", e)
            return []

    def _pick_schedule_title(self, titles: List[str]) -> Optional[str]:
        """
        –í—ã–±–∏—Ä–∞–µ—Ç –Ω–∞–∑–≤–∞–Ω–∏–µ –ª–∏—Å—Ç–∞ –≥—Ä–∞—Ñ–∏–∫–∞ –∏–∑ –∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤.
        """
        available = set(titles)
        for cand in CANDIDATE_SCHEDULE_TITLES:
            if cand in available:
                return cand
        return None

    def get_shift_calendar(self) -> List[List[str]]:
        """
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–∞–±–ª–∏—Ü—É –≥—Ä–∞—Ñ–∏–∫–∞ –∫–∞–∫ —Å–ø–∏—Å–æ–∫ —Å–ø–∏—Å–∫–æ–≤:
        [ [header...], [row1...], ... ]. –ï—Å–ª–∏ –ª–∏—Å—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç ‚Äî [].
        """
        try:
            titles = self._list_titles()
            if not titles:
                logger.info("–í –∫–Ω–∏–≥–µ '%s' –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –ª–∏—Å—Ç–æ–≤.", GOOGLE_SHEET_NAME)
                return []

            name = self._pick_schedule_title(titles)
            if not name:
                logger.info(
                    "–õ–∏—Å—Ç –≥—Ä–∞—Ñ–∏–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω. –û–∂–∏–¥–∞–ª–∏—Å—å: %s; –µ—Å—Ç—å: %s",
                    ", ".join(CANDIDATE_SCHEDULE_TITLES),
                    ", ".join(titles),
                )
                return []

            ws = self.sheets.get_worksheet(name)
            values = self.sheets._request_with_retry(ws.get_all_values)
            return values or []
        except SheetsAPIError as e:
            logger.warning("–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –ª–∏—Å—Ç—É –≥—Ä–∞—Ñ–∏–∫–∞: %s", e)
            return []
        except Exception as e:
            logger.exception("get_shift_calendar error: %s", e)
            return []

--------------------------------------------------------------------------------
# FILE: admin_app\schedule_parser.py
# SIZE: 4599 bytes | SHA256(text): 5f71b0fd877ad4c30a0ff770ef0ca2e0c748c080591488fa53c0ca65c9fb27c6
--------------------------------------------------------------------------------
# admin_app/schedule_parser.py
"""
DEPRECATED: –ø–æ–º–æ–≥–∞–µ—Ç —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å, –Ω–æ –Ω–µ –¥–æ–ª–∂–µ–Ω –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –≤ –Ω–æ–≤–æ–º –∫–æ–¥–µ.
–¢–µ–ø–µ—Ä—å –≥—Ä–∞—Ñ–∏–∫ —á–∏—Ç–∞–µ—Ç—Å—è —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ —á–µ—Ä–µ–∑ SheetsAPI / AdminRepo.get_shift_calendar().

–ï—Å–ª–∏ –º–æ–¥—É–ª—å –≤—Å—ë –µ—â—ë –∏–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è —Å—Ç–∞—Ä—ã–º–∏ —É—á–∞—Å—Ç–∫–∞–º–∏ –∫–æ–¥–∞, —Ñ—É–Ω–∫—Ü–∏–∏ –Ω–∏–∂–µ –¥–µ–ª–µ–≥–∏—Ä—É—é—Ç —á—Ç–µ–Ω–∏–µ
–≤ Google Sheets —á–µ—Ä–µ–∑ SheetsAPI (–±–µ–∑ pandas/requests –∏ –±–µ–∑ –ø—Ä—è–º—ã—Ö gspread-–≤—ã–∑–æ–≤–æ–≤).
"""

from __future__ import annotations
from typing import List, Optional
import logging
from pathlib import Path
import sys

# –î–æ–±–∞–≤–ª—è–µ–º –∫–æ—Ä–µ–Ω—å –ø—Ä–æ–µ–∫—Ç–∞ –≤ sys.path, —á—Ç–æ–±—ã –±—ã–ª–∏ –¥–æ—Å—Ç—É–ø–Ω—ã config –∏ sheets_api –ø—Ä–∏ –ø—Ä—è–º–æ–º –∑–∞–ø—É—Å–∫–µ
ROOT_PATH = str(Path(__file__).parent.parent.resolve())
if ROOT_PATH not in sys.path:
    sys.path.insert(0, ROOT_PATH)

from sheets_api import SheetsAPI, SheetsAPIError  # —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π —Å–ª–æ–π
from config import GOOGLE_SHEET_NAME  # —Ç–æ–ª—å–∫–æ –¥–ª—è —Å–æ–æ–±—â–µ–Ω–∏–π

logger = logging.getLogger(__name__)
if not logger.hasHandlers():
    logging.basicConfig(level=logging.INFO)

# –í–æ–∑–º–æ–∂–Ω—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è –ª–∏—Å—Ç–∞ —Å –≥—Ä–∞—Ñ–∏–∫–æ–º (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –ø–æ –ø–æ—Ä—è–¥–∫—É)
CANDIDATE_SCHEDULE_TITLES = ["ShiftCalendar", "Schedule", "–ì—Ä–∞—Ñ–∏–∫"]


def _list_titles(sheets: SheetsAPI) -> List[str]:
    """–ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –Ω–∞–∑–≤–∞–Ω–∏–π –ª–∏—Å—Ç–æ–≤ —á–µ—Ä–µ–∑ SheetsAPI, —Å —Ñ–æ–ª–±—ç–∫–æ–º."""
    try:
        # –ù–æ–≤–∞—è –≤–µ—Ä—Å–∏—è SheetsAPI –º–æ–∂–µ—Ç –∏–º–µ—Ç—å list_worksheet_titles()
        if hasattr(sheets, "list_worksheet_titles"):
            return list(sheets.list_worksheet_titles())  # type: ignore
    except Exception:
        pass

    # –§–æ–ª–±—ç–∫: –Ω–∞–ø—Ä—è–º—É—é —á–µ—Ä–µ–∑ –æ—Ç–∫—Ä—ã—Ç—É—é –∫–Ω–∏–≥—É (–≤—Å—ë —Ä–∞–≤–Ω–æ —á–µ—Ä–µ–∑ _request_with_retry)
    try:
        spreadsheet = sheets._request_with_retry(sheets.client.open, GOOGLE_SHEET_NAME)
        worksheets = sheets._request_with_retry(spreadsheet.worksheets)
        return [ws.title for ws in worksheets]
    except Exception as e:
        logger.warning("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ª–∏—Å—Ç–æ–≤: %s", e)
        return []


def _pick_schedule_sheet_title(titles: List[str]) -> Optional[str]:
    """–í—ã–±–∏—Ä–∞–µ–º –ø–µ—Ä–≤—ã–π –ø–æ–¥—Ö–æ–¥—è—â–∏–π –ª–∏—Å—Ç –∏–∑ –∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤."""
    tset = set(titles)
    for cand in CANDIDATE_SCHEDULE_TITLES:
        if cand in tset:
            return cand
    return None


def get_shift_calendar() -> List[List[str]]:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç ¬´—Ç–∞–±–ª–∏—Ü—É –≥—Ä–∞—Ñ–∏–∫–∞¬ª –∫–∞–∫ —Å–ø–∏—Å–æ–∫ —Å–ø–∏—Å–∫–æ–≤: [ [header...], [row1...], ... ].
    –ï—Å–ª–∏ –ª–∏—Å—Ç –≥—Ä–∞—Ñ–∏–∫–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç ‚Äî –≤–µ—Ä–Ω—ë—Ç [].
    –í –Ω–æ–≤–æ–º –∫–æ–¥–µ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ AdminRepo.get_shift_calendar().
    """
    sheets = SheetsAPI()

    titles = _list_titles(sheets)
    if not titles:
        logger.info("–í –∫–Ω–∏–≥–µ '%s' –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –Ω–∏ –æ–¥–Ω–æ–≥–æ –ª–∏—Å—Ç–∞.", GOOGLE_SHEET_NAME)
        return []

    sheet_name = _pick_schedule_sheet_title(titles)
    if not sheet_name:
        logger.info(
            "–õ–∏—Å—Ç –≥—Ä–∞—Ñ–∏–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω. –û–∂–∏–¥–∞–ª–∏—Å—å –æ–¥–∏–Ω –∏–∑: %s; –µ—Å—Ç—å: %s",
            ", ".join(CANDIDATE_SCHEDULE_TITLES), ", ".join(titles),
        )
        return []

    try:
        ws = sheets.get_worksheet(sheet_name)
        values = sheets._request_with_retry(ws.get_all_values)
        if not values:
            logger.info("–õ–∏—Å—Ç '%s' –ø—É—Å—Ç–æ–π.", sheet_name)
            return []
        return values
    except SheetsAPIError as e:
        logger.warning("–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –ª–∏—Å—Ç—É '%s': %s", sheet_name, e)
        return []
    except Exception as e:
        logger.exception("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å –ª–∏—Å—Ç '%s': %s", sheet_name, e)
        return []


# –î–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å–æ —Å—Ç–∞—Ä—ã–º –∏–º–µ–Ω–µ–º
def get_shift_info() -> List[List[str]]:
    """–°—Ç–∞—Ä–æ–µ –∏–º—è —Ñ—É–Ω–∫—Ü–∏–∏, –æ—Å—Ç–∞–≤–ª–µ–Ω–æ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏."""
    logger.warning("schedule_parser.get_shift_info() —É—Å—Ç–∞—Ä–µ–ª–∞ ‚Äî –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ AdminRepo.get_shift_calendar().")
    return get_shift_calendar()

--------------------------------------------------------------------------------
# FILE: archiver.py
# SIZE: 7712 bytes | SHA256(text): bdfd07e45105c2a0c310884e7ac82791d9cabb3eccfefbe7f52395601d450874
--------------------------------------------------------------------------------
# archiver.py (reworked to use centralized SheetsAPI only)
from __future__ import annotations

import sys
import os
from pathlib import Path
from datetime import datetime, timedelta, timezone
from typing import List, Tuple, Optional, Dict
import logging
import argparse

# Ensure project root is importable (so we can import config and sheets_api when run directly)
ROOT_PATH = str(Path(__file__).parent.resolve())
if ROOT_PATH not in sys.path:
    sys.path.insert(0, ROOT_PATH)

from config import GOOGLE_SHEET_NAME, WORKLOG_SHEET, ARCHIVE_SHEET  # type: ignore
from sheets_api import SheetsAPI, SheetsAPIError  # type: ignore

logger = logging.getLogger(__name__)


# ---- helpers ----

TS_HEADER_CANDIDATES = ("timestamp", "Timestamp", "time", "Time", "–î–∞—Ç–∞", "–í—Ä–µ–º—è", "DateTime", "datetime")

def _parse_ts(s: str) -> Optional[datetime]:
    """
    Parse timestamp in flexible formats. Prefer ISO-8601 with timezone.
    Returns timezone-aware datetime in local timezone for date comparison.
    """
    s = (s or "").strip()
    if not s:
        return None
    fmts = [
        "%Y-%m-%dT%H:%M:%S%z",
        "%Y-%m-%dT%H:%M:%S.%f%z",
        "%Y-%m-%d %H:%M:%S%z",
        "%Y-%m-%d %H:%M:%S",
        "%d.%m.%Y %H:%M:%S",
        "%d.%m.%Y",
        "%Y-%m-%d",
    ]
    for f in fmts:
        try:
            dt = datetime.strptime(s, f)
            if dt.tzinfo is None:
                dt = dt.replace(tzinfo=timezone.utc)
            return dt.astimezone()
        except Exception:
            continue
    try:
        dt = datetime.fromisoformat(s)
        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=timezone.utc)
        return dt.astimezone()
    except Exception:
        return None


def _yesterday_local(base: Optional[datetime] = None) -> datetime.date:
    now_local = (base or datetime.now().astimezone())
    return (now_local.date() - timedelta(days=1))


def _find_timestamp_index(header: List[str]) -> Optional[int]:
    idx_map = { (h or "").strip(): i for i, h in enumerate(header) }
    for key in TS_HEADER_CANDIDATES:
        for h,i in idx_map.items():
            if h.lower() == key.lower():
                return i
    if len(header) >= 6 and header[5].lower().startswith("time"):
        return 5
    return None


def _ensure_archive_sheet(sheets: SheetsAPI, header: List[str]) -> object:
    """
    Get archive worksheet; if missing ‚Äî create and put header.
    """
    try:
        ws = sheets.get_worksheet(ARCHIVE_SHEET)
        values = sheets._request_with_retry(ws.get_all_values)
        if not values:
            sheets._request_with_retry(ws.update, "A1", [header])
        elif values and values[0] != header:
            pass
        return ws
    except SheetsAPIError:
        from config import GOOGLE_SHEET_NAME  # lazy import
        spreadsheet = sheets._request_with_retry(sheets.client.open, GOOGLE_SHEET_NAME)
        ws = sheets._request_with_retry(spreadsheet.add_worksheet, title=ARCHIVE_SHEET, rows=1, cols=max(1, len(header)))
        sheets._request_with_retry(ws.update, "A1", [header])
        return ws


def _collect_rows_for_date(values: List[List[str]], day: datetime.date) -> Tuple[List[List[str]], List[List[str]], List[str]]:
    """
    Split table rows to (to_archive, to_keep).
    Returns (to_archive_rows, keep_rows, header)
    """
    if not values:
        return [], [], []

    header = values[0]
    body = values[1:]
    ts_idx = _find_timestamp_index(header)
    if ts_idx is None:
        logger.warning("Timestamp column not found in header: %s", header)
        return [], values[1:], header

    to_archive: List[List[str]] = []
    keep_rows: List[List[str]] = []

    for row in body:
        ts_raw = row[ts_idx] if ts_idx < len(row) else ""
        dt = _parse_ts(ts_raw)
        if dt and dt.date() == day:
            to_archive.append(row)
        else:
            keep_rows.append(row)

    return to_archive, keep_rows, header


def _process_sheet(sheets: SheetsAPI, sheet_name: str, day: datetime.date, dry_run: bool = False) -> Tuple[int,int]:
    """
    Process one sheet: move rows for `day` to ARCHIVE_SHEET.
    Returns (archived_count, kept_count)
    """
    try:
        ws = sheets.get_worksheet(sheet_name)
        values = sheets._request_with_retry(ws.get_all_values)
        to_move, keep, header = _collect_rows_for_date(values, day)
        if not header:
            logger.info("[%s] empty or no header ‚Äî skipping", sheet_name)
            return 0, len(keep)

        archived = len(to_move)
        if archived == 0:
            logger.info("[%s] no rows for %s", sheet_name, day.isoformat())
            return 0, len(keep)

        logger.info("[%s] archiving %d rows for %s", sheet_name, archived, day.isoformat())

        if dry_run:
            return archived, len(keep)

        arch = _ensure_archive_sheet(sheets, header)
        sheets._request_with_retry(arch.append_rows, to_move, value_input_option="USER_ENTERED")

        new_data = [header] + keep if keep else [header]
        sheets._request_with_retry(ws.clear)
        sheets._request_with_retry(ws.update, "A1", new_data)

        return archived, len(keep)
    except Exception as e:
        logger.exception("Failed to process sheet %s: %s", sheet_name, e)
        return 0, 0


def run_archive(target_date: Optional[str] = None, dry_run: bool = False, only_sheet: Optional[str] = None) -> None:
    """
    Archive rows for yesterday (or for specific date YYYY-MM-DD) from WorkLog sheets to Archive.
    - If `only_sheet` is provided, process only that sheet.
    - Otherwise process WORKLOG_SHEET and all 'WorkLog_*' sheets that exist.
    """
    sheets = SheetsAPI()

    if target_date:
        try:
            day = datetime.strptime(target_date, "%Y-%m-%d").date()
        except Exception:
            raise SystemExit("Invalid --date format. Use YYYY-MM-DD")
    else:
        day = _yesterday_local()

    titles: List[str] = []
    try:
        titles = sheets.list_worksheet_titles()
    except Exception:
        pass

    candidates: List[str] = []
    if only_sheet:
        if only_sheet not in titles:
            raise SystemExit(f"Sheet '{only_sheet}' not found in {GOOGLE_SHEET_NAME}")
        candidates = [only_sheet]
    else:
        for t in titles:
            if t == WORKLOG_SHEET or t.startswith(f"{WORKLOG_SHEET}_"):
                candidates.append(t)

    if not candidates:
        logger.warning("No WorkLog-like sheets found. Nothing to do.")
        return

    total_archived = 0
    for name in candidates:
        a, _k = _process_sheet(sheets, name, day, dry_run=dry_run)
        total_archived += a

    if dry_run:
        logger.info("DRY-RUN complete. Would archive %d rows total for %s.", total_archived, day.isoformat())
    else:
        logger.info("Archive complete. Archived %d rows total for %s.", total_archived, day.isoformat())


def main():
    ap = argparse.ArgumentParser(description="Archive yesterday's rows from WorkLog sheets to Archive via SheetsAPI.")
    ap.add_argument("--date", help="Target date YYYY-MM-DD (default: yesterday in local tz)", default=None)
    ap.add_argument("--dry-run", action="store_true", help="Do not modify sheets, just report.")
    ap.add_argument("--only-sheet", help="Process only given sheet name", default=None)
    args = ap.parse_args()
    run_archive(target_date=args.date, dry_run=args.dry_run, only_sheet=args.only_sheet)

if __name__ == "__main__":
    main()

--------------------------------------------------------------------------------
# FILE: auto_sync.py
# SIZE: 22760 bytes | SHA256(text): ae8962e4c852506b031ec63650b245dbc6fd3c1cb39b170bc47cc10c23553088
--------------------------------------------------------------------------------
import sys
import logging
import time
import signal
from datetime import datetime
from threading import Event, RLock, Thread
from pathlib import Path
from typing import Dict, List, Optional
import socket
from time import monotonic

PROJECT_ROOT = Path(__file__).parent
sys.path.insert(0, str(PROJECT_ROOT))

try:
    from PyQt5.QtCore import QObject, pyqtSignal
except ImportError:
    logging.warning("PyQt5 –Ω–µ –Ω–∞–π–¥–µ–Ω. –°–∏–≥–Ω–∞–ª—ã GUI –Ω–µ –±—É–¥—É—Ç —Ä–∞–±–æ—Ç–∞—Ç—å. –ó–∞–ø—É—Å–∫ –≤ —Ä–µ–∂–∏–º–µ CLI.")
    class QObject: pass
    class pyqtSignal:
        def __init__(self): pass
        def emit(self, *args, **kwargs): pass

try:
    from config import (
        SYNC_INTERVAL,
        API_MAX_RETRIES,
        SYNC_BATCH_SIZE,
        SYNC_RETRY_STRATEGY,
        SYNC_INTERVAL_ONLINE,
        SYNC_INTERVAL_OFFLINE_RECOVERY
    )
    from user_app.db_local import LocalDB
    from sheets_api import sheets_api
    from sync.network import is_internet_available
except ImportError as e:
    logging.error(f"–û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ –º–æ–¥—É–ª–µ–π: {e}")
    raise

logger = logging.getLogger(__name__)

PING_PORT = 43333
PING_TIMEOUT = 3600  # 1 —á–∞—Å

class SyncSignals(QObject):
    force_logout = pyqtSignal()
    sync_status_updated = pyqtSignal(dict)

class SyncManager(QObject):
    def __init__(self, signals: Optional[SyncSignals] = None, background_mode: bool = True):
        super().__init__()
        logger.info(f"–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è SyncManager: background_mode={background_mode}")
        self._db = LocalDB()
        self._db_lock = RLock()
        self._stop_event = Event()
        self.signals = signals
        self._background_mode = background_mode
        self._sync_interval = SYNC_INTERVAL if background_mode else 0
        self._last_sync_time = None
        self._is_offline_recovery = False  # –§–ª–∞–≥ –¥–ª—è —Ä–µ–∂–∏–º–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
        self._stats = {
            'total_synced': 0,
            'last_sync': None,
            'last_duration': 0,
            'success_rate': 1.0,
            'queue_size': 0
        }
        self._last_ping = time.time()
        self._last_loop_started = monotonic()
        if background_mode:
            self._ping_thread = Thread(target=self._ping_listener, daemon=True)
            self._ping_thread.start()
            logger.debug("Ping listener –ø–æ—Ç–æ–∫ –∑–∞–ø—É—â–µ–Ω")

    def _check_remote_commands(self):
        logger.info("=== –ü–†–û–í–ï–†–ö–ê –ö–û–ú–ê–ù–î ===")
        if not is_internet_available():
            logger.debug("–ü—Ä–æ–≤–µ—Ä–∫–∞ —É–¥–∞–ª–µ–Ω–Ω—ã—Ö –∫–æ–º–∞–Ω–¥ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–∞: –Ω–µ—Ç –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞.")
            return

        with self._db_lock:
            email = self._db.get_current_user_email()
            logger.debug(f"–¢–µ–∫—É—â–∏–π email –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {email}")
            session = self._db.get_active_session(email) if email else None
            session_id = session["session_id"] if session else None
            logger.debug(f"–ê–∫—Ç–∏–≤–Ω–∞—è —Å–µ—Å—Å–∏—è: session_id={session_id}")

        if not email or not session_id:
            logger.debug("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π —Å–µ—Å—Å–∏–∏ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —É–¥–∞–ª–µ–Ω–Ω—ã—Ö –∫–æ–º–∞–Ω–¥.")
            return

        try:
            logger.info(f"–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ —Å–µ—Å—Å–∏–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {email}, session_id: {session_id}")
            remote_status = self._check_user_session_status(email, session_id)
            logger.debug(f"–ü–æ–ª—É—á–µ–Ω —É–¥–∞–ª–µ–Ω–Ω—ã–π —Å—Ç–∞—Ç—É—Å: {remote_status}")
            
            if remote_status == "kicked":
                logger.info(f"[ADMIN_LOGOUT] –û–±–Ω–∞—Ä—É–∂–µ–Ω —Å—Ç–∞—Ç—É—Å 'kicked' –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {email}. –ò—Å–ø—É—Å–∫–∞–µ–º force_logout.")
                if self.signals:
                    self.signals.force_logout.emit()
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º ACK –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã
                try:
                    sheets_api.ack_remote_command(email=email, session_id=session_id)
                    logger.info(f"ACK –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –¥–ª—è –∫–æ–º–∞–Ω–¥—ã kick –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {email}")
                except Exception as ack_error:
                    logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ ACK: {ack_error}")
                return
            elif remote_status == "finished":
                logger.warning(f"–ü–æ–ª—É—á–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ 'finished' –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {email}. –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–∏–≥–Ω–∞–ª–∞ –≤ GUI.")
                if self.signals:
                    logger.info("Emit force_logout signal to GUI")
                    self.signals.force_logout.emit()
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º ACK –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã
                try:
                    sheets_api.ack_remote_command(email=email, session_id=session_id)
                    logger.info(f"ACK –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –¥–ª—è –∫–æ–º–∞–Ω–¥—ã finished –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {email}")
                except Exception as ack_error:
                    logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ ACK: {ack_error}")
                # –ù–ï –≤—ã–∑—ã–≤–∞–µ–º self.stop() –∑–¥–µ—Å—å!
            else:
                logger.debug(f"–°—Ç–∞—Ç—É—Å —Å–µ—Å—Å–∏–∏ –≤ –Ω–æ—Ä–º–µ: {remote_status}")
                
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —É–¥–∞–ª–µ–Ω–Ω—ã—Ö –∫–æ–º–∞–Ω–¥ –¥–ª—è {email}: {e}", exc_info=True)

    def _check_user_session_status(self, email: str, session_id: str) -> str:
        """
        –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Å—Ç–∞—Ç—É—Å —É–∫–∞–∑–∞–Ω–Ω–æ–π —Å–µ—Å—Å–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ Google Sheets.
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç: 'active', 'kicked', 'finished', 'expired', 'unknown'
        """
        try:
            return sheets_api.check_user_session_status(email, session_id)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —Å—Ç–∞—Ç—É—Å–∞ —Å–µ—Å—Å–∏–∏: {e}")
            return "unknown"

    def _ping_listener(self):
        logger.info(f"–ó–∞–ø—É—Å–∫ ping listener –Ω–∞ UDP –ø–æ—Ä—Ç—É {PING_PORT}")
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.bind(("127.0.0.1", PING_PORT))
        s.settimeout(2)
        logger.info(f"Ping listener –∑–∞–ø—É—â–µ–Ω –Ω–∞ UDP –ø–æ—Ä—Ç—É {PING_PORT}")
        while not self._stop_event.is_set():
            try:
                data, addr = s.recvfrom(1024)
                logger.debug(f"–ü–æ–ª—É—á–µ–Ω UDP –ø–∞–∫–µ—Ç –æ—Ç {addr}: {data}")
                if data == b"ping":
                    self._last_ping = time.time()
                    logger.debug("–ü–æ–ª—É—á–µ–Ω ping, –æ–±–Ω–æ–≤–ª–µ–Ω–æ –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ ping")
            except socket.timeout:
                continue
            except Exception as e:
                logger.warning(f"–û—à–∏–±–∫–∞ –≤ ping listener: {e}", exc_info=True)
        s.close()
        logger.info("Ping listener –∑–∞–≤–µ—Ä—à–µ–Ω")

    def _prepare_batch(self) -> Optional[Dict[str, List[Dict]]]:
        logger.debug("–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –ø–∞–∫–µ—Ç–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏")
        with self._db_lock:
            try:
                unsynced = self._db.get_unsynced_actions(SYNC_BATCH_SIZE)
                logger.debug(f"–ù–∞–π–¥–µ–Ω–æ {len(unsynced)} –Ω–µ—Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π")
                
                if not unsynced:
                    logger.debug("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ –ø–∞–∫–µ—Ç–∞")
                    return None
                
                batch = {}
                for action in unsynced:
                    email = action[1]
                    if email not in batch:
                        batch[email] = []
                    batch[email].append({
                        'id': action[0],
                        'email': action[1],
                        'name': action[2],
                        'status': action[3],
                        'action_type': action[4],
                        'comment': action[5],
                        'timestamp': action[6],
                        'session_id': action[7],
                        'status_start_time': action[8],
                        'status_end_time': action[9],
                        'reason': action[10],        # NEW
                        'user_group': action[11],    # NEW
                    })
                
                logger.info(f"–ü–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω –ø–∞–∫–µ—Ç –¥–ª—è {len(batch)} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –≤—Å–µ–≥–æ –¥–µ–π—Å—Ç–≤–∏–π: {sum(len(actions) for actions in batch.values())}")
                return batch
                
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ –ø–∞–∫–µ—Ç–∞: {e}", exc_info=True)
                return None

    def _sync_batch(self, batch: Dict[str, List[Dict]]) -> bool:
        if not batch:
            logger.debug("–ü—É—Å—Ç–æ–π –ø–∞–∫–µ—Ç, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é")
            return True
            
        start_time = time.time()
        total_actions = sum(len(actions) for actions in batch.values())
        success_count = 0
        synced_ids = []
        
        logger.info(f"–ù–∞—á–∞–ª–æ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –ø–∞–∫–µ—Ç–∞ –∏–∑ {total_actions} –¥–µ–π—Å—Ç–≤–∏–π –¥–ª—è {len(batch)} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π")
        
        for email, actions in batch.items():
            logger.debug(f"–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {email}: {len(actions)} –¥–µ–π—Å—Ç–≤–∏–π")
            
            for attempt in range(API_MAX_RETRIES):
                try:
                    logger.debug(f"–ü–æ–ø—ã—Ç–∫–∞ {attempt + 1}/{API_MAX_RETRIES} –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {email}")
                    
                    if not is_internet_available():
                        logger.warning("–ò–Ω—Ç–µ—Ä–Ω–µ—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é.")
                        return False
                    
                    # –ü–æ–ª—É—á–∞–µ–º –≥—Ä—É–ø–ø—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –ª–∏—Å—Ç–∞ Users
                    user = sheets_api.get_user_by_email(email)
                    user_group = user.get("group") if user else None
                    
                    # –ì–æ—Ç–æ–≤–∏–º —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤–∞—Ä–µ–π –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏
                    actions_payload = []
                    for a in actions:
                        actions_payload.append({
                            "session_id": a['session_id'],
                            "email": a['email'],
                            "name": a['name'],
                            "status": a['status'],
                            "action_type": a['action_type'],
                            "comment": a['comment'],
                            "timestamp": a['timestamp'],
                            "status_start_time": a['status_start_time'],
                            "status_end_time": a['status_end_time'],
                            "reason": a.get('reason'),
                        })

                    # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—É—é —Å–∏–≥–Ω–∞—Ç—É—Ä—É API —Å –ø–µ—Ä–µ–¥–∞—á–µ–π user_group
                    if sheets_api.log_user_actions(actions_payload, email, user_group=user_group):
                        success_count += len(actions)
                        synced_ids.extend([a['id'] for a in actions])
                        logger.info(f"–£—Å–ø–µ—à–Ω–æ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–æ {len(actions)} –¥–µ–π—Å—Ç–≤–∏–π –¥–ª—è {email}")
                        break
                    else:
                        logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞—Ç—å –¥–µ–π—Å—Ç–≤–∏—è –¥–ª—è {email}, –ø–æ–ø—ã—Ç–∫–∞ {attempt + 1}")
                        
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –¥–ª—è {email} (–ø–æ–ø—ã—Ç–∫–∞ {attempt + 1}): {e}", exc_info=True)
                
                if attempt < API_MAX_RETRIES - 1:
                    delay = SYNC_RETRY_STRATEGY[min(attempt, len(SYNC_RETRY_STRATEGY) - 1)]
                    logger.info(f"–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ —á–µ—Ä–µ–∑ {delay} —Å–µ–∫...")
                    time.sleep(delay)
        
        if synced_ids:
            with self._db_lock:
                try:
                    logger.debug(f"–ü–æ–º–µ—á–∞–µ–º –∫–∞–∫ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ {len(synced_ids)} –∑–∞–ø–∏—Å–µ–π")
                    self._db.mark_actions_synced(synced_ids)
                    logger.info(f"–£—Å–ø–µ—à–Ω–æ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–æ –∏ –æ—Ç–º–µ—á–µ–Ω–æ {len(synced_ids)} –∑–∞–ø–∏—Å–µ–π.")
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ –∑–∞–ø–∏—Å–µ–π –≤ –ª–æ–∫–∞–ª—å–Ω–æ–π –ë–î: {e}", exc_info=True)
        
        duration = time.time() - start_time
        logger.info(f"–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –∑–∞ {duration:.2f} —Å–µ–∫. –£—Å–ø–µ—à–Ω–æ: {success_count}/{total_actions}")
        
        self._update_stats(success_count, total_actions, duration)
        return success_count == total_actions

    def _update_stats(self, success_count: int, total_actions: int, duration: float):
        logger.debug(f"–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: success={success_count}, total={total_actions}, duration={duration:.2f}")
        with self._db_lock:
            self._stats['total_synced'] += success_count
            self._stats['last_sync'] = datetime.now().isoformat(timespec='seconds')
            self._stats['last_duration'] = round(duration, 3)
            if total_actions > 0:
                rate = success_count / total_actions
                self._stats['success_rate'] = 0.9 * self._stats['success_rate'] + 0.1 * rate
            self._stats['queue_size'] = self._db.get_unsynced_count()
            
        logger.debug(f"–û–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞: {self._stats}")
        if self.signals:
            self.signals.sync_status_updated.emit(self._stats.copy())
            logger.debug("–°–∏–≥–Ω–∞–ª sync_status_updated –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω")

    def sync_once(self) -> bool:
        logger.info("=== –ó–ê–ü–£–°–ö –†–ê–ó–û–í–û–ô –°–ò–ù–•–†–û–ù–ò–ó–ê–¶–ò–ò ===")
        start = time.time()
        ok = False
        try:
            batch = self._prepare_batch()
            if not batch:
                logger.debug("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏.")
                return True

            total_actions = sum(len(actions) for actions in batch.values())
            logger.info(f"–ù–∞—á–∞–ª–æ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –ø–∞–∫–µ—Ç–∞ –∏–∑ {total_actions} –∑–∞–ø–∏—Å–µ–π.")

            # –ï—Å–ª–∏ –æ—á–µ—Ä–µ–¥—å –æ—á–µ–Ω—å –±–æ–ª—å—à–∞—è, –∞–∫—Ç–∏–≤–∏—Ä—É–µ–º —Ä–µ–∂–∏–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
            if total_actions > 100 and not self._is_offline_recovery:
                self._is_offline_recovery = True
                self._sync_interval = SYNC_INTERVAL_OFFLINE_RECOVERY
                logger.info(f"–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –±–æ–ª—å—à–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–µ–π—Å—Ç–≤–∏–π ({total_actions}). –ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω —Ä–µ–∂–∏–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è.")

            ok = self._sync_batch(batch)
            logger.info(f"–†–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞–∑–æ–≤–æ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏: {'–£–°–ü–ï–•' if ok else '–ù–ï–£–î–ê–ß–ê'}")
        finally:
            elapsed = time.time() - start
            self._stats['last_sync'] = datetime.now().isoformat(timespec='seconds')
            self._stats['last_duration'] = round(elapsed, 3)
            self._stats['queue_size'] = self._db.get_unsynced_count()
            if ok:
                self._stats['total_synced'] += 1
            if self.signals:
                self.signals.sync_status_updated.emit(dict(self._stats))
        return ok

    def run_service(self):
        logger.info(f"–°–µ—Ä–≤–∏—Å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –∑–∞–ø—É—â–µ–Ω. –ò–Ω—Ç–µ—Ä–≤–∞–ª: {self._sync_interval} —Å–µ–∫.")
        cycle_count = 0
        
        while not self._stop_event.is_set():
            cycle_count += 1
            self._last_loop_started = monotonic()
            logger.debug(f"=== –¶–ò–ö–õ –°–ò–ù–•–†–û–ù–ò–ó–ê–¶–ò–ò #{cycle_count} ===")
            
            now = time.time()
            if (now - self._last_ping) > PING_TIMEOUT:
                logger.warning("Ping –Ω–µ –ø–æ–ª—É—á–µ–Ω –±–æ–ª–µ–µ —á–∞—Å–∞ ‚Äî –∑–∞–≤–µ—Ä—à–∞–µ–º —Ä–∞–±–æ—Ç—É —Å–µ—Ä–≤–∏—Å–∞.")
                break
            
            start_time = time.time()
            try:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç
                internet_available = is_internet_available()
                logger.debug(f"–î–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞: {internet_available}")
                
                if internet_available:
                    # –ï—Å–ª–∏ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç –µ—Å—Ç—å, –ø—Ä–æ–≤–µ—Ä—è–µ–º, –≤ –∫–∞–∫–æ–º —Ä–µ–∂–∏–º–µ –º—ã –Ω–∞—Ö–æ–¥–∏–º—Å—è
                    if self._is_offline_recovery:
                        # –ï—Å–ª–∏ –º—ã –≤ —Ä–µ–∂–∏–º–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è, –ø—Ä–æ–≤–µ—Ä—è–µ–º, —Å–∫–æ–ª—å–∫–æ –∑–∞–ø–∏—Å–µ–π –æ—Å—Ç–∞–ª–æ—Å—å
                        queue_size = self._db.get_unsynced_count()
                        logger.debug(f"–†–µ–∂–∏–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è. –†–∞–∑–º–µ—Ä –æ—á–µ—Ä–µ–¥–∏: {queue_size}")
                        
                        if queue_size < 50:  # –ï—Å–ª–∏ –æ—Å—Ç–∞–ª–æ—Å—å –º–µ–Ω—å—à–µ 50 –∑–∞–ø–∏—Å–µ–π, —Å—á–∏—Ç–∞–µ–º, —á—Ç–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ
                            self._is_offline_recovery = False
                            self._sync_interval = SYNC_INTERVAL  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–º—É –∏–Ω—Ç–µ—Ä–≤–∞–ª—É
                            logger.info("–†–µ–∂–∏–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω. –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–º—É –∏–Ω—Ç–µ—Ä–≤–∞–ª—É —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏.")
                        else:
                            self._sync_interval = SYNC_INTERVAL_OFFLINE_RECOVERY
                    else:
                        # –ù–æ—Ä–º–∞–ª—å–Ω—ã–π —Ä–µ–∂–∏–º
                        self._sync_interval = SYNC_INTERVAL_ONLINE
                else:
                    # –ù–µ—Ç –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞ ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è –µ–≥–æ –ø–æ—è–≤–ª–µ–Ω–∏—è
                    self._sync_interval = 10
                    logger.debug("–ù–µ—Ç –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞, —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏–Ω—Ç–µ—Ä–≤–∞–ª 10 —Å–µ–∫")

                logger.debug(f"–¢–µ–∫—É—â–∏–π –∏–Ω—Ç–µ—Ä–≤–∞–ª —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏: {self._sync_interval} —Å–µ–∫")
                
                # –í—ã–ø–æ–ª–Ω—è–µ–º —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é
                self.sync_once()
                self._check_remote_commands()
                
            except Exception as e:
                logger.critical(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ —Ü–∏–∫–ª–µ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏: {e}", exc_info=True)
            
            elapsed = time.time() - start_time
            sleep_time = max(1, self._sync_interval - elapsed)
            logger.debug(f"–¶–∏–∫–ª –∑–∞–≤–µ—Ä—à–µ–Ω –∑–∞ {elapsed:.2f} —Å–µ–∫. –û–∂–∏–¥–∞–Ω–∏–µ {sleep_time:.2f} —Å–µ–∫")
            
            self._stop_event.wait(sleep_time)

        logger.info("–°–µ—Ä–≤–∏—Å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –∑–∞–≤–µ—Ä—à—ë–Ω.")

    def stop(self):
        logger.info("–û—Å—Ç–∞–Ω–æ–≤–∫–∞ SyncManager...")
        self._stop_event.set()
        try:
            self._db.close()
            logger.debug("–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∑–∞–∫—Ä—ã—Ç–∞")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ –ë–î: {e}", exc_info=True)
        logger.info("–°–µ—Ä–≤–∏—Å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.")

def configure_logging(background_mode: bool):
    log_file = 'auto_sync.log' if background_mode else None
    handlers = [logging.StreamHandler()]
    if log_file:
        handlers.append(logging.FileHandler(log_file, encoding='utf-8'))
    
    # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —É—Ä–æ–≤–µ–Ω—å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –¥–æ DEBUG –¥–ª—è –±–æ–ª–µ–µ –¥–µ—Ç–∞–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
    logging.basicConfig(
        level=logging.DEBUG,  # –ò–∑–º–µ–Ω–µ–Ω–æ —Å INFO –Ω–∞ DEBUG
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=handlers
    )
    
    # –î–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –±–æ–ª–µ–µ –≤—ã—Å–æ–∫–∏–π —É—Ä–æ–≤–µ–Ω—å, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –ª–æ–≥–æ–≤
    logging.getLogger('urllib3').setLevel(logging.INFO)
    logging.getLogger('googleapiclient').setLevel(logging.INFO)

def handle_shutdown(signum, frame):
    logger.info("–ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–∞–±–æ—Ç—ã (SIGTERM/SIGINT)")
    raise SystemExit("–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ø–æ —Å–∏–≥–Ω–∞–ª—É.")

def main(background_mode: bool = True):
    configure_logging(background_mode)
    manager = None
    try:
        signal.signal(signal.SIGINT, handle_shutdown)
        signal.signal(signal.SIGTERM, handle_shutdown)

        demo_signals = SyncSignals()
        def on_force_logout():
            logger.info("--- –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è: –ø–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª force_logout! –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –≤—ã–π—Ç–∏. ---")
        demo_signals.force_logout.connect(on_force_logout)

        manager = SyncManager(signals=demo_signals, background_mode=background_mode)

        if background_mode:
            logger.info("–ó–∞–ø—É—Å–∫ –≤ —Ä–µ–∂–∏–º–µ —Å–µ—Ä–≤–∏—Å–∞ (–¥–µ–º–æ)")
            manager.run_service()
        else:
            logger.info("–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ä–∞–∑–æ–≤–æ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ (–¥–µ–º–æ)")
            manager.sync_once()
            manager._check_remote_commands()

    except SystemExit as e:
        logger.info(f"–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã: {e}")
    except Exception as e:
        logger.critical(f"–§–∞—Ç–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞ –≤ main: {e}", exc_info=True)
    finally:
        if manager:
            manager.stop()

if __name__ == "__main__":
    main(background_mode=True)

--------------------------------------------------------------------------------
# FILE: build_admin.py
# SIZE: 2141 bytes | SHA256(text): 61314b2fa48430cce7746bb0fdb899626af3e0abb44d0cccd4eee315f3035c98
--------------------------------------------------------------------------------
# build_admin.py
import os
import sys
import logging
import shutil
from pathlib import Path
from PyInstaller.__main__ import run

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('build_admin.log', mode='w', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

def main():
    try:
        logger.info("üöÄ –°–±–æ—Ä–∫–∞ –∞–¥–º–∏–Ω–∫–∏...")
        app_name = "WorkTimeTracker_Admin"
        main_script = "admin_app/main_admin.py" # –ü—É—Ç—å –æ—Ç –∫–æ—Ä–Ω—è
        icon_file = "user_app/sberhealf.ico" # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç—É –∂–µ –∏–∫–æ–Ω–∫—É

        for dir_name in ['dist', 'build']:
            if Path(dir_name).exists():
                shutil.rmtree(dir_name)
                logger.info(f"üßπ –û—á–∏—â–µ–Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è: {dir_name}")

        options = [
            main_script,
            f'--name={app_name}',
            '--onedir',
            '--windowed',
            '--clean',
            '--noconfirm',
            '--log-level=WARN',
            f'--icon={icon_file}' if Path(icon_file).exists() else None,
            '--paths=.', # –ö–ª—é—á–µ–≤–∞—è —Å—Ç—Ä–æ–∫–∞
            '--add-data=secret_creds.zip;.',
            '--add-data=config.py;.',
            '--add-data=user_app/sberhealf.png;user_app',
            '--hidden-import=auto_sync',
            '--hidden-import=sheets_api',
            '--hidden-import=user_app.db_local',
        ]

        options = [opt for opt in options if opt is not None]

        logger.info(f"‚öôÔ∏è  –ó–∞–ø—É—Å–∫: {' '.join(options)}")
        run(options)

        exe_path = Path('dist') / app_name / f"{app_name}.exe"
        if exe_path.exists():
            logger.info(f"‚úÖ –£—Å–ø–µ—Ö! {exe_path}")
        else:
            raise RuntimeError("–°–±–æ—Ä–∫–∞ –ø—Ä–æ—à–ª–∞, –Ω–æ exe –Ω–µ –Ω–∞–π–¥–µ–Ω.")

    except Exception as e:
        logger.critical(f"‚ùå –û—à–∏–±–∫–∞: {e}", exc_info=True)
        sys.exit(1)

if __name__ == "__main__":
    main()

--------------------------------------------------------------------------------
# FILE: build_user.py
# SIZE: 2979 bytes | SHA256(text): 4216f57927b7d0a06a8307c71e8e7ad393eec607de641709d5b8061c3f154ff3
--------------------------------------------------------------------------------
# build_user.py
import os
import sys
import logging
import shutil
from pathlib import Path
from PyInstaller.__main__ import run

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('build_user.log', mode='w', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

def main():
    try:
        logger.info("üöÄ –°–±–æ—Ä–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–π —á–∞—Å—Ç–∏...")
        app_name = "WorkTimeTracker_User"
        main_script = "user_app/main.py"
        icon_file = "user_app/sberhealf.ico"

        # –û—á–∏—Å—Ç–∫–∞
        for dir_name in ['dist', 'build']:
            if Path(dir_name).exists():
                shutil.rmtree(dir_name)
                logger.info(f"üßπ –û—á–∏—â–µ–Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è: {dir_name}")

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è —Ñ–∞–π–ª–æ–≤
        required_files = [
            'secret_creds.zip',
            'config.py',
            'auto_sync.py',
            'sheets_api.py',
            'user_app',
            'sync'
        ]
        for file in required_files:
            if not Path(file).exists():
                logger.critical(f"‚ùå –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: {file} –Ω–µ –Ω–∞–π–¥–µ–Ω!")
                sys.exit(1)

        options = [
            main_script,
            f'--name={app_name}',
            '--onedir',
            '--windowed',
            '--clean',
            '--noconfirm',
            '--log-level=WARN',
            f'--icon={icon_file}' if Path(icon_file).exists() else None,
            '--paths=.',
            '--add-data=secret_creds.zip;.',
            '--add-data=config.py;.',
            '--add-data=auto_sync.py;.',
            '--add-data=sheets_api.py;.',
            '--add-data=user_app;user_app',
            '--add-data=sync;sync',
            '--hidden-import=PyQt5.sip',
            '--hidden-import=gspread',
            '--hidden-import=oauth2client',
            '--hidden-import=google.auth',
            '--hidden-import=googleapiclient',
            '--hidden-import=google.oauth2',
            '--hidden-import=googleapiclient.discovery',
            '--hidden-import=httplib2',
            '--hidden-import=OpenSSL',
            '--hidden-import=requests',
        ]

        options = [opt for opt in options if opt is not None]
        logger.info(f"‚öôÔ∏è –ó–∞–ø—É—Å–∫: {' '.join(options)}")
        run(options)

        exe_path = Path('dist') / app_name / f"{app_name}.exe"
        if exe_path.exists():
            logger.info(f"‚úÖ –£—Å–ø–µ—Ö! {exe_path}")
        else:
            raise RuntimeError("–°–±–æ—Ä–∫–∞ –ø—Ä–æ—à–ª–∞, –Ω–æ exe –Ω–µ –Ω–∞–π–¥–µ–Ω.")

    except Exception as e:
        logger.critical(f"‚ùå –û—à–∏–±–∫–∞: {e}", exc_info=True)
        sys.exit(1)

if __name__ == "__main__":
    main()

--------------------------------------------------------------------------------
# FILE: bundle_project.py
# SIZE: 21101 bytes | SHA256(text): b6c1f1599c20041b8ed5c6b641e5fd454d41846711bd7674452a97216ce01493
--------------------------------------------------------------------------------
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
inspect_and_bundle.py ‚Äî –µ–¥–∏–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç:
  1) –°–Ω–∏–º–æ–∫ –¥–µ—Ä–µ–≤–∞ –ø—Ä–æ–µ–∫—Ç–∞ (—Å –∏—Å–∫–ª—é—á–µ–Ω–∏—è–º–∏)
  2) TXT-–±–∞–Ω–¥–ª –∏—Å—Ö–æ–¥–Ω–∏–∫–æ–≤/–∫–æ–Ω—Ñ–∏–≥–æ–≤
  3) –û–±–∑–æ—Ä –ª–æ–∫–∞–ª—å–Ω–æ–π SQLite (—Å—Ö–µ–º–∞, –∏–Ω–¥–µ–∫—Å—ã, —Ç—Ä–∏–≥–≥–µ—Ä—ã, —Å—á—ë—Ç—á–∏–∫–∏, –ø—Ä–∏–º–µ—Ä—ã)
  4) –û–±–∑–æ—Ä Google Sheets (–∫–Ω–∏–≥–∞, –ª–∏—Å—Ç—ã, –∑–∞–≥–æ–ª–æ–≤–∫–∏, –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–æ–∫, –ø—Ä–∏–º–µ—Ä—ã)

–ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏:
  - stdlib
  - –í–∞—à –ø—Ä–æ–µ–∫—Ç (config.py, sheets_api.py) ‚Äî –¥–ª—è –ø—É—Ç–µ–π/–¥–æ—Å—Ç—É–ø–∞ –∫ Google Sheets.
    sheets_api —É–∂–µ —Å–æ–¥–µ—Ä–∂–∏—Ç ¬´–ª–µ–Ω–∏–≤—ã–π¬ª –ø—Ä–æ–∫—Å–∏/–∫–ª–∏–µ–Ω—Ç –∏ —Ä–µ—Ç—Ä–∞–∏.

–ü—Ä–∏–º–µ—Ä—ã:
  python inspect_and_bundle.py -r . -o project_report.txt
  python inspect_and_bundle.py -r . -o report.txt --db C:/path/to/local_backup.db
  python inspect_and_bundle.py --git-only --no-sheets
"""

from __future__ import annotations

import argparse
import hashlib
import mimetypes
import os
import sqlite3
import sys
import time
from pathlib import Path
from typing import Iterable, List, Dict, Optional, Tuple

# -----------------------------------
# 1) –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è –¥–µ—Ä–µ–≤–∞ –∏ –±–∞–Ω–¥–ª–∞
# -----------------------------------

EXCLUDE_TREE = {'.venv', '__pycache__', '.git', '.idea', 'dist', 'build', '.vscode', '.mypy_cache', '.pytest_cache', '.ruff_cache', 'node_modules', 'target', 'out'}
DEFAULT_EXCLUDE_DIRS = {
    ".git", ".hg", ".svn", ".idea", ".vscode",
    ".venv", "venv", "env",
    "__pycache__", ".mypy_cache", ".pytest_cache", ".ruff_cache",
    "build", "dist", ".cache", ".eggs", ".tox", ".coverage",
    "node_modules", "target", "out"
}

# –¢–µ–∫—Å—Ç–æ–≤—ã–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è (–º–æ–∂–Ω–æ —Ä–∞—Å—à–∏—Ä–∏—Ç—å —á–µ—Ä–µ–∑ --include-ext)
DEFAULT_INCLUDE_EXTS = {
    # code
    ".py", ".pyw", ".ipynb",
    ".js", ".jsx", ".ts", ".tsx", ".vue", ".svelte",
    ".java", ".kt", ".kts", ".scala", ".go", ".rb", ".php",
    ".c", ".cc", ".cpp", ".h", ".hpp", ".cs", ".rs", ".swift",
    # web / markup
    ".html", ".htm", ".css", ".scss", ".sass",
    ".xml", ".xsd", ".xslt",
    # config
    ".json", ".jsonc", ".yaml", ".yml", ".ini", ".cfg", ".toml", ".env",
    # scripts
    ".bat", ".cmd", ".ps1", ".psm1", ".sh", ".bash",
    # data-ish (text)
    ".md", ".rst", ".txt", ".csv", ".tsv", ".sql",
    # project files
    ".sln", ".csproj", ".vbproj", ".props", ".targets", ".cmake", "CMakeLists.txt",
    ".gradle", ".pro", ".pri", "Makefile", "Dockerfile", "Procfile",
}
SPECIAL_FILENAMES = {"Makefile", "Dockerfile", "Procfile", "CMakeLists.txt", ".gitignore", ".gitattributes"}

# -----------------------------------
# 2) –í—Å–ø–æ–º–æ–≥–∞–ª–∫–∏
# -----------------------------------

def normalize_extensions_set(exts: Iterable[str]) -> set[str]:
    out = set()
    for e in exts:
        e = (e or "").strip()
        if not e:
            continue
        if not e.startswith(".") and e not in SPECIAL_FILENAMES:
            e = "." + e
        out.add(e)
    return out

def is_binary_by_chunk(p: Path, chunk_size: int = 2048) -> bool:
    try:
        with p.open("rb") as f:
            chunk = f.read(chunk_size)
        if b"\x00" in chunk:
            return True
        text_chars = bytearray({7,8,9,10,12,13,27} | set(range(0x20, 0x100)) - {0x7f})
        nontext = chunk.translate(None, text_chars)
        return len(nontext) / max(1, len(chunk)) > 0.30
    except Exception:
        return True

def should_include_file(p: Path, include_exts: set[str]) -> bool:
    name = p.name
    if name in SPECIAL_FILENAMES:
        return True
    ext = p.suffix
    if ext in include_exts:
        return True
    mtype, _ = mimetypes.guess_type(str(p))
    if mtype and mtype.startswith("text/"):
        return True
    return False

def sha256_of_text(s: str) -> str:
    import hashlib as _h
    return _h.sha256(s.encode("utf-8", errors="replace")).hexdigest()

def read_text_best_effort(p: Path) -> str:
    for enc in ("utf-8", "utf-8-sig", "cp1251", "latin-1"):
        try:
            return p.read_text(encoding=enc)
        except Exception:
            continue
    try:
        return p.read_bytes().decode("latin-1", errors="replace")
    except Exception:
        return ""

# -----------------------------------
# 3) –î–µ—Ä–µ–≤–æ –ø—Ä–æ–µ–∫—Ç–∞ (–≤ —Å—Ç—Ä–æ–∫—É)
# -----------------------------------

def render_tree(dir_path: Path, prefix: str = "", exclude: set[str] = None) -> str:
    exclude = exclude or set()
    lines: List[str] = []
    try:
        entries = [e for e in os.listdir(dir_path) if e not in exclude]
    except Exception as e:
        return f"[tree] –û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ {dir_path}: {e}\n"
    entries.sort()
    for i, name in enumerate(entries):
        path = dir_path / name
        connector = "‚îî‚îÄ‚îÄ " if i == len(entries) - 1 else "‚îú‚îÄ‚îÄ "
        lines.append(prefix + connector + name)
        if path.is_dir():
            extension = "    " if i == len(entries) - 1 else "‚îÇ   "
            lines.append(render_tree(path, prefix + extension, exclude))
    return "\n".join(lines)

# -----------------------------------
# 4) –°–±–æ—Ä —Ñ–∞–π–ª–æ–≤ –ø—Ä–æ–µ–∫—Ç–∞ –≤ TXT
# -----------------------------------

def collect_files(root: Path, include_exts: set[str], exclude_dirs: set[str], max_bytes: int) -> List[Path]:
    files: List[Path] = []
    for dirpath, dirnames, filenames in os.walk(root):
        dirnames[:] = [d for d in dirnames if d not in exclude_dirs]
        dp = Path(dirpath)
        for fname in filenames:
            p = dp / fname
            try:
                if not p.is_file():
                    continue
                if p.stat().st_size > max_bytes:
                    continue
                if not should_include_file(p, include_exts):
                    continue
                if is_binary_by_chunk(p):
                    continue
                files.append(p)
            except Exception:
                continue
    files.sort(key=lambda x: str(x).lower())
    return files

def write_bundle(out, root: Path, files: List[Path]) -> None:
    ts = time.strftime("%Y-%m-%d %H:%M:%S")
    header = [
        "=" * 80,
        f"PROJECT REPORT",
        f"Generated:   {ts}",
        f"Root:        {root}",
        f"Python:      {sys.version.split()[0]}",
        f"Files:       {len(files)}",
        "=" * 80,
        ""
    ]
    out.write("\n".join(header) + "\n")
    for p in files:
        try:
            rel = p.relative_to(root)
        except Exception:
            rel = p
        try:
            text = read_text_best_effort(p)
            size = p.stat().st_size
            h = sha256_of_text(text)
            out.write("\n" + "-" * 80 + "\n")
            out.write(f"# FILE: {rel}\n")
            out.write(f"# SIZE: {size} bytes | SHA256(text): {h}\n")
            out.write("-" * 80 + "\n")
            out.write(text)
            if not text.endswith("\n"):
                out.write("\n")
        except Exception as e:
            out.write("\n" + "-" * 80 + "\n")
            out.write(f"# FILE: {rel}\n")
            out.write(f"# ERROR: {e}\n")
            out.write("-" * 80 + "\n\n")

# -----------------------------------
# 5) –ò–Ω—Å–ø–µ–∫—Ü–∏—è SQLite
# -----------------------------------

def _sql_fetchall_safe(cur: sqlite3.Cursor, sql: str, params: Tuple = ()) -> List[Tuple]:
    try:
        cur.execute(sql, params)
        return cur.fetchall()
    except Exception:
        return []

def introspect_sqlite(db_path: Path, sample_limit: int = 5) -> str:
    out: List[str] = []
    out.append("=" * 80)
    out.append("LOCAL SQLITE OVERVIEW")
    out.append(f"DB Path: {db_path}")
    out.append("=" * 80)

    if not db_path.exists():
        out.append(f"[warn] –§–∞–π–ª –ë–î –Ω–µ –Ω–∞–π–¥–µ–Ω: {db_path}")
        return "\n".join(out) + "\n"

    try:
        conn = sqlite3.connect(str(db_path))
        cur = conn.cursor()

        # –ë–∞–∑–æ–≤–∞—è –∏–Ω—Ñ–æ
        db_list = _sql_fetchall_safe(cur, "PRAGMA database_list;")
        out.append(f"database_list: {db_list}")

        # –¢–∞–±–ª–∏—Ü—ã (–∫—Ä–æ–º–µ —Å–ª—É–∂–µ–±–Ω—ã—Ö)
        tables = _sql_fetchall_safe(
            cur, "SELECT name, sql FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%' ORDER BY name;"
        )
        for name, create_sql in tables:
            out.append("-" * 80)
            out.append(f"[TABLE] {name}")
            out.append(f"schema: {create_sql}")

            # –ö–æ–ª–æ–Ω–∫–∏
            cols = _sql_fetchall_safe(cur, f"PRAGMA table_info({name});")
            if cols:
                out.append("columns:")
                for cid, cname, ctype, notnull, dflt, pk in cols:
                    out.append(f"  - {cname} {ctype or ''} NOTNULL={notnull} PK={pk} DEFAULT={dflt}")

            # –ò–Ω–¥–µ–∫—Å—ã
            idxs = _sql_fetchall_safe(cur, f"PRAGMA index_list({name});")
            if idxs:
                out.append("indexes:")
                for idx in idxs:
                    iname = idx[1]
                    unique = idx[2]
                    out.append(f"  - {iname} UNIQUE={unique}")
                    idxcols = _sql_fetchall_safe(cur, f"PRAGMA index_info({iname});")
                    for _, seqno, cname in idxcols:
                        out.append(f"      * {seqno}: {cname}")

            # –¢—Ä–∏–≥–≥–µ—Ä—ã –ø–æ —Ç–∞–±–ª–∏—Ü–µ
            trigs = _sql_fetchall_safe(
                cur, "SELECT name, sql FROM sqlite_master WHERE type='trigger' AND tbl_name=? ORDER BY name;", (name,)
            )
            if trigs:
                out.append("triggers:")
                for tname, tsql in trigs:
                    out.append(f"  - {tname}: {tsql}")

            # –°—á—ë—Ç—á–∏–∫ —Å—Ç—Ä–æ–∫
            cnt = _sql_fetchall_safe(cur, f"SELECT COUNT(*) FROM {name};")
            if cnt:
                out.append(f"rows_count: {cnt[0][0]}")

            # –ü—Ä–∏–º–µ—Ä—ã —Å—Ç—Ä–æ–∫
            samples = _sql_fetchall_safe(cur, f"SELECT * FROM {name} ORDER BY ROWID DESC LIMIT {int(sample_limit)};")
            if samples:
                out.append("sample rows (last):")
                for row in samples:
                    out.append(f"  ‚Ä¢ {row}")

        # –ì–ª–æ–±–∞–ª—å–Ω—ã–µ —Ç—Ä–∏–≥–≥–µ—Ä—ã
        gtrigs = _sql_fetchall_safe(cur, "SELECT name, tbl_name, sql FROM sqlite_master WHERE type='trigger' ORDER BY name;")
        if gtrigs:
            out.append("-" * 80)
            out.append("[TRIGGERS GLOBAL]")
            for name, tbl, sql in gtrigs:
                out.append(f"  - {name} on {tbl}: {sql}")

        conn.close()
    except Exception as e:
        out.append(f"[error] –û—à–∏–±–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è/—á—Ç–µ–Ω–∏—è SQLite: {e}")

    out.append("")
    return "\n".join(out)

# -----------------------------------
# 6) –ò–Ω—Å–ø–µ–∫—Ü–∏—è Google Sheets
# -----------------------------------

def introspect_gsheets(sample_limit: int = 3) -> str:
    """
    –ü—ã—Ç–∞–µ—Ç—Å—è –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –≤–∞—à sheets_api –∏ –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –æ–±–∑–æ—Ä –∫–Ω–∏–≥–∏:
      - –ù–∞–∑–≤–∞–Ω–∏–µ –∫–Ω–∏–≥–∏ –∏–∑ config
      - –°–ø–∏—Å–æ–∫ –ª–∏—Å—Ç–æ–≤
      - –ó–∞–≥–æ–ª–æ–≤–æ–∫ –∫–∞–∂–¥–æ–π —Ç–∞–±–ª–∏—Ü—ã
      - –ö–æ–ª-–≤–æ –Ω–µ–ø—É—Å—Ç—ã—Ö —Å—Ç—Ä–æ–∫ (–ø–æ get_all_values)
      - –ü–µ—Ä–≤—ã–µ sample_limit —Å—Ç—Ä–æ–∫
    """
    out: List[str] = []
    out.append("=" * 80)
    out.append("GOOGLE SHEETS OVERVIEW")
    out.append("=" * 80)

    try:
        # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –ª–µ–Ω–∏–≤—ã–π –ø—Ä–æ–∫—Å–∏/–∫–ª–∏–µ–Ω—Ç –∏–∑ –≤–∞—à–µ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞
        # –í –ø—Ä–æ–µ–∫—Ç–µ –µ—Å—Ç—å –º–µ—Ç–æ–¥—ã list_worksheet_titles(), get_users(), get_all_active_sessions() –∏ —Ç.–ø. :contentReference[oaicite:2]{index=2}
        import importlib

        try:
            sheets_mod = importlib.import_module("sheets_api")
        except Exception as e:
            out.append(f"[warn] –ù–µ —É–¥–∞–ª–æ—Å—å –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å sheets_api: {e}")
            return "\n".join(out) + "\n"

        # –í–æ–∑—å–º—ë–º —Ä–µ–∞–ª—å–Ω—ã–π –∏–Ω—Å—Ç–∞–Ω—Å
        if hasattr(sheets_mod, "get_sheets_api"):
            sheets = sheets_mod.get_sheets_api()
        elif hasattr(sheets_mod, "SheetsAPI"):
            sheets = sheets_mod.SheetsAPI()
        else:
            out.append("[warn] sheets_api –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç SheetsAPI/get_sheets_api")
            return "\n".join(out) + "\n"

        # –ó–∞–≥–æ–ª–æ–≤–æ–∫ –∏ –ª–∏—Å—Ç—ã
        try:
            from config import GOOGLE_SHEET_NAME  # –∏–º—è –∫–Ω–∏–≥–∏ —Ö—Ä–∞–Ω–∏—Ç—Å—è –≤ –∫–æ–Ω—Ñ–∏–≥–µ :contentReference[oaicite:3]{index=3}
        except Exception:
            GOOGLE_SHEET_NAME = "(—Å–º. config)"

        out.append(f"Spreadsheet: {GOOGLE_SHEET_NAME}")

        titles: List[str] = []
        try:
            titles = list(sheets.list_worksheet_titles())
        except Exception as e:
            out.append(f"[warn] list_worksheet_titles error: {e}")

        if not titles:
            out.append("[warn] –õ–∏—Å—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –∏–ª–∏ –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
            return "\n".join(out) + "\n"

        for t in titles:
            out.append("-" * 80)
            out.append(f"[SHEET] {t}")

            try:
                ws = sheets._get_ws(t)  # –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π helper —É –≤–∞—Å –µ—Å—Ç—å
            except Exception:
                # fallback: —á–µ—Ä–µ–∑ –∫–ª–∏–µ–Ω—Ç
                try:
                    ss = sheets.client.open(GOOGLE_SHEET_NAME)
                    ws = ss.worksheet(t)
                except Exception as e:
                    out.append(f"  [warn] –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –ª–∏—Å—Ç '{t}': {e}")
                    continue

            # –ó–∞–≥–æ–ª–æ–≤–æ–∫
            try:
                header = sheets._request_with_retry(lambda: ws.row_values(1))
                out.append(f"header: {header}")
            except Exception as e:
                out.append(f"  [warn] header read error: {e}")
                header = []

            # –í—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è, —á—Ç–æ–±—ã –ø–æ—Å—á–∏—Ç–∞—Ç—å –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏ (–±–µ–∑ –ø—É—Å—Ç—ã—Ö —Ö–≤–æ—Å—Ç–æ–≤)
            values: List[List[str]] = []
            try:
                values = sheets._request_with_retry(lambda: ws.get_all_values())
            except Exception as e:
                out.append(f"  [warn] get_all_values error: {e}")

            if values:
                # –ù–µ–ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ (–≥—Ä—É–±–∞—è –æ—Ü–µ–Ω–∫–∞)
                nonempty = [r for r in values[1:] if any((c or "").strip() for c in r)]
                out.append(f"rows_count (non-empty): {len(nonempty)}")
                # –ü—Ä–∏–º–µ—Ä—ã –ø–µ—Ä–≤—ã—Ö N
                if nonempty:
                    out.append(f"sample rows (first {sample_limit}):")
                    for row in nonempty[:sample_limit]:
                        out.append("  ‚Ä¢ " + str(row))

    except Exception as e:
        out.append(f"[error] –û—à–∏–±–∫–∞ –æ–±–∑–æ—Ä–∞ Google Sheets: {e}")

    out.append("")
    return "\n".join(out)

# -----------------------------------
# 7) –ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è/CLI
# -----------------------------------

def main():
    ap = argparse.ArgumentParser(description="–°–æ–±—Ä–∞—Ç—å –æ—Ç—á—ë—Ç –ø–æ –ø—Ä–æ–µ–∫—Ç—É (–¥–µ—Ä–µ–≤–æ, –±–∞–Ω–¥–ª, SQLite, Google Sheets).")
    ap.add_argument("-r", "--root", type=str, default=".", help="–ö–æ—Ä–µ–Ω—å –ø—Ä–æ–µ–∫—Ç–∞ (default .)")
    ap.add_argument("-o", "--output", type=str, default="project_report.txt", help="–ü—É—Ç—å –∫ –≤—ã—Ö–æ–¥–Ω–æ–º—É TXT.")
    ap.add_argument("--max-bytes", type=int, default=3_000_000, help="–ú–∞–∫—Å. —Ä–∞–∑–º–µ—Ä –æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ (–±–∞–π—Ç).")
    ap.add_argument("--include-ext", type=str, nargs="*", default=None, help="–î–æ–ø. —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è (py toml conf ...)")
    ap.add_argument("--exclude-dir", type=str, nargs="*", default=None, help="–î–æ–ø. –∫–∞—Ç–∞–ª–æ–≥–∏ –¥–ª—è –∏—Å–∫–ª—é—á–µ–Ω–∏—è (–∏–º–µ–Ω–∞).")
    ap.add_argument("--git-only", action="store_true", help="–°–æ–±–∏—Ä–∞–µ—Ç —Ç–æ–ª—å–∫–æ —Ñ–∞–π–ª—ã, –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º—ã–µ Git.")
    ap.add_argument("--no-tree", action="store_true", help="–ù–µ –¥–æ–±–∞–≤–ª—è—Ç—å –¥–µ—Ä–µ–≤–æ –ø—Ä–æ–µ–∫—Ç–∞.")
    ap.add_argument("--no-db", action="store_true", help="–ù–µ –¥–æ–±–∞–≤–ª—è—Ç—å –æ–±–∑–æ—Ä SQLite.")
    ap.add_argument("--no-sheets", action="store_true", help="–ù–µ –¥–æ–±–∞–≤–ª—è—Ç—å –æ–±–∑–æ—Ä Google Sheets.")
    ap.add_argument("--db", type=str, default=None, help="–ü—É—Ç—å –∫ SQLite (–∏–Ω–∞—á–µ –≤–æ–∑—å–º—ë–º –∏–∑ config.LOCAL_DB_PATH).")
    ap.add_argument("--db-sample", type=int, default=5, help="–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–æ–∫-–ø—Ä–∏–º–µ—Ä–æ–≤ –∏–∑ —Ç–∞–±–ª–∏—Ü SQLite.")
    ap.add_argument("--sheets-sample", type=int, default=3, help="–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–æ–∫-–ø—Ä–∏–º–µ—Ä–æ–≤ –∏–∑ –ª–∏—Å—Ç–æ–≤ Google Sheets.")

    args = ap.parse_args()

    root = Path(args.root).resolve()
    out_path = Path(args.output).resolve()
    out_path.parent.mkdir(parents=True, exist_ok=True)

    include_exts = set(DEFAULT_INCLUDE_EXTS)
    if args.include_ext:
        include_exts |= normalize_extensions_set(set(args.include_ext))

    exclude_dirs = set(DEFAULT_EXCLUDE_DIRS)
    if args.exclude_dir:
        exclude_dirs |= set(args.exclude_dir)

    # --- –ü–æ–¥–≥–æ—Ç–æ–≤–∏–º —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ ---
    if args.git_only:
        try:
            import subprocess
            res = subprocess.run(
                ["git", "ls-files"],
                check=True,
                cwd=str(root),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                encoding="utf-8",
            )
            files = []
            tracked = [root / line.strip() for line in res.stdout.splitlines() if line.strip()]
            for p in tracked:
                try:
                    if not p.exists() or not p.is_file():
                        continue
                    if p.stat().st_size > args.max_bytes:
                        continue
                    if not should_include_file(p, include_exts):
                        continue
                    if is_binary_by_chunk(p):
                        continue
                    files.append(p)
                except Exception:
                    continue
            files.sort(key=lambda x: str(x).lower())
        except Exception as e:
            print(f"[WARN] git-only —Ä–µ–∂–∏–º –Ω–µ —É–¥–∞–ª—Å—è: {e}. –ü–µ—Ä–µ—Ö–æ–¥ –∫ —Ñ–∞–π–ª–æ–≤–æ–º—É –æ–±—Ö–æ–¥—É.", file=sys.stderr)
            files = collect_files(root, include_exts, exclude_dirs, args.max_bytes)
    else:
        files = collect_files(root, include_exts, exclude_dirs, args.max_bytes)

    # --- –ü—É—Ç—å –∫ –ª–æ–∫–∞–ª—å–Ω–æ–π –ë–î ---
    db_path: Optional[Path] = None
    if not args.no_db:
        if args.db:
            db_path = Path(args.db)
        else:
            # –ü–æ–ø—Ä–æ–±—É–µ–º –¥–æ—Å—Ç–∞—Ç—å –∏–∑ config.LOCAL_DB_PATH (—É –≤–∞—Å —Ç–∞–∫ –∏ —Å–¥–µ–ª–∞–Ω–æ –≤ –ø—Ä–æ–µ–∫—Ç–µ) :contentReference[oaicite:4]{index=4}
            try:
                import importlib
                cfg = importlib.import_module("config")
                db_path = Path(getattr(cfg, "LOCAL_DB_PATH"))
            except Exception:
                # –§–æ–ª–±—ç–∫ ‚Äî –∏—â–µ–º *.db —Ä—è–¥–æ–º
                candidates = list(root.glob("**/*.db"))
                db_path = candidates[0] if candidates else None

    # --- –ó–∞–ø–∏—Å—å –æ—Ç—á—ë—Ç–∞ ---
    with out_path.open("w", encoding="utf-8", newline="\n") as out:
        # –®–∞–ø–∫–∞ + TREE
        ts = time.strftime("%Y-%m-%d %H:%M:%S")
        out.write("=" * 80 + "\n")
        out.write("PROJECT SNAPSHOT\n")
        out.write(f"Generated:   {ts}\n")
        out.write(f"Root:        {root}\n")
        out.write(f"Python:      {sys.version.split()[0]}\n")
        out.write("=" * 80 + "\n\n")

        if not args.no_tree:
            out.write("=" * 80 + "\n")
            out.write("PROJECT TREE\n")
            out.write("=" * 80 + "\n")
            out.write(render_tree(root, exclude=EXCLUDE_TREE))
            out.write("\n\n")

        # DB overview
        if not args.no_db and db_path:
            out.write(introspect_sqlite(db_path, sample_limit=args.db_sample))

        # Sheets overview
        if not args.no_sheets:
            out.write(introspect_gsheets(sample_limit=args.sheets_sample))

        # –ë–∞–Ω–¥–ª –∏—Å—Ö–æ–¥–Ω–∏–∫–æ–≤
        write_bundle(out, root, files)

    print(f"‚úì –ì–æ—Ç–æ–≤–æ: {out_path}")

if __name__ == "__main__":
    main()

--------------------------------------------------------------------------------
# FILE: config.py
# SIZE: 13794 bytes | SHA256(text): 2c1974d45eb66463e295ed01cce1a7b722213ca30c9967b4f06f69f00f148742
--------------------------------------------------------------------------------
# config.py
import os
import sys
import platform
from pathlib import Path
from typing import Dict, List, Set, Optional
from contextlib import contextmanager
import atexit

# ==================== –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è –∏–∑ .env ====================
from dotenv import load_dotenv
load_dotenv()

# ==================== –ò–º–ø–æ—Ä—Ç –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–º credentials ====================
import pyzipper
import tempfile

# ==================== –ë–∞–∑–æ–≤—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ ====================
if getattr(sys, 'frozen', False):
    # –†–µ–∂–∏–º —Å–±–æ—Ä–∫–∏ (PyInstaller)
    BASE_DIR = Path(sys.executable).parent
else:
    # –†–µ–∂–∏–º —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
    BASE_DIR = Path(__file__).parent.absolute()

# --- –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: –°–æ–∑–¥–∞–µ–º LOG_DIR —Å—Ä–∞–∑—É ---
if platform.system() == "Windows":
    LOG_DIR = Path(os.getenv('APPDATA')) / "WorkTimeTracker" / "logs"
else:
    LOG_DIR = Path.home() / ".local" / "share" / "WorkTimeTracker" / "logs"
LOG_DIR.mkdir(parents=True, exist_ok=True) # –°–æ–∑–¥–∞–µ–º –ø—Ä–∏ –∏–º–ø–æ—Ä—Ç–µ –º–æ–¥—É–ª—è
# ---

# ==================== –ü—É—Ç–∏ –∫ —Ñ–∞–π–ª–∞–º ====================
# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∞—Ä—Ö–∏–≤–∞ —Å credentials
CREDENTIALS_ZIP = BASE_DIR / 'secret_creds.zip'  # –∞—Ä—Ö–∏–≤ –¥–æ–ª–∂–µ–Ω –ª–µ–∂–∞—Ç—å —Ä—è–¥–æ–º —Å exe

# –ü–∞—Ä–æ–ª—å –±–µ—Ä—ë—Ç—Å—è –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –æ–∫—Ä—É–∂–µ–Ω–∏—è
CREDENTIALS_ZIP_PASSWORD = os.getenv("CREDENTIALS_ZIP_PASSWORD")
if CREDENTIALS_ZIP_PASSWORD is None:
    raise RuntimeError("CREDENTIALS_ZIP_PASSWORD –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ .env —Ñ–∞–π–ª–µ!")
CREDENTIALS_ZIP_PASSWORD = CREDENTIALS_ZIP_PASSWORD.encode('utf-8')

# --- –õ–µ–Ω–∏–≤–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ credentials ---
_CREDS_TMP_DIR = Path(tempfile.gettempdir()) / "wtt_creds"
_CREDS_TMP_DIR.mkdir(parents=True, exist_ok=True)
_CREDENTIALS_FILE: Optional[Path] = None

def _cleanup_credentials():
    """–£–¥–∞–ª—è–µ—Ç –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª —Å —É—á–µ—Ç–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏ –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ –∏–∑ –ø—Ä–æ—Ü–µ—Å—Å–∞."""
    try:
        if _CREDENTIALS_FILE and _CREDENTIALS_FILE.exists():
            _CREDENTIALS_FILE.unlink()
    except Exception:
        pass

# –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –æ—á–∏—Å—Ç–∫—É –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ
atexit.register(_cleanup_credentials)

@contextmanager
def credentials_path() -> Path:
    """
    –õ–µ–Ω–∏–≤–æ –∏ –≤—Ä–µ–º–µ–Ω–Ω–æ –∏–∑–≤–ª–µ–∫–∞–µ—Ç service_account.json –∏–∑ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ ZIP.
    –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: with credentials_path() as p: ...
    """
    global _CREDENTIALS_FILE
    
    # –ï—Å–ª–∏ —Ñ–∞–π–ª —É–∂–µ –∏–∑–≤–ª–µ—á–µ–Ω –∏ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ
    if _CREDENTIALS_FILE and _CREDENTIALS_FILE.exists():
        yield _CREDENTIALS_FILE
        return
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ ZIP-–∞—Ä—Ö–∏–≤–∞
    if not CREDENTIALS_ZIP.exists():
        raise FileNotFoundError(f"Zip —Å credentials –Ω–µ –Ω–∞–π–¥–µ–Ω: {CREDENTIALS_ZIP}")
    
    # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ñ–∞–π–ª –∏–∑ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∞—Ä—Ö–∏–≤–∞
    with pyzipper.AESZipFile(CREDENTIALS_ZIP) as zf:
        zf.pwd = CREDENTIALS_ZIP_PASSWORD
        try:
            data = zf.read('service_account.json')
        except KeyError:
            raise FileNotFoundError("–§–∞–π–ª 'service_account.json' –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –∞—Ä—Ö–∏–≤–µ")
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤–æ –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
        temp_file = _CREDS_TMP_DIR / 'service_account.json'
        with open(temp_file, 'wb') as f:
            f.write(data)
        
        _CREDENTIALS_FILE = temp_file
        yield _CREDENTIALS_FILE

def get_credentials_file() -> Path:
    """–û–±—Ä–∞—Ç–Ω–∞—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å: –ø–æ–ª—É—á–∏—Ç—å –ø—É—Ç—å –∫ JSON (–∏–∑–≤–ª–µ—á—ë—Ç –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –≤—ã–∑–æ–≤–µ)."""
    with credentials_path() as p:
        return Path(p)

LOCAL_DB_PATH = BASE_DIR / 'local_backup.db'
ERROR_LOG_FILE = LOG_DIR / 'error.log'
SYNC_LOG_FILE = LOG_DIR / 'sync.log'  # –î–æ–±–∞–≤–ª–µ–Ω –ª–æ–≥ –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏

# ==================== –ù–∞—Å—Ç—Ä–æ–π–∫–∏ Google Sheets ====================
GOOGLE_SHEET_NAME = "WorkLog"
USERS_SHEET = "Users"
WORKLOG_SHEET = "WorkLog"
ARCHIVE_SHEET = "Archive"
ACTIVE_SESSIONS_SHEET = "ActiveSessions"
SHIFT_CALENDAR_SHEET = ""  # –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: 'ShiftCalendar' / '–ì—Ä–∞—Ñ–∏–∫' –µ—Å–ª–∏ –ø–æ—è–≤–∏—Ç—Å—è –ª–∏—Å—Ç –≥—Ä–∞—Ñ–∏–∫–∞

# ==================== –õ–∏–º–∏—Ç—ã API ====================
GOOGLE_API_LIMITS: Dict[str, int] = {
    'max_requests_per_minute': 60,
    'max_rows_per_request': 50,
    'max_cells_per_request': 10000,
    'daily_limit': 100000
}

# ==================== –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ ====================
SYNC_INTERVAL: int = 100
SYNC_BATCH_SIZE: int = 35
API_MAX_RETRIES: int = 5  # –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ—Ç—Ä–∞–µ–≤
API_DELAY_SECONDS: float = 1.5  # –£–≤–µ–ª–∏—á–µ–Ω –±–∞–∑–æ–≤—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª
SYNC_RETRY_STRATEGY: List[int] = [60, 300, 900, 1800, 3600]  # 1, 5, 15, 30, 60 –º–∏–Ω—É—Ç - —É–≤–µ–ª–∏—á–µ–Ω–Ω–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è

# –ò–Ω—Ç–µ—Ä–≤–∞–ª—ã —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ä–µ–∂–∏–º–æ–≤ —Ä–∞–±–æ—Ç—ã
SYNC_INTERVAL_ONLINE: int = 60  # 60 —Å–µ–∫—É–Ω–¥ –ø—Ä–∏ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–π —Ä–∞–±–æ—Ç–µ
SYNC_INTERVAL_OFFLINE_RECOVERY: int = 300  # 300 —Å–µ–∫—É–Ω–¥ (5 –º–∏–Ω—É—Ç) –ø—Ä–∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–æ—Å–ª–µ –æ—Ñ—Ñ–ª–∞–π–Ω–∞

# ==================== –ì—Ä—É–ø–ø—ã –æ–±—Ä–∞–±–æ—Ç–∫–∏ ====================
GROUP_MAPPING: Dict[str, str] = {
    "call": "–í—Ö–æ–¥—è—â–∏–µ",
    "appointment": "–ó–∞–ø–∏—Å—å",
    "mail": "–ü–æ—á—Ç–∞",
    "dental": "–°—Ç–æ–º–∞—Ç–æ–ª–æ–≥–∏—è",
    "default": "–í—Ö–æ–¥—è—â–∏–µ"
}

# ==================== –°—Ç–∞—Ç—É—Å—ã —Å–∏—Å—Ç–µ–º—ã ====================
STATUSES: List[str] = [
    "–í —Ä–∞–±–æ—Ç–µ",
    "–ß–∞—Ç",
    "–ê—É–¥–∏–æ",
    "–ó–∞–ø–∏—Å—å",
    "–ê–Ω–∫–µ—Ç—ã",
    "–ü–µ—Ä–µ—Ä—ã–≤",
    "–û–±–µ–¥",
    "–¶–ò–¢–û",
    "–û–±—É—á–µ–Ω–∏–µ"
]

# –ì—Ä—É–ø–ø—ã –¥–ª—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ (—Ä–∞—Å–∫–ª–∞–¥–∫–∞ –∫–Ω–æ–ø–æ–∫)
STATUS_GROUPS: List[List[str]] = [
    ["–í —Ä–∞–±–æ—Ç–µ", "–ß–∞—Ç", "–ê—É–¥–∏–æ", "–ó–∞–ø–∏—Å—å", "–ê–Ω–∫–µ—Ç—ã"],   # –û—Å–Ω–æ–≤–Ω–∞—è —Ä–∞–±–æ—Ç–∞
    ["–ü–µ—Ä–µ—Ä—ã–≤", "–û–±–µ–¥"],                                # –ü–µ—Ä–µ—Ä—ã–≤—ã
    ["–¶–ò–¢–û", "–û–±—É—á–µ–Ω–∏–µ"]                                # –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ
]

CONFIRMATION_STATUSES: Set[str] = {"–ü–µ—Ä–µ—Ä—ã–≤", "–û–±–µ–¥", "–¶–ò–¢–û"}
RESTRICTED_STATUSES_FIRST_2H: Set[str] = {"–ü–µ—Ä–µ—Ä—ã–≤", "–û–±–µ–¥"}
MAX_COMMENT_LENGTH: int = 500
MAX_HISTORY_DAYS: int = 30

# ==================== –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ ====================
PASSWORD_MIN_LENGTH: int = 8
SESSION_TIMEOUT: int = 3600  # —Å–µ–∫—É–Ω–¥—ã
ALLOWED_DOMAINS: List[str] = ["company.com", "sberhealth.ru"]

# ==================== Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è ====================
TELEGRAM_BOT_TOKEN: str | None = os.getenv("8318266102:AAESpe4TIQpkTEAFuFD_ECZKWBkc5Tk32LU") or None
# –õ–∏—á–Ω—ã–π —á–∞—Ç –∞–¥–º–∏–Ω–∞:
TELEGRAM_ADMIN_CHAT_ID: str | None = os.getenv("1053909260") or None
# –û–±—â–∏–π –∫–∞–Ω–∞–ª –¥–ª—è –≥—Ä—É–ø–ø–æ–≤—ã—Ö –æ–±—ä—è–≤–ª–µ–Ω–∏–π (–º–æ–∂–µ—Ç –±—ã—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–π id):
TELEGRAM_BROADCAST_CHAT_ID: str | None = os.getenv("TELEGRAM_BROADCAST_CHAT_ID") or None
# –ê–Ω—Ç–∏-—Å–ø–∞–º –∫–ª—é—á–µ–π (–º–∏–Ω—É—Ç –º–µ–∂–¥—É –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º–∏ —Å–æ–±—ã—Ç–∏—è–º–∏)
TELEGRAM_MIN_INTERVAL_SEC: int = int(os.getenv("TELEGRAM_MIN_INTERVAL_SEC", "600"))
# –¢–∏—Ö–∏–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
TELEGRAM_SILENT: bool = os.getenv("TELEGRAM_SILENT", "0") == "1"
TELEGRAM_ALERTS_ENABLED: bool = bool(TELEGRAM_BOT_TOKEN and (TELEGRAM_ADMIN_CHAT_ID or TELEGRAM_BROADCAST_CHAT_ID))

# ==================== –ê—Ä—Ö–∏–≤–∏—Ä–æ–≤–∞–Ω–∏–µ ====================
ARCHIVE_DELETE_SOURCE_ROWS: bool = os.getenv("ARCHIVE_DELETE_SOURCE_ROWS", "1") == "1"

# ==================== –ü–æ—Ä–æ–≥–∏ –ø—Ä–∞–≤–∏–ª —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π ====================
# –æ–ø–æ–∑–¥–∞–Ω–∏–µ –Ω–∞ –ª–æ–≥–∏–Ω, –º–∏–Ω—É—Ç
LATE_LOGIN_MINUTES: int = int(os.getenv("LATE_LOGIN_MINUTES", "15"))
# —Å–ª–∏—à–∫–æ–º —á–∞—Å—Ç–∞—è —Å–º–µ–Ω–∞ —Å—Ç–∞—Ç—É—Å–æ–≤, —à—Ç—É–∫ –∑–∞ —á–∞—Å
OVER_STATUS_MAX_PER_HOUR: int = int(os.getenv("OVER_STATUS_MAX_PER_HOUR", "10"))
# –ø–æ—Ä–æ–≥ –æ—á–µ—Ä–µ–¥–∏ –Ω–µ—Å–∏–Ω—Ö—Ä–æ–Ω–∞
NOTIFY_QUEUE_THRESHOLD: int = int(os.getenv("NOTIFY_QUEUE_THRESHOLD", "50"))

# ==================== –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è ====================
LOG_LEVEL: str = "INFO"  # DEBUG, INFO, WARNING, ERROR, CRITICAL
LOG_ROTATION_SIZE: int = 10 * 1024 * 1024  # 10MB
LOG_BACKUP_COUNT: int = 5  # –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–∑–µ—Ä–≤–Ω—ã—Ö –∫–æ–ø–∏–π –ª–æ–≥–æ–≤

# ==================== –í–∞–ª–∏–¥–∞—Ü–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ ====================
def validate_config() -> None:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ."""
    errors = []
    
    # –õ–µ–Ω–∏–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —É—á–µ—Ç–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    try:
        with credentials_path() as creds_file:
            if not creds_file.exists():
                errors.append(f"–§–∞–π–ª —É—á–µ—Ç–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –Ω–µ –Ω–∞–π–¥–µ–Ω: {creds_file}")
    except Exception as e:
        errors.append(f"–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ —É—á–µ—Ç–Ω—ã–º –¥–∞–Ω–Ω—ã–º: {e}")
    
    if not LOG_DIR.exists():
        try:
            LOG_DIR.mkdir(parents=True)
        except Exception as e:
            errors.append(f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –ª–æ–≥–æ–≤: {e}")
    
    if not GROUP_MAPPING.get("default"):
        errors.append("–ù–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –≥—Ä—É–ø–ø—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤ GROUP_MAPPING")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
    if not CREDENTIALS_ZIP.exists():
        errors.append(f"–§–∞–π–ª secret_creds.zip –Ω–µ –Ω–∞–π–¥–µ–Ω: {CREDENTIALS_ZIP}")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä–∞—Ç–µ–≥–∏—é —Ä–µ—Ç—Ä–∞–µ–≤
    if len(SYNC_RETRY_STRATEGY) < 3:
        errors.append("–°—Ç—Ä–∞—Ç–µ–≥–∏—è –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –¥–æ–ª–∂–Ω–∞ —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 3 –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞")
    
    if max(SYNC_RETRY_STRATEGY) < 1800:
        errors.append("–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–µ –º–µ–Ω–µ–µ 1800 —Å–µ–∫—É–Ω–¥ (30 –º–∏–Ω—É—Ç)")
    
    if errors:
        raise ValueError("–û—à–∏–±–∫–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏:\n- " + "\n- ".join(errors))

# ==================== –£—Ç–∏–ª–∏—Ç—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ ====================
def get_sync_retry_delay(attempt: int) -> int:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–∞–¥–µ—Ä–∂–∫—É –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏.
    
    Args:
        attempt: –ù–æ–º–µ—Ä –ø–æ–ø—ã—Ç–∫–∏ (–Ω–∞—á–∏–Ω–∞—è —Å 0)
    
    Returns:
        –ó–∞–¥–µ—Ä–∂–∫–∞ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
    """
    if attempt < len(SYNC_RETRY_STRATEGY):
        return SYNC_RETRY_STRATEGY[attempt]
    return SYNC_RETRY_STRATEGY[-1]  # –ü–æ—Å–ª–µ–¥–Ω–∏–π –∏–Ω—Ç–µ—Ä–≤–∞–ª –¥–ª—è –≤—Å–µ—Ö –ø–æ—Å–ª–µ–¥—É—é—â–∏—Ö –ø–æ–ø—ã—Ç–æ–∫

def should_retry_sync(error: Exception) -> bool:
    """
    –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, —Å–ª–µ–¥—É–µ—Ç –ª–∏ –ø–æ–≤—Ç–æ—Ä—è—Ç—å –ø–æ–ø—ã—Ç–∫—É —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –ø—Ä–∏ –¥–∞–Ω–Ω–æ–π –æ—à–∏–±–∫–µ.
    
    Args:
        error: –ò—Å–∫–ª—é—á–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –ø—Ä–æ–∏–∑–æ—à–ª–æ
        
    Returns:
        True –µ—Å–ª–∏ —Å–ª–µ–¥—É–µ—Ç –ø–æ–≤—Ç–æ—Ä–∏—Ç—å, False –µ—Å–ª–∏ –Ω–µ—Ç
    """
    # –û—à–∏–±–∫–∏, –ø—Ä–∏ –∫–æ—Ç–æ—Ä—ã—Ö —Å—Ç–æ–∏—Ç –ø–æ–≤—Ç–æ—Ä—è—Ç—å –ø–æ–ø—ã—Ç–∫—É
    retryable_errors = [
        "ConnectionError",
        "TimeoutError",
        "HttpError",
        "ServiceUnavailable",
        "RateLimitExceeded"
    ]
    
    error_name = type(error).__name__
    return any(retryable in error_name for retryable in retryable_errors)

# ==================== –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ ====================
try:
    validate_config()
    print("‚úì –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–æ –ø—Ä–æ–≤–µ—Ä–µ–Ω–∞")
    print(f"‚úì –°—Ç—Ä–∞—Ç–µ–≥–∏—è –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫: {SYNC_RETRY_STRATEGY}")
except Exception as e:
    print(f"‚úó –û—à–∏–±–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")
    raise

# ==================== –£—Ç–∏–ª–∏—Ç—ã –¥–ª—è PyInstaller ====================
def get_resource_path(relative_path: str) -> str:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∞–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—É—Ç—å –∫ —Ä–µ—Å—É—Ä—Å—É, —É—á–∏—Ç—ã–≤–∞—è PyInstaller."""
    if hasattr(sys, '_MEIPASS'):
        base_path = Path(sys._MEIPASS)
    else:
        base_path = BASE_DIR
    return str(base_path / relative_path)

# ==================== –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è ====================
if __name__ == "__main__":
    print(f"BASE_DIR: {BASE_DIR}")
    print(f"LOG_DIR: {LOG_DIR}")
    print(f"CREDENTIALS_ZIP: {CREDENTIALS_ZIP}")
    print(f"SYNC_RETRY_STRATEGY: {SYNC_RETRY_STRATEGY}")
    print(f"–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞: {max(SYNC_RETRY_STRATEGY)} —Å–µ–∫—É–Ω–¥ ({max(SYNC_RETRY_STRATEGY)/60} –º–∏–Ω—É—Ç)")
    
    # –¢–µ—Å—Ç–∏—Ä—É–µ–º –ª–µ–Ω–∏–≤—É—é –∑–∞–≥—Ä—É–∑–∫—É credentials
    try:
        with credentials_path() as creds:
            print(f"‚úì Credentials file: {creds}")
            print(f"‚úì File exists: {creds.exists()}")
    except Exception as e:
        print(f"‚úó Error accessing credentials: {e}")

--------------------------------------------------------------------------------
# FILE: diagnostics_report.json
# SIZE: 10268 bytes | SHA256(text): 24d3d43f0e8dcf768c19369a3df6144f027ebd4d14aa43e3310cb20bda4f8f25
--------------------------------------------------------------------------------
{
  "ts": "2025-09-02T17:13:19",
  "log_dir": "C:\\Users\\–°–µ—Ä–≥–µ–π\\AppData\\Roaming\\WorkTimeTracker\\logs",
  "credentials_file": "C:\\Temp\\wtt_creds\\service_account.json",
  "sqlite": {
    "objects": [
      {
        "name": "app_logs",
        "type": "table",
        "sql": "CREATE TABLE app_logs (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                ts TEXT NOT NULL,\n                level TEXT NOT NULL,\n                message TEXT NOT NULL\n            )"
      },
      {
        "name": "app_logs_legacy_20250826175446",
        "type": "table",
        "sql": "CREATE TABLE \"app_logs_legacy_20250826175446\" (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                ts TEXT NOT NULL,\n                level TEXT NOT NULL,\n                message TEXT NOT NULL\n            )"
      },
      {
        "name": "check_comment_length",
        "type": "trigger",
        "sql": "CREATE TRIGGER check_comment_length\n            BEFORE INSERT ON logs\n            FOR EACH ROW\n            WHEN length(NEW.comment) > 500\n            BEGIN\n                SELECT RAISE(ABORT, 'Comment too long');\n            END"
      },
      {
        "name": "idx_app_logs_ts",
        "type": "index",
        "sql": "CREATE INDEX idx_app_logs_ts ON app_logs(ts)"
      },
      {
        "name": "idx_logs_email",
        "type": "index",
        "sql": "CREATE INDEX idx_logs_email ON logs(email)"
      },
      {
        "name": "idx_logs_session",
        "type": "index",
        "sql": "CREATE INDEX idx_logs_session ON logs(session_id)"
      },
      {
        "name": "idx_logs_synced",
        "type": "index",
        "sql": "CREATE INDEX idx_logs_synced ON logs(synced)"
      },
      {
        "name": "idx_logs_timestamp",
        "type": "index",
        "sql": "CREATE INDEX idx_logs_timestamp ON logs(timestamp)"
      },
      {
        "name": "idx_logs_ts",
        "type": "index",
        "sql": "CREATE INDEX idx_logs_ts ON \"app_logs_legacy_20250826175446\"(ts)"
      },
      {
        "name": "idx_offline_actions_status_ts",
        "type": "index",
        "sql": "CREATE INDEX idx_offline_actions_status_ts ON offline_actions(status, ts)"
      },
      {
        "name": "logs",
        "type": "table",
        "sql": "CREATE TABLE logs (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                session_id TEXT NOT NULL,\n                email TEXT NOT NULL,\n                name TEXT NOT NULL,\n                status TEXT,\n                action_type TEXT NOT NULL,\n                comment TEXT,\n                timestamp TEXT NOT NULL,\n                synced INTEGER DEFAULT 0,\n                sync_attempts INTEGER DEFAULT 0,\n                last_sync_attempt TEXT,\n                priority INTEGER DEFAULT 1,\n                status_start_time TEXT,\n                status_end_time TEXT,\n                reason TEXT,\n                user_group TEXT\n            )"
      },
      {
        "name": "offline_actions",
        "type": "table",
        "sql": "CREATE TABLE offline_actions (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                ts TEXT NOT NULL,\n                action_type TEXT NOT NULL,\n                payload TEXT NOT NULL,  -- JSON-—Å—Ç—Ä–æ–∫–∞\n                status TEXT NOT NULL DEFAULT 'pending'  -- pending|synced|failed\n            )"
      },
      {
        "name": "prevent_duplicate_logout",
        "type": "trigger",
        "sql": "CREATE TRIGGER prevent_duplicate_logout\n            BEFORE INSERT ON logs\n            FOR EACH ROW\n            WHEN LOWER(NEW.action_type) = 'logout' AND EXISTS (\n                SELECT 1 FROM logs\n                WHERE session_id = NEW.session_id\n                  AND LOWER(action_type) = 'logout'\n                  AND timestamp > datetime('now', '-5 minutes')\n            )\n            BEGIN\n                SELECT RAISE(ABORT, 'Duplicate LOGOUT action');\n            END"
      },
      {
        "name": "sqlite_sequence",
        "type": "table",
        "sql": "CREATE TABLE sqlite_sequence(name,seq)"
      }
    ],
    "stats": {
      "app_logs": 0,
      "app_logs_legacy_20250826175446": 0,
      "logs": 26,
      "offline_actions": 0
    },
    "samples": {
      "app_logs": [],
      "app_logs_legacy_20250826175446": [],
      "logs": [
        [
          26,
          "10@ya.ru_20250902102558",
          "10@ya.ru",
          "—Ç–µ—Å—Ç —Å—Ç–æ–º 3",
          "–ó–∞–≤–µ—Ä—à–µ–Ω–æ",
          "LOGOUT",
          "–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Å–º–µ–Ω—ã (–Ω–æ—Ä–º–∞–ª—å–Ω–æ–µ)",
          "2025-09-02T07:31:20.622314+00:00",
          0,
          0,
          null,
          1,
          "2025-09-02T10:31:20.622249",
          "2025-09-02T10:31:20.622249",
          "user",
          "–°—Ç–æ–º–∞—Ç–æ–ª–æ–≥–∏—è"
        ],
        [
          25,
          "10@ya.ru_20250902102558",
          "10@ya.ru",
          "—Ç–µ—Å—Ç —Å—Ç–æ–º 3",
          "–ê—É–¥–∏–æ",
          "STATUS_CHANGE",
          null,
          "2025-09-02T07:30:03.200596+00:00",
          1,
          1,
          "2025-09-02T07:30:05.016279+00:00",
          1,
          "2025-09-02T10:30:03.197439",
          "2025-09-02T07:31:20.619894+00:00",
          null,
          null
        ],
        [
          24,
          "10@ya.ru_20250902102558",
          "10@ya.ru",
          "—Ç–µ—Å—Ç —Å—Ç–æ–º 3",
          "–ß–∞—Ç",
          "STATUS_CHANGE",
          null,
          "2025-09-02T07:29:57.160421+00:00",
          1,
          2,
          "2025-09-02T07:30:03.496395+00:00",
          1,
          "2025-09-02T10:29:57.156445",
          "2025-09-02T10:30:03.197439",
          null,
          null
        ],
        [
          23,
          "10@ya.ru_20250902102558",
          "10@ya.ru",
          "—Ç–µ—Å—Ç —Å—Ç–æ–º 3",
          "–í —Ä–∞–±–æ—Ç–µ",
          "LOGIN",
          "–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã",
          "2025-09-02T07:25:58.866299+00:00",
          1,
          2,
          "2025-09-02T07:29:57.501512+00:00",
          1,
          "2025-09-02T10:25:58.866228",
          "2025-09-02T10:29:57.156445",
          null,
          null
        ],
        [
          22,
          "10@ya.ru_20250901175741",
          "10@ya.ru",
          "—Ç–µ—Å—Ç —Å—Ç–æ–º 3",
          "–ó–∞–≤–µ—Ä—à–µ–Ω–æ",
          "LOGOUT",
          "–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ —á–µ—Ä–µ–∑ –∫—Ä–µ—Å—Ç–∏–∫",
          "2025-09-02T05:58:06.182047+00:00",
          0,
          0,
          null,
          1,
          "2025-09-02T08:58:06.181994",
          "2025-09-02T08:58:06.181994",
          "user",
          "–°—Ç–æ–º–∞—Ç–æ–ª–æ–≥–∏—è"
        ]
      ],
      "offline_actions": []
    },
    "extra": {
      "logs_unsynced": 2,
      "offline_actions_pending": 0
    }
  },
  "sheets": {
    "worksheets": [
      {
        "title": "Admins",
        "header": [
          "Login",
          "Password"
        ],
        "rows_hint": 1000,
        "cols_hint": 26
      },
      {
        "title": "Users",
        "header": [
          "Email",
          "Name",
          "Phone",
          "Role",
          "Telegram",
          "ShiftHours",
          "Hours",
          "NotifyTelegram",
          "Group"
        ],
        "rows_hint": 999,
        "cols_hint": 26
      },
      {
        "title": "Groups",
        "header": [
          "Group",
          "Sheet",
          "Statuses",
          "–í–æ–∑–º–æ–∂–Ω—ã–µ —Å—Ç–∞—Ç—É—Å—ã: \"–í —Ä–∞–±–æ—Ç–µ\",\n    \"–ß–∞—Ç\",\n    \"–ê—É–¥–∏–æ\",\n    \"–ó–∞–ø–∏—Å—å\",\n    \"–ê–Ω–∫–µ—Ç—ã\",\n    \"–ü–µ—Ä–µ—Ä—ã–≤\",\n    \"–û–±–µ–¥\",\n    \"–¶–ò–¢–û\",\n    \"–û–±—É—á–µ–Ω–∏–µ\" \n–£–∫–∞–∑—ã–≤–∞—Ç—å —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é, –±–µ–∑ –∫–æ–≤—ã—á–µ–∫"
        ],
        "rows_hint": 1000,
        "cols_hint": 18
      },
      {
        "title": "WorkLog_–ó–∞–ø–∏—Å—å",
        "header": [
          "123@ya.ru",
          "—Ç–µ—Å—Ç –∑–∞–ø–∏—Å–∏",
          "–í —Ä–∞–±–æ—Ç–µ",
          "LOGIN",
          "–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã",
          "2025-08-25T17:49:24.965579",
          "123@ya.r_20250825174924",
          "2025-08-25T17:49:24.965517"
        ],
        "rows_hint": 1000,
        "cols_hint": 20
      },
      {
        "title": "WorkLog_–í—Ö–æ–¥—è—â–∏–µ",
        "header": [
          "Email",
          "Name",
          "Status",
          "ActionType",
          "Comment",
          "Timestamp",
          "SessionID",
          "StatusStartTime",
          "StatusEndTime"
        ],
        "rows_hint": 28,
        "cols_hint": 20
      },
      {
        "title": "ActiveSessions",
        "header": [
          "Email",
          "Name",
          "SessionID",
          "LoginTime",
          "Status",
          "LogoutTime",
          "RemoteCommand"
        ],
        "rows_hint": 905,
        "cols_hint": 26
      },
      {
        "title": "WorkLog_–°—Ç–æ–º–∞—Ç–æ–ª–æ–≥–∏—è",
        "header": [
          "10@ya.ru",
          "—Ç–µ—Å—Ç —Å—Ç–æ–º 3",
          "–í —Ä–∞–±–æ—Ç–µ",
          "LOGIN",
          "–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã",
          "2025-09-01 16:05:14",
          "10@ya.ru_20250901160514",
          "2025-09-01 19:05:14",
          "2025-09-01 16:05:20"
        ],
        "rows_hint": 775,
        "cols_hint": 18
      },
      {
        "title": "WorkLog_–ü–æ—á—Ç–∞",
        "header": [
          "7@ya.ru",
          "–¢–µ—Å—Ç –ø–æ—á—Ç—ã",
          "–í —Ä–∞–±–æ—Ç–µ",
          "LOGIN",
          "–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã",
          "2025-08-25T14:21:50.941225",
          "7@ya.ru_20250825142150",
          "2025-08-25T14:21:50.941160"
        ],
        "rows_hint": 891,
        "cols_hint": 20
      },
      {
        "title": "AccessControl",
        "header": [
          "KeyType",
          "KeyValue",
          "AccessStatus",
          "BlockUntil",
          "Reason",
          "UpdatedAt"
        ],
        "rows_hint": 1000,
        "cols_hint": 26
      }
    ],
    "expectations": []
  }
}

--------------------------------------------------------------------------------
# FILE: logging_setup.py
# SIZE: 2050 bytes | SHA256(text): 98dc7bafe517d42a5c51d8b834ca7b819571876388aff69be7e13d72421c7037
--------------------------------------------------------------------------------
# logging_setup.py
from __future__ import annotations

import logging
from logging.handlers import RotatingFileHandler
from pathlib import Path
import sys
import re

def _mask_pii(msg: str) -> str:
    # –ø—Ä–æ—Å—Ç–æ–µ –º–∞—Å–∫–∏—Ä–æ–≤–∞–Ω–∏–µ email –∏ —Ç–µ–ª–µ—Ñ–æ–Ω–æ–≤
    msg = re.sub(r'([A-Za-z0-9._%+-]+)@([A-Za-z0-9.-]+\.[A-Za-z]{2,})', r'***@\2', msg)
    msg = re.sub(r'\+?\d[\d\s\-()]{6,}\d', '***PHONE***', msg)
    return msg

class PIIFilter(logging.Filter):
    def filter(self, record: logging.LogRecord) -> bool:
        if isinstance(record.msg, str):
            record.msg = _mask_pii(record.msg)
        return True

def setup_logging(app_name: str, log_dir: Path, level_console: int = logging.INFO, level_file: int = logging.DEBUG, reset: bool = True):
    log_dir.mkdir(parents=True, exist_ok=True)
    logfile = log_dir / f"{app_name}.log"

    root = logging.getLogger()
    root.setLevel(logging.DEBUG)
    # –í–ê–ñ–ù–û: —É–±–∏—Ä–∞–µ–º —Ä–∞–Ω–µ–µ –Ω–∞–≤–µ—à–∞–Ω–Ω—ã–µ —Ö–µ–Ω–¥–ª–µ—Ä—ã (basicConfig –∏ —Ç.–¥.), —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –¥—É–±–ª–µ–π
    if reset and root.handlers:
        for h in list(root.handlers):
            root.removeHandler(h)

    fmt = logging.Formatter(
        "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S"
    )

    # —Ñ–∞–π–ª
    fh = RotatingFileHandler(logfile, maxBytes=5_000_000, backupCount=5, encoding="utf-8")
    fh.setLevel(level_file)
    fh.setFormatter(fmt)
    fh.addFilter(PIIFilter())
    root.addHandler(fh)

    # –∫–æ–Ω—Å–æ–ª—å
    ch = logging.StreamHandler(sys.stdout)
    ch.setLevel(level_console)
    ch.setFormatter(fmt)
    ch.addFilter(PIIFilter())
    root.addHandler(ch)

    # –ì–ª—É—à–∏–º –±–æ–ª—Ç–ª–∏–≤—ã–µ —Å—Ç–æ—Ä–æ–Ω–Ω–∏–µ –ª–∏–±—ã
    logging.getLogger("urllib3").setLevel(logging.WARNING)
    logging.getLogger("google").setLevel(logging.WARNING)
    logging.getLogger("gspread").setLevel(logging.INFO)
    logging.captureWarnings(True)
    return logfile

--------------------------------------------------------------------------------
# FILE: map_project.py
# SIZE: 569 bytes | SHA256(text): b482c900c1c23a191bee42e296ea4d67d4d4c8044506ff8e103397d7392a9907
--------------------------------------------------------------------------------
import os

EXCLUDE = {'.venv', '__pycache__', '.git', '.idea', 'dist', 'build'}
def tree(dir_path, prefix=''):
    entries = [e for e in os.listdir(dir_path) if e not in EXCLUDE]
    entries.sort()
    for i, name in enumerate(entries):
        path = os.path.join(dir_path, name)
        connector = '‚îî‚îÄ‚îÄ ' if i == len(entries) - 1 else '‚îú‚îÄ‚îÄ '
        print(prefix + connector + name)
        if os.path.isdir(path):
            extension = '    ' if i == len(entries) - 1 else '‚îÇ   '
            tree(path, prefix + extension)

tree('.')

--------------------------------------------------------------------------------
# FILE: project_report.txt
# SIZE: 133737 bytes | SHA256(text): 844b022beeadc435d2117c68bb65b3181031f8e509b99077d4096a47eb70fbbc
--------------------------------------------------------------------------------
================================================================================
PROJECT SNAPSHOT
Generated:   2025-09-02 17:12:59
Root:        C:\moy python\projects vs code\roma
Python:      3.13.5
================================================================================

================================================================================
PROJECT TREE
================================================================================
‚îú‚îÄ‚îÄ .env
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ admin_app
‚îÇ   ‚îú‚îÄ‚îÄ gui_admin.py
‚îÇ   ‚îú‚îÄ‚îÄ main_admin.py
‚îÇ   ‚îú‚îÄ‚îÄ repo.py
‚îÇ   ‚îî‚îÄ‚îÄ schedule_parser.py
‚îú‚îÄ‚îÄ archiver.py
‚îú‚îÄ‚îÄ auto_sync.py
‚îú‚îÄ‚îÄ build_admin.py
‚îú‚îÄ‚îÄ build_user.py
‚îú‚îÄ‚îÄ bundle_project.py
‚îú‚îÄ‚îÄ config.py
‚îú‚îÄ‚îÄ credentials
‚îÇ   ‚îî‚îÄ‚îÄ secret_creds.zip
‚îú‚îÄ‚îÄ diagnose_sync.log
‚îú‚îÄ‚îÄ diagnose_user_log.log
‚îú‚îÄ‚îÄ diagnostics_report.json
‚îú‚îÄ‚îÄ libcrypto-1_1-x64.dll
‚îú‚îÄ‚îÄ libcrypto-1_1.dll
‚îú‚îÄ‚îÄ libssl-1_1-x64.dll
‚îú‚îÄ‚îÄ libssl-1_1.dll
‚îú‚îÄ‚îÄ local_backup.db
‚îú‚îÄ‚îÄ logging_setup.py
‚îú‚îÄ‚îÄ logs

‚îú‚îÄ‚îÄ map_project.py
‚îú‚îÄ‚îÄ project_report.txt
‚îú‚îÄ‚îÄ pyproject.toml
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ secret_creds.zip
‚îú‚îÄ‚îÄ sheets_api.py
‚îú‚îÄ‚îÄ sync
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ network.py
‚îÇ   ‚îú‚îÄ‚îÄ notifications.py
‚îÇ   ‚îî‚îÄ‚îÄ sync_queue.py
‚îú‚îÄ‚îÄ telegram_bot
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ main.py
‚îÇ   ‚îî‚îÄ‚îÄ notifier.py
‚îú‚îÄ‚îÄ tools
‚îÇ   ‚îú‚îÄ‚îÄ doctor.py
‚îÇ   ‚îú‚îÄ‚îÄ tg_envcheck.py
‚îÇ   ‚îî‚îÄ‚îÄ tg_send.py
‚îú‚îÄ‚îÄ user_app
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ api.py
‚îÇ   ‚îú‚îÄ‚îÄ app.log
‚îÇ   ‚îú‚îÄ‚îÄ db_local.py
‚îÇ   ‚îú‚îÄ‚îÄ db_migrations.py
‚îÇ   ‚îú‚îÄ‚îÄ gui.py
‚îÇ   ‚îú‚îÄ‚îÄ login_window.py
‚îÇ   ‚îú‚îÄ‚îÄ main.py
‚îÇ   ‚îú‚îÄ‚îÄ sberhealf.ico
‚îÇ   ‚îú‚îÄ‚îÄ sberhealf.png
‚îÇ   ‚îú‚îÄ‚îÄ signals.py
‚îÇ   ‚îî‚îÄ‚îÄ ui_helpers.py
‚îî‚îÄ‚îÄ work_time_tracker.egg-info
    ‚îú‚îÄ‚îÄ PKG-INFO
    ‚îú‚îÄ‚îÄ SOURCES.txt
    ‚îú‚îÄ‚îÄ dependency_links.txt
    ‚îú‚îÄ‚îÄ entry_points.txt
    ‚îú‚îÄ‚îÄ requires.txt
    ‚îî‚îÄ‚îÄ top_level.txt

================================================================================
LOCAL SQLITE OVERVIEW
DB Path: c:\moy python\projects vs code\roma\local_backup.db
================================================================================
database_list: [(0, 'main', 'c:\\moy python\\projects vs code\\roma\\local_backup.db')]
--------------------------------------------------------------------------------
[TABLE] app_logs
schema: CREATE TABLE app_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ts TEXT NOT NULL,
                level TEXT NOT NULL,
                message TEXT NOT NULL
            )
columns:
  - id INTEGER NOTNULL=0 PK=1 DEFAULT=None
  - ts TEXT NOTNULL=1 PK=0 DEFAULT=None
  - level TEXT NOTNULL=1 PK=0 DEFAULT=None
  - message TEXT NOTNULL=1 PK=0 DEFAULT=None
indexes:
  - idx_app_logs_ts UNIQUE=0
      * 1: ts
rows_count: 0
--------------------------------------------------------------------------------
[TABLE] app_logs_legacy_20250826175446
schema: CREATE TABLE "app_logs_legacy_20250826175446" (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ts TEXT NOT NULL,
                level TEXT NOT NULL,
                message TEXT NOT NULL
            )
columns:
  - id INTEGER NOTNULL=0 PK=1 DEFAULT=None
  - ts TEXT NOTNULL=1 PK=0 DEFAULT=None
  - level TEXT NOTNULL=1 PK=0 DEFAULT=None
  - message TEXT NOTNULL=1 PK=0 DEFAULT=None
indexes:
  - idx_logs_ts UNIQUE=0
      * 1: ts
rows_count: 0
--------------------------------------------------------------------------------
[TABLE] logs
schema: CREATE TABLE logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                session_id TEXT NOT NULL,
                email TEXT NOT NULL,
                name TEXT NOT NULL,
                status TEXT,
                action_type TEXT NOT NULL,
                comment TEXT,
                timestamp TEXT NOT NULL,
                synced INTEGER DEFAULT 0,
                sync_attempts INTEGER DEFAULT 0,
                last_sync_attempt TEXT,
                priority INTEGER DEFAULT 1,
                status_start_time TEXT,
                status_end_time TEXT,
                reason TEXT,
                user_group TEXT
            )
columns:
  - id INTEGER NOTNULL=0 PK=1 DEFAULT=None
  - session_id TEXT NOTNULL=1 PK=0 DEFAULT=None
  - email TEXT NOTNULL=1 PK=0 DEFAULT=None
  - name TEXT NOTNULL=1 PK=0 DEFAULT=None
  - status TEXT NOTNULL=0 PK=0 DEFAULT=None
  - action_type TEXT NOTNULL=1 PK=0 DEFAULT=None
  - comment TEXT NOTNULL=0 PK=0 DEFAULT=None
  - timestamp TEXT NOTNULL=1 PK=0 DEFAULT=None
  - synced INTEGER NOTNULL=0 PK=0 DEFAULT=0
  - sync_attempts INTEGER NOTNULL=0 PK=0 DEFAULT=0
  - last_sync_attempt TEXT NOTNULL=0 PK=0 DEFAULT=None
  - priority INTEGER NOTNULL=0 PK=0 DEFAULT=1
  - status_start_time TEXT NOTNULL=0 PK=0 DEFAULT=None
  - status_end_time TEXT NOTNULL=0 PK=0 DEFAULT=None
  - reason TEXT NOTNULL=0 PK=0 DEFAULT=None
  - user_group TEXT NOTNULL=0 PK=0 DEFAULT=None
indexes:
  - idx_logs_session UNIQUE=0
      * 1: session_id
  - idx_logs_timestamp UNIQUE=0
      * 7: timestamp
  - idx_logs_synced UNIQUE=0
      * 8: synced
  - idx_logs_email UNIQUE=0
      * 2: email
triggers:
  - check_comment_length: CREATE TRIGGER check_comment_length
            BEFORE INSERT ON logs
            FOR EACH ROW
            WHEN length(NEW.comment) > 500
            BEGIN
                SELECT RAISE(ABORT, 'Comment too long');
            END
  - prevent_duplicate_logout: CREATE TRIGGER prevent_duplicate_logout
            BEFORE INSERT ON logs
            FOR EACH ROW
            WHEN LOWER(NEW.action_type) = 'logout' AND EXISTS (
                SELECT 1 FROM logs
                WHERE session_id = NEW.session_id
                  AND LOWER(action_type) = 'logout'
                  AND timestamp > datetime('now', '-5 minutes')
            )
            BEGIN
                SELECT RAISE(ABORT, 'Duplicate LOGOUT action');
            END
rows_count: 26
sample rows (last):
  ‚Ä¢ (26, '10@ya.ru_20250902102558', '10@ya.ru', '—Ç–µ—Å—Ç —Å—Ç–æ–º 3', '–ó–∞–≤–µ—Ä—à–µ–Ω–æ', 'LOGOUT', '–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Å–º–µ–Ω—ã (–Ω–æ—Ä–º–∞–ª—å–Ω–æ–µ)', '2025-09-02T07:31:20.622314+00:00', 0, 0, None, 1, '2025-09-02T10:31:20.622249', '2025-09-02T10:31:20.622249', 'user', '–°—Ç–æ–º–∞—Ç–æ–ª–æ–≥–∏—è')
  ‚Ä¢ (25, '10@ya.ru_20250902102558', '10@ya.ru', '—Ç–µ—Å—Ç —Å—Ç–æ–º 3', '–ê—É–¥–∏–æ', 'STATUS_CHANGE', None, '2025-09-02T07:30:03.200596+00:00', 1, 1, '2025-09-02T07:30:05.016279+00:00', 1, '2025-09-02T10:30:03.197439', '2025-09-02T07:31:20.619894+00:00', None, None)
  ‚Ä¢ (24, '10@ya.ru_20250902102558', '10@ya.ru', '—Ç–µ—Å—Ç —Å—Ç–æ–º 3', '–ß–∞—Ç', 'STATUS_CHANGE', None, '2025-09-02T07:29:57.160421+00:00', 1, 2, '2025-09-02T07:30:03.496395+00:00', 1, '2025-09-02T10:29:57.156445', '2025-09-02T10:30:03.197439', None, None)
  ‚Ä¢ (23, '10@ya.ru_20250902102558', '10@ya.ru', '—Ç–µ—Å—Ç —Å—Ç–æ–º 3', '–í —Ä–∞–±–æ—Ç–µ', 'LOGIN', '–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã', '2025-09-02T07:25:58.866299+00:00', 1, 2, '2025-09-02T07:29:57.501512+00:00', 1, '2025-09-02T10:25:58.866228', '2025-09-02T10:29:57.156445', None, None)
  ‚Ä¢ (22, '10@ya.ru_20250901175741', '10@ya.ru', '—Ç–µ—Å—Ç —Å—Ç–æ–º 3', '–ó–∞–≤–µ—Ä—à–µ–Ω–æ', 'LOGOUT', '–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ —á–µ—Ä–µ–∑ –∫—Ä–µ—Å—Ç–∏–∫', '2025-09-02T05:58:06.182047+00:00', 0, 0, None, 1, '2025-09-02T08:58:06.181994', '2025-09-02T08:58:06.181994', 'user', '–°—Ç–æ–º–∞—Ç–æ–ª–æ–≥–∏—è')
--------------------------------------------------------------------------------
[TABLE] offline_actions
schema: CREATE TABLE offline_actions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ts TEXT NOT NULL,
                action_type TEXT NOT NULL,
                payload TEXT NOT NULL,  -- JSON-—Å—Ç—Ä–æ–∫–∞
                status TEXT NOT NULL DEFAULT 'pending'  -- pending|synced|failed
            )
columns:
  - id INTEGER NOTNULL=0 PK=1 DEFAULT=None
  - ts TEXT NOTNULL=1 PK=0 DEFAULT=None
  - action_type TEXT NOTNULL=1 PK=0 DEFAULT=None
  - payload TEXT NOTNULL=1 PK=0 DEFAULT=None
  - status TEXT NOTNULL=1 PK=0 DEFAULT='pending'
indexes:
  - idx_offline_actions_status_ts UNIQUE=0
      * 4: status
      * 1: ts
rows_count: 0
--------------------------------------------------------------------------------
[TRIGGERS GLOBAL]
  - check_comment_length on logs: CREATE TRIGGER check_comment_length
            BEFORE INSERT ON logs
            FOR EACH ROW
            WHEN length(NEW.comment) > 500
            BEGIN
                SELECT RAISE(ABORT, 'Comment too long');
            END
  - prevent_duplicate_logout on logs: CREATE TRIGGER prevent_duplicate_logout
            BEFORE INSERT ON logs
            FOR EACH ROW
            WHEN LOWER(NEW.action_type) = 'logout' AND EXISTS (
                SELECT 1 FROM logs
                WHERE session_id = NEW.session_id
                  AND LOWER(action_type) = 'logout'
                  AND timestamp > datetime('now', '-5 minutes')
            )
            BEGIN
                SELECT RAISE(ABORT, 'Duplicate LOGOUT action');
            END
================================================================================
GOOGLE SHEETS OVERVIEW
================================================================================
Spreadsheet: WorkLog
--------------------------------------------------------------------------------
[SHEET] Admins
header: ['Login', 'Password']
rows_count (non-empty): 1
sample rows (first 3):
  ‚Ä¢ ['Admin', 'qwerty']
--------------------------------------------------------------------------------
[SHEET] Users
header: ['Email', 'Name', 'Phone', 'Role', 'Telegram', 'ShiftHours', 'Hours', 'NotifyTelegram', 'Group']
rows_count (non-empty): 12
sample rows (first 3):
  ‚Ä¢ ['1@ya.ru', '—Ç–µ—Å—Ç–æ–≤—ã–π —á–µ–ª', '888', '–°–ø–µ—Ü–∏–∞–ª–∏—Å—Ç', '', '5/2', '8', '', '']
  ‚Ä¢ ['2@ya.ru', '–¢–µ—Å—Ç–æ–≤—ã–π –í–∞—Å—è', '111', '', '', '', '', '', '']
  ‚Ä¢ ['3@ya.ru', '—Ç—Ä–µ—Ç–∏–π —á–µ–ª', '3333', '', '', '', '', '', '']
--------------------------------------------------------------------------------
[SHEET] Groups
header: ['Group', 'Sheet', 'Statuses', '–í–æ–∑–º–æ–∂–Ω—ã–µ —Å—Ç–∞—Ç—É—Å—ã: "–í —Ä–∞–±–æ—Ç–µ",\n    "–ß–∞—Ç",\n    "–ê—É–¥–∏–æ",\n    "–ó–∞–ø–∏—Å—å",\n    "–ê–Ω–∫–µ—Ç—ã",\n    "–ü–µ—Ä–µ—Ä—ã–≤",\n    "–û–±–µ–¥",\n    "–¶–ò–¢–û",\n    "–û–±—É—á–µ–Ω–∏–µ" \n–£–∫–∞–∑—ã–≤–∞—Ç—å —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é, –±–µ–∑ –∫–æ–≤—ã—á–µ–∫']
rows_count (non-empty): 4
sample rows (first 3):
  ‚Ä¢ ['–í—Ö–æ–¥—è—â–∏–µ', 'WorkLog_–í—Ö–æ–¥—è—â–∏–µ', '–í —Ä–∞–±–æ—Ç–µ,–ß–∞—Ç,–ê—É–¥–∏–æ,–ü–µ—Ä–µ—Ä—ã–≤,–û–±–µ–¥,–¶–ò–¢–û', '']
  ‚Ä¢ ['–ó–∞–ø–∏—Å—å', 'WorkLog_–ó–∞–ø–∏—Å—å', '–í —Ä–∞–±–æ—Ç–µ,–ß–∞—Ç,–ê—É–¥–∏–æ,–ü–µ—Ä–µ—Ä—ã–≤,–û–±–µ–¥,–¶–ò–¢–û', '']
  ‚Ä¢ ['–°—Ç–æ–º–∞—Ç–æ–ª–æ–≥–∏—è', 'WorkLog_–°—Ç–æ–º–∞—Ç–æ–ª–æ–≥–∏—è', '–í —Ä–∞–±–æ—Ç–µ,–ß–∞—Ç,–ê—É–¥–∏–æ,–ü–µ—Ä–µ—Ä—ã–≤,–û–±–µ–¥,–¶–ò–¢–û', '']
--------------------------------------------------------------------------------
[SHEET] WorkLog_–ó–∞–ø–∏—Å—å
header: ['123@ya.ru', '—Ç–µ—Å—Ç –∑–∞–ø–∏—Å–∏', '–í —Ä–∞–±–æ—Ç–µ', 'LOGIN', '–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã', '2025-08-25T17:49:24.965579', '123@ya.r_20250825174924', '2025-08-25T17:49:24.965517']
rows_count (non-empty): 6
sample rows (first 3):
  ‚Ä¢ ['123@ya.ru', '—Ç–µ—Å—Ç –∑–∞–ø–∏—Å–∏', '–í —Ä–∞–±–æ—Ç–µ', 'LOGIN', '–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã', '2025-08-25T17:49:24.965579', '123@ya.r_20250825174924', '2025-08-25T17:49:24.965517', '', '']
  ‚Ä¢ ['123@ya.ru', '—Ç–µ—Å—Ç –∑–∞–ø–∏—Å–∏', '–í —Ä–∞–±–æ—Ç–µ', 'LOGIN', '–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã', '2025-08-25T17:49:24.965579', '123@ya.r_20250825174924', '2025-08-25T17:49:24.965517', '2025-08-25T17:49:56.465386', '']
  ‚Ä¢ ['123@ya.ru', '—Ç–µ—Å—Ç –∑–∞–ø–∏—Å–∏', '–ó–∞–≤–µ—Ä—à–µ–Ω–æ', 'LOGOUT', '–†–∞–∑–ª–æ–≥–∏–Ω–µ–Ω –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º (—É–¥–∞–ª—ë–Ω–Ω–æ)', '2025-08-25T17:49:56.505634', '123@ya.r_20250825174924', '2025-08-25T17:49:56.505530', '2025-08-25T17:49:56.505530', 'admin']
--------------------------------------------------------------------------------
[SHEET] WorkLog_–í—Ö–æ–¥—è—â–∏–µ
header: ['Email', 'Name', 'Status', 'ActionType', 'Comment', 'Timestamp', 'SessionID', 'StatusStartTime', 'StatusEndTime']
rows_count (non-empty): 27
sample rows (first 3):
  ‚Ä¢ ['7@ya.ru_20250823171203', '7@ya.ru', '–¢–µ—Å—Ç –ø–æ—á—Ç—ã', '–í —Ä–∞–±–æ—Ç–µ', 'LOGIN', '–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã', '2025-08-23T17:12:03.958642', '2025-08-23T17:12:03.958610', '2025-08-23T17:12:11.051848', '']
  ‚Ä¢ ['pid:dkuj4sai7negjt4x', 'PID-dkuj4s', '–í —Ä–∞–±–æ—Ç–µ', 'LOGIN', '–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã', '2025-08-27 14:41:46', 'pid:dkuj_20250827144146', '2025-08-27 17:41:46', '2025-08-27 14:41:52', '']
  ‚Ä¢ ['pid:dkuj4sai7negjt4x', 'PID-dkuj4s', '–í —Ä–∞–±–æ—Ç–µ', 'LOGIN', '–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã', '2025-08-27 14:41:46', 'pid:dkuj_20250827144146', '2025-08-27 17:41:46', '2025-08-27 14:57:43', '']
--------------------------------------------------------------------------------
[SHEET] ActiveSessions
header: ['Email', 'Name', 'SessionID', 'LoginTime', 'Status', 'LogoutTime', 'RemoteCommand']
rows_count (non-empty): 158
sample rows (first 3):
  ‚Ä¢ ['5@ya.ru', '–ì–æ–ª—É–±–µ–≤–∞ –Æ–ª–∏—è –í–∏–∫—Ç–æ—Ä–æ–≤–Ω–∞', '5@ya.ru_20250731150702', '2025-07-31T15:07:02', 'finished', '2025-08-15 14:38:22', '']
  ‚Ä¢ ['5@ya.ru', '–ì–æ–ª—É–±–µ–≤–∞ –Æ–ª–∏—è –í–∏–∫—Ç–æ—Ä–æ–≤–Ω–∞', '5@ya.ru_20250731152815', '2025-07-31T15:28:15', 'finished', '2025-07-31T15:28:49.376478', '']
  ‚Ä¢ ['5@ya.ru', '–ì–æ–ª—É–±–µ–≤–∞ –Æ–ª–∏—è –í–∏–∫—Ç–æ—Ä–æ–≤–Ω–∞', '5@ya.ru_20250731154231', '2025-07-31T15:42:31', 'finished', '2025-07-31T15:43:08.484935', '']
--------------------------------------------------------------------------------
[SHEET] WorkLog_–°—Ç–æ–º–∞—Ç–æ–ª–æ–≥–∏—è
header: ['10@ya.ru', '—Ç–µ—Å—Ç —Å—Ç–æ–º 3', '–í —Ä–∞–±–æ—Ç–µ', 'LOGIN', '–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã', '2025-09-01 16:05:14', '10@ya.ru_20250901160514', '2025-09-01 19:05:14', '2025-09-01 16:05:20']
rows_count (non-empty): 19
sample rows (first 3):
  ‚Ä¢ ['10@ya.ru', '—Ç–µ—Å—Ç —Å—Ç–æ–º 3', '–ß–∞—Ç', 'STATUS_CHANGE', '', '2025-09-01 16:05:31', '10@ya.ru_20250901160514', '2025-09-01 19:05:31', '2025-09-01 16:05:31']
  ‚Ä¢ ['10@ya.ru', '—Ç–µ—Å—Ç —Å—Ç–æ–º 3', '–í —Ä–∞–±–æ—Ç–µ', 'LOGIN', '–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã', '2025-09-01 16:05:14', '10@ya.ru_20250901160514', '2025-09-01 19:05:14', '2025-09-01 19:05:31']
  ‚Ä¢ ['10@ya.ru', '—Ç–µ—Å—Ç —Å—Ç–æ–º 3', '–í —Ä–∞–±–æ—Ç–µ', 'LOGIN', '–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã', '2025-09-01 16:48:28', '10@ya.ru_20250901164828', '2025-09-01 19:48:28', '2025-09-01 16:48:33']
--------------------------------------------------------------------------------
[SHEET] WorkLog_–ü–æ—á—Ç–∞
header: ['7@ya.ru', '–¢–µ—Å—Ç –ø–æ—á—Ç—ã', '–í —Ä–∞–±–æ—Ç–µ', 'LOGIN', '–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã', '2025-08-25T14:21:50.941225', '7@ya.ru_20250825142150', '2025-08-25T14:21:50.941160']
rows_count (non-empty): 18
sample rows (first 3):
  ‚Ä¢ ['7@ya.ru', '–¢–µ—Å—Ç –ø–æ—á—Ç—ã', '–í —Ä–∞–±–æ—Ç–µ', 'LOGIN', '–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã', '2025-08-25T14:21:50.941225', '7@ya.ru_20250825142150', '2025-08-25T14:21:50.941160', '2025-08-25T14:23:04.217964', '']
  ‚Ä¢ ['7@ya.ru', '–¢–µ—Å—Ç –ø–æ—á—Ç—ã', '–ß–∞—Ç', 'STATUS_CHANGE', '', '2025-08-25T14:23:04.223693', '7@ya.ru_20250825142150', '2025-08-25T14:23:04.217964', '', '']
  ‚Ä¢ ['7@ya.ru', '–¢–µ—Å—Ç –ø–æ—á—Ç—ã', '–ß–∞—Ç', 'STATUS_CHANGE', '', '2025-08-25T14:23:04.223693', '7@ya.ru_20250825142150', '2025-08-25T14:23:04.217964', '2025-08-25T14:25:21.425490', '']
--------------------------------------------------------------------------------
[SHEET] AccessControl
header: ['KeyType', 'KeyValue', 'AccessStatus', 'BlockUntil', 'Reason', 'UpdatedAt']
rows_count (non-empty): 0
================================================================================
PROJECT REPORT
Generated:   2025-09-02 17:14:32
Root:        C:\moy python\projects vs code\roma
Python:      3.13.5
Files:       43
================================================================================


--------------------------------------------------------------------------------
# FILE: .gitignore
# SIZE: 437 bytes | SHA256(text): 927018a20d479a444e2d7d6b4836885f02432e4616c8f83dfb3e523ef6051a83
--------------------------------------------------------------------------------
# Python
__pycache__/
*.pyc
*.pyo
*.pyd

# SQLite (–ª–æ–∫–∞–ª—å–Ω—ã–µ –ë–î)
*.db
*.db-shm
*.db-wal

# –õ–æ–≥–∏
*.log
logs/
*.bak

# –°–µ–∫—Ä–µ—Ç—ã –∏ –∫–ª—é—á–∏
.env
secret_creds.zip

# PyInstaller
*.spec
dist/
build/
*.exe
*.dll

# IDE/Editor
.vscode/
.idea/
.DS_Store

# GCP creds ‚Äî –∑–∞–ø—Ä–µ—â–µ–Ω–æ —Ö—Ä–∞–Ω–∏—Ç—å –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏
credentials/*.json
*.secret.json
service_account.json

--------------------------------------------------------------------------------
# FILE: __init__.py
# SIZE: 343 bytes | SHA256(text): 423245e097df4d9c26b80058efa8bc9635eddc1ac1b1a2482e90816d7b154ca6
--------------------------------------------------------------------------------
# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–∞–∫–µ—Ç–∞ user_app
from .version import __version__

__all__ = [
    'main',
    'gui', 
    'login_window',
    'db_local',
    'sheets_api',
    'sync'
]

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—É—Ç–µ–π
import os
import sys

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

--------------------------------------------------------------------------------
# FILE: admin_app\gui_admin.py
# SIZE: 0 bytes | SHA256(text): e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
# FILE: admin_app\main_admin.py
# SIZE: 21626 bytes | SHA256(text): df255496219eed226297ec882cfe813e8cf046f5e231999a37080a23114343a7
--------------------------------------------------------------------------------
# admin_app/main_admin.py
from __future__ import annotations

import sys
import logging
import time
from pathlib import Path
from typing import Optional, Dict, List, Tuple

from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit,
    QPushButton, QTableWidget, QTableWidgetItem, QCheckBox, QComboBox, QMessageBox,
    QTabWidget, QGroupBox
)

# --- –ï–¥–∏–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –∞–¥–º–∏–Ω–∫–∏ ---
from logging_setup import setup_logging
from config import LOG_DIR

# --- –î–æ–º–µ–Ω–Ω–∞—è –ª–æ–≥–∏–∫–∞/—Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π ---
from admin_app.repo import AdminRepo

# =================== –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã UI ===================
FIELDS = ["Email", "Name", "Phone", "Role", "Telegram", "Group", "NotifyTelegram"]
ROLES = ["—Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç", "—Å—Ç–∞—Ä—à–∏–π —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç", "–≤–µ–¥—É—â–∏–π —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç", "—Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å –≥—Ä—É–ø–ø—ã"]

# –ó–∞–≥—Ä—É–∑–∫–∞ GROUP_MAPPING —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫
try:
    # —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∞—è –∫–∞—Ä—Ç–∞ –≥—Ä—É–ø–ø, –µ—Å–ª–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –≤ config.py
    from config import GROUP_MAPPING
except Exception:
    GROUP_MAPPING = {}

# =================== –î–∏–∞–ª–æ–≥ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ===================
from PyQt5.QtWidgets import QDialog

class UserDialog(QDialog):
    def __init__(self, parent=None, user: Optional[Dict[str, str]] = None, groups: List[str] = None):
        super().__init__(parent)
        self.setWindowTitle("–ö–∞—Ä—Ç–æ—á–∫–∞ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞")
        self.user = user or {}
        self.groups = groups or []
        self._build()

    def _build(self):
        layout = QVBoxLayout(self)

        self.email_input = QLineEdit(str(self.user.get("Email", "")))
        self.fio_input = QLineEdit(str(self.user.get("Name", "")))
        self.phone_input = QLineEdit(str(self.user.get("Phone", "")))
        self.tg_input = QLineEdit(str(self.user.get("Telegram", "")))

        self.role_combo = QComboBox()
        self.role_combo.addItems(ROLES)
        role_val = str(self.user.get("Role", "")).strip()
        if role_val in ROLES:
            self.role_combo.setCurrentText(role_val)

        self.group_combo = QComboBox()
        self.group_combo.addItems(self.groups)
        group_val = str(self.user.get("Group", "")).strip()
        if group_val in self.groups:
            self.group_combo.setCurrentText(group_val)

        self.tg_notify_chk = QCheckBox("–û—Ç–ø—Ä–∞–≤–ª—è—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ Telegram")
        chk = str(self.user.get("NotifyTelegram", "")).strip().lower()
        self.tg_notify_chk.setChecked(chk in ("yes", "true", "1", "–¥–∞"))

        layout.addWidget(QLabel("Email:"))
        layout.addWidget(self.email_input)
        layout.addWidget(QLabel("–§–ò–û:"))
        layout.addWidget(self.fio_input)
        layout.addWidget(QLabel("–¢–µ–ª–µ—Ñ–æ–Ω:"))
        layout.addWidget(self.phone_input)
        layout.addWidget(QLabel("Telegram:"))
        layout.addWidget(self.tg_input)
        layout.addWidget(QLabel("–î–æ–ª–∂–Ω–æ—Å—Ç—å:"))
        layout.addWidget(self.role_combo)
        layout.addWidget(QLabel("–ì—Ä—É–ø–ø–∞:"))
        layout.addWidget(self.group_combo)
        layout.addWidget(self.tg_notify_chk)

        btns = QHBoxLayout()
        btn_save = QPushButton("–°–æ—Ö—Ä–∞–Ω–∏—Ç—å")
        btn_save.clicked.connect(self.accept)
        btn_cancel = QPushButton("–û—Ç–º–µ–Ω–∞")
        btn_cancel.clicked.connect(self.reject)
        btns.addWidget(btn_save)
        btns.addWidget(btn_cancel)
        layout.addLayout(btns)

    def get_user(self) -> Dict[str, str]:
        return {
            "Email": self.email_input.text().strip().lower(),
            "Name": self.fio_input.text().strip(),
            "Phone": self.phone_input.text().strip(),
            "Role": self.role_combo.currentText().strip(),
            "Telegram": self.tg_input.text().strip(),
            "Group": self.group_combo.currentText().strip(),
            "NotifyTelegram": "Yes" if self.tg_notify_chk.isChecked() else "No",
        }

# =================== –ì–ª–∞–≤–Ω–æ–µ –æ–∫–Ω–æ ===================

class AdminWindow(QMainWindow):
    def __init__(self, groups: List[str]):
        super().__init__()
        self.setWindowTitle("–ê–¥–º–∏–Ω–∫–∞ WorkTimeTracker")
        self.resize(1400, 780)
        
        # –ì—Ä—É–ø–ø—ã
        self.groups = groups

        # –†–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π
        self.repo = AdminRepo()

        # –ö—ç—à –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏ –∞–∫—Ç–∏–≤–Ω—ã—Ö e-mail
        self.users: List[Dict[str, str]] = []
        self._active_cache: Tuple[float, set[str]] = (0.0, set())  # (ts, {emails})
        self._active_ttl_sec = 30.0

        self._build_ui()
        self.refresh_users()
        self.load_shift_calendar()

    # ---------- UI ----------
    def _build_ui(self):
        self.tabs = QTabWidget(self)

        # --- –í–∫–ª–∞–¥–∫–∞ "–°–æ—Ç—Ä—É–¥–Ω–∏–∫–∏" ---
        self.tab_users = QWidget()
        users_layout = QVBoxLayout(self.tab_users)

        # –§–∏–ª—å—Ç—Ä—ã
        filter_layout = QHBoxLayout()
        filter_layout.addWidget(QLabel("–ì—Ä—É–ø–ø–∞:"))
        self.group_filter_combo = QComboBox()
        self.group_filter_combo.addItem("–í—Å–µ –≥—Ä—É–ø–ø—ã")
        self.group_filter_combo.addItems(self.groups)
        self.group_filter_combo.currentIndexChanged.connect(self.apply_user_search)
        filter_layout.addWidget(self.group_filter_combo)

        self.only_active_chk = QCheckBox("–¢–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ")
        self.only_active_chk.stateChanged.connect(self.apply_user_search)
        filter_layout.addWidget(self.only_active_chk)

        filter_layout.addStretch()
        users_layout.addLayout(filter_layout)

        # –ü–æ–∏—Å–∫ –∏ –∫–Ω–æ–ø–∫–∏
        top_layout = QHBoxLayout()
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("–ü–æ–∏—Å–∫ –ø–æ –§–ò–û –∏–ª–∏ email")
        self.search_input.textChanged.connect(self.apply_user_search)
        top_layout.addWidget(self.search_input)

        btn_add = QPushButton("–î–æ–±–∞–≤–∏—Ç—å")
        btn_add.clicked.connect(self.add_user)
        btn_edit = QPushButton("–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å")
        btn_edit.clicked.connect(self.edit_user)
        btn_delete = QPushButton("–£–¥–∞–ª–∏—Ç—å")
        btn_delete.clicked.connect(self.on_delete_user_clicked)
        btn_kick = QPushButton("–†–∞–∑–ª–æ–≥–∏–Ω–∏—Ç—å")
        btn_kick.clicked.connect(self.on_force_logout_clicked)

        for b in (btn_add, btn_edit, btn_delete, btn_kick):
            top_layout.addWidget(b)
        users_layout.addLayout(top_layout)

        # –¢–∞–±–ª–∏—Ü–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        self.users_table = QTableWidget(0, len(FIELDS))
        self.users_table.setHorizontalHeaderLabels(
            ["Email", "–§–ò–û", "–¢–µ–ª–µ—Ñ–æ–Ω", "–î–æ–ª–∂–Ω–æ—Å—Ç—å", "Telegram", "–ì—Ä—É–ø–ø–∞", "Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è"]
        )
        self.users_table.setSelectionBehavior(QTableWidget.SelectRows)
        users_layout.addWidget(self.users_table)

        self.tabs.addTab(self.tab_users, "–°–æ—Ç—Ä—É–¥–Ω–∏–∫–∏")

        # --- –í–∫–ª–∞–¥–∫–∞ "–ì—Ä–∞—Ñ–∏–∫" ---
        self.tab_schedule = QWidget()
        schedule_layout = QVBoxLayout(self.tab_schedule)

        header_layout = QHBoxLayout()
        header_layout.addWidget(QLabel("–°–æ—Ç—Ä—É–¥–Ω–∏–∫:"))
        self.schedule_user_combo = QComboBox()
        self.schedule_user_combo.addItem("–í—ã–±–µ—Ä–∏—Ç–µ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞")
        self.schedule_user_combo.currentIndexChanged.connect(self.on_schedule_user_change)
        header_layout.addWidget(self.schedule_user_combo)
        header_layout.addStretch()
        schedule_layout.addLayout(header_layout)

        self.info_group = QGroupBox("–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–µ")
        info_layout = QVBoxLayout()
        self.login_status_lbl = QLabel("–ó–∞–ª–æ–≥–∏–Ω–µ–Ω: –ù–µ—Ç")
        self.btn_force_logout = QPushButton("–†–∞–∑–ª–æ–≥–∏–Ω–∏—Ç—å")
        self.btn_force_logout.setEnabled(False)
        self.btn_force_logout.clicked.connect(self.force_logout_from_schedule)
        status_row = QHBoxLayout()
        status_row.addWidget(self.login_status_lbl)
        status_row.addWidget(self.btn_force_logout)
        status_row.addStretch()
        info_layout.addLayout(status_row)

        self.info_label = QLabel("")
        self.info_label.setWordWrap(True)
        info_layout.addWidget(self.info_label)
        self.info_group.setLayout(info_layout)
        schedule_layout.addWidget(self.info_group)

        self.schedule_table = QTableWidget()
        schedule_layout.addWidget(self.schedule_table)

        self.tabs.addTab(self.tab_schedule, "–ì—Ä–∞—Ñ–∏–∫")

        # --- –í–∫–ª–∞–¥–∫–∞ "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ" (–ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä) ---
        self.tab_extra = QWidget()
        extra_layout = QVBoxLayout(self.tab_extra)
        extra_layout.addWidget(QLabel("–¢—É—Ç –±—É–¥–µ—Ç —á—Ç–æ-—Ç–æ –µ—â—ë"))
        self.tabs.addTab(self.tab_extra, "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ")

        self.setCentralWidget(self.tabs)

    # ---------- Helpers ----------
    def _selected_email(self) -> Optional[str]:
        items = self.users_table.selectedItems()
        if not items:
            return None
        val = items[0].text().strip()
        return val[2:] if val.startswith("üü¢ ") else val

    def _confirm(self, msg: str) -> bool:
        return QMessageBox.question(self, "–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ", msg, QMessageBox.Yes | QMessageBox.No, QMessageBox.No) == QMessageBox.Yes

    def _info(self, msg: str):
        QMessageBox.information(self, "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è", msg)

    def _warn(self, msg: str):
        QMessageBox.warning(self, "–û—à–∏–±–∫–∞", msg)

    # ---------- –ê–∫—Ç–∏–≤–Ω—ã–µ —Å–µ—Å—Å–∏–∏ (–∫—ç—à) ----------
    def _get_active_emails_cached(self) -> set[str]:
        ts, emails = self._active_cache
        if time.monotonic() - ts < self._active_ttl_sec:
            return emails
        try:
            sessions = self.repo.get_active_sessions()
            emails = {str(s.get("Email", "")).strip().lower() for s in sessions if str(s.get("Status", "")).strip().lower() == "active"}
            self._active_cache = (time.monotonic(), emails)
            return emails
        except Exception as e:
            logger.warning("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–µ —Å–µ—Å—Å–∏–∏: %s", e)
            return set()

    # =================== –¢–∞–± "–°–æ—Ç—Ä—É–¥–Ω–∏–∫–∏" ===================

    def refresh_users(self):
        try:
            rows = self.repo.list_users()
        except Exception as e:
            logger.exception("refresh_users failed: %s", e)
            rows = []

        self.users = []
        for r in rows:
            nt = str(r.get("NotifyTelegram", "")).strip().lower()
            nt_norm = "Yes" if nt in ("yes", "true", "1", "–¥–∞") else "No"
            self.users.append({
                "Email": str(r.get("Email", "")),
                "Name": str(r.get("Name", "")),
                "Phone": str(r.get("Phone", "")),
                "Role": str(r.get("Role", "")),
                "Telegram": str(r.get("Telegram", "")),
                "Group": str(r.get("Group", "")),
                "NotifyTelegram": nt_norm,
            })

        # –∑–∞–ø–æ–ª–Ω—è–µ–º —Ç–∞–±–ª–∏—Ü—É
        self.refresh_users_table()

        # –∏ –≤—ã–ø–∞–¥–∞—é—â–∏–π —Å–ø–∏—Å–æ–∫ –Ω–∞ –≤–∫–ª–∞–¥–∫–µ "–ì—Ä–∞—Ñ–∏–∫"
        self.schedule_user_combo.blockSignals(True)
        self.schedule_user_combo.clear()
        self.schedule_user_combo.addItem("–í—ã–±–µ—Ä–∏—Ç–µ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞")
        for u in self.users:
            fio = u.get("Name", "")
            if fio:
                self.schedule_user_combo.addItem(fio)
        self.schedule_user_combo.blockSignals(False)

    def refresh_users_table(self, filter_text: str = ""):
        self.users_table.setRowCount(0)
        selected_group = self.group_filter_combo.currentText()
        only_active = self.only_active_chk.isChecked()
        active_emails = self._get_active_emails_cached() if only_active else set()

        for u in self.users:
            email = u.get("Email", "").strip().lower()
            group = u.get("Group", "").strip()
            is_active = email in active_emails

            # –ø–æ–∏—Å–∫
            if filter_text:
                q = filter_text.lower()
                if q not in email and q not in u.get("Name", "").lower():
                    continue
            # —Ñ–∏–ª—å—Ç—Ä –ø–æ –≥—Ä—É–ø–ø–µ
            if selected_group != "–í—Å–µ –≥—Ä—É–ø–ø—ã" and group != selected_group:
                continue
            # —Ñ–∏–ª—å—Ç—Ä –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
            if only_active and not is_active:
                continue

            row = self.users_table.rowCount()
            self.users_table.insertRow(row)
            for col, key in enumerate(FIELDS):
                val = u.get(key, "")
                if key == "Email" and is_active:
                    val = f"üü¢ {val}"
                item = QTableWidgetItem(str(val))
                item.setFlags(Qt.ItemIsEnabled | Qt.ItemIsSelectable)
                self.users_table.setItem(row, col, item)

    def apply_user_search(self):
        self.refresh_users_table(self.search_input.text())

    # --- CRUD/Actions ---

    def add_user(self):
        dlg = UserDialog(self, groups=self.groups)
        if dlg.exec_():
            data = dlg.get_user()
            if self.repo.add_or_update_user(data):
                self._info("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–æ–±–∞–≤–ª–µ–Ω")
                self.refresh_users()
            else:
                self._warn("–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")

    def edit_user(self):
        row = self.users_table.currentRow()
        if row < 0 or row >= len(self.users):
            self._warn("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ —Å—Ç—Ä–æ–∫—É –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.")
            return
        user = self.users[row]
        dlg = UserDialog(self, user=user, groups=self.groups)
        if dlg.exec_():
            data = dlg.get_user()
            if self.repo.add_or_update_user(data):
                self._info("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ–±–Ω–æ–≤–ª—ë–Ω")
                self.refresh_users()
            else:
                self._warn("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")

    def on_delete_user_clicked(self):
        email = self._selected_email()
        if not email:
            self._warn("–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
            return
        if not self._confirm(f"–£–¥–∞–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {email}?"):
            return
        if self.repo.delete_user(email):
            self._info("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–¥–∞–ª—ë–Ω")
            self.refresh_users()
        else:
            self._warn("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ —É–¥–∞–ª—ë–Ω")

    def on_force_logout_clicked(self):
        email = self._selected_email()
        if not email:
            self._warn("–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ —Å–ø–∏—Å–∫–∞.")
            return

        # –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º –§–ò–û –¥–ª—è –∫—Ä–∞—Å–æ—Ç—ã
        fio = ""
        sel = self.users_table.selectedItems()
        if sel and len(sel) > 1:
            fio = sel[1].text()

        if not self._confirm(f"–†–∞–∑–ª–æ–≥–∏–Ω–∏—Ç—å {fio or email}?"):
            return

        if self.repo.force_logout(email=email):
            self._info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {fio or email} –±—ã–ª —Ä–∞–∑–ª–æ–≥–∏–Ω–µ–Ω.")
            # —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –∫—ç—à –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–µ–π, —á—Ç–æ–±—ã —Ç–∞–±–ª–∏—Ü–∞ –æ–±–Ω–æ–≤–∏–ª–∞—Å—å –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
            self._active_cache = (0.0, set())
            self.refresh_users()
        else:
            self._warn("–ê–∫—Ç–∏–≤–Ω–∞—è —Å–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")

    # =================== –¢–∞–± "–ì—Ä–∞—Ñ–∏–∫" ===================

    def load_shift_calendar(self):
        """–ü–æ–¥—Ç—è–≥–∏–≤–∞–µ–º —Ç–∞–±–ª–∏—Ü—É –≥—Ä–∞—Ñ–∏–∫–∞. –ï—Å–ª–∏ –µ—ë –Ω–µ—Ç ‚Äî –æ—Ç–∫–ª—é—á–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã."""
        try:
            data = self.repo.get_shift_calendar()
        except Exception as e:
            logger.exception("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –≥—Ä–∞—Ñ–∏–∫–∞: %s", e)
            data = []

        self.shift_calendar_data: List[List[str]] = data
        self.shift_headers: List[str] = data[0] if data else []

        if not data:
            self.info_label.setText("–õ–∏—Å—Ç –≥—Ä–∞—Ñ–∏–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –ø—É—Å—Ç.")
            self.login_status_lbl.setText("–ó–∞–ª–æ–≥–∏–Ω–µ–Ω: –ù–µ—Ç")
            self.btn_force_logout.setEnabled(False)
            self.schedule_table.setRowCount(0)
            self.schedule_table.setColumnCount(0)
            self.schedule_user_combo.setEnabled(bool(self.users))
            return

        self.schedule_user_combo.setEnabled(True)

    def on_schedule_user_change(self):
        idx = self.schedule_user_combo.currentIndex()
        if idx <= 0 or not self.shift_calendar_data:
            self.schedule_table.setRowCount(0)
            self.schedule_table.setColumnCount(0)
            self.info_label.setText("")
            self.login_status_lbl.setText("–ó–∞–ª–æ–≥–∏–Ω–µ–Ω: –ù–µ—Ç")
            self.btn_force_logout.setEnabled(False)
            return

        fio = self.schedule_user_combo.currentText()
        email = ""
        for u in self.users:
            if u.get("Name", "") == fio:
                email = u.get("Email", "")
                break

        # —Å—Ç–∞—Ç—É—Å –ª–æ–≥–∏–Ω–∞
        active = self._get_active_emails_cached()
        is_logged_in = email.strip().lower() in active
        self.login_status_lbl.setText(f"–ó–∞–ª–æ–≥–∏–Ω–µ–Ω: {'–î–∞' if is_logged_in else '–ù–µ—Ç'}")
        self.btn_force_logout.setEnabled(is_logged_in)
        self.btn_force_logout.setProperty("user_email", email)
        self.btn_force_logout.setProperty("user_fio", fio)

        # –∏–Ω—Ñ–æ –ø–æ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫—É
        info_parts = [f"<b>–§–ò–û:</b> {fio}", f"<b>Email:</b> {email}"]
        self.info_label.setText("<br>".join(info_parts))

        # —Ç–∞–±–µ–ª—å –ø–æ –¥–Ω—è–º (–∏—â–µ–º –ø–µ—Ä–≤—ã–µ —á–∏—Å–ª–æ–≤—ã–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏ –∫–∞–∫ –¥–Ω–∏ –º–µ—Å—è—Ü–∞)
        headers = self.shift_headers
        row_for_user: Optional[List[str]] = None
        for r in self.shift_calendar_data[1:]:
            if r and r[0].strip() == fio:
                row_for_user = r
                break

        day_indices = [(i, h) for i, h in enumerate(headers) if str(h).isdigit()]
        self.schedule_table.setRowCount(0)
        self.schedule_table.setColumnCount(len(day_indices))
        self.schedule_table.setHorizontalHeaderLabels([str(h) for _, h in day_indices])

        if row_for_user:
            self.schedule_table.setRowCount(1)
            for col, (i, _) in enumerate(day_indices):
                val = row_for_user[i] if i < len(row_for_user) else ""
                self.schedule_table.setItem(0, col, QTableWidgetItem(str(val)))
            self.schedule_table.resizeColumnsToContents()

    def force_logout_from_schedule(self):
        email = self.btn_force_logout.property("user_email")
        fio = self.btn_force_logout.property("user_fio")
        if not email:
            self._warn("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å Email –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.")
            return
        if not self._confirm(f"–†–∞–∑–ª–æ–≥–∏–Ω–∏—Ç—å {fio or email}?"):
            return

        if self.repo.force_logout(email=email):
            self._info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {fio or email} —Ä–∞–∑–ª–æ–≥–∏–Ω–µ–Ω.")
            self.btn_force_logout.setEnabled(False)
            self.login_status_lbl.setText("–ó–∞–ª–æ–≥–∏–Ω–µ–Ω: –ù–µ—Ç")
            # —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –∫—ç—à –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–µ–π
            self._active_cache = (0.0, set())
            self.refresh_users()
        else:
            self._warn("–ê–∫—Ç–∏–≤–Ω–∞—è —Å–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")

# =================== –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ ===================

def get_available_groups(repo: AdminRepo) -> list[str]:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –≥—Ä—É–ø–ø"""
    if GROUP_MAPPING:
        return sorted(set(GROUP_MAPPING.values()))
    return repo.list_groups_from_sheet()

# =================== Entrypoint ===================

def main():
    # –ï–¥–∏–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –∞–¥–º–∏–Ω–∫–∏
    log_path = setup_logging(app_name="wtt-admin", log_dir=LOG_DIR)
    logger = logging.getLogger(__name__)
    logger.info("Admin app logging initialized (path=%s)", log_path)
    
    # –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –≥—Ä—É–ø–ø
    repo = AdminRepo()
    groups = get_available_groups(repo)
    logger.info("Groups: %s", ", ".join(groups) if groups else "<none>")
    
    # –ó–∞–ø—É—Å–∫ GUI —Å –ø–µ—Ä–µ–¥–∞—á–µ–π —Å–ø–∏—Å–∫–∞ –≥—Ä—É–ø–ø
    app = QApplication(sys.argv)
    win = AdminWindow(groups=groups)
    win.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()

--------------------------------------------------------------------------------
# FILE: admin_app\repo.py
# SIZE: 8954 bytes | SHA256(text): 4a8ef84d5b996624f84258294e093fd05e5cc30c7b2ab55b47d86761e409c0ed
--------------------------------------------------------------------------------
# admin_app/repo.py
from __future__ import annotations

import logging
from typing import List, Dict, Optional
from datetime import datetime, timezone

from sheets_api import SheetsAPI, SheetsAPIError
from config import (
    GOOGLE_SHEET_NAME,
    USERS_SHEET,
    ACTIVE_SESSIONS_SHEET,
)

logger = logging.getLogger(__name__)

# –í–æ–∑–º–æ–∂–Ω—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è –ª–∏—Å—Ç–∞ —Å –≥—Ä–∞—Ñ–∏–∫–æ–º (–ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—É)
CANDIDATE_SCHEDULE_TITLES = ["ShiftCalendar", "Schedule", "–ì—Ä–∞—Ñ–∏–∫"]


class AdminRepo:
    """
    –†–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π.
    –í—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –∏–¥—É—Ç —á–µ—Ä–µ–∑ —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π SheetsAPI (—Ä–µ—Ç—Ä–∞–∏/–∫–≤–æ—Ç—ã/–ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ).
    """

    def __init__(self, sheets: Optional[SheetsAPI] = None):
        self.sheets = sheets or SheetsAPI()

    # -------------------------------------------------------------------------
    # Users
    # -------------------------------------------------------------------------
    def list_users(self) -> List[Dict[str, str]]:
        """
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∫–∞–∫ —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤–∞—Ä–µ–π (–∫–æ–ª–æ–Ω–∫–∏ –ø–æ –∑–∞–≥–æ–ª–æ–≤–∫—É –ª–∏—Å—Ç–∞ Users).
        """
        try:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤—ã—Å–æ–∫–æ—É—Ä–æ–≤–Ω–µ–≤—ã–π –º–µ—Ç–æ–¥ SheetsAPI, —á—Ç–æ–±—ã –Ω–µ –¥—É–±–ª–∏—Ä–æ–≤–∞—Ç—å –ª–æ–≥–∏–∫—É
            users = self.sheets.get_users()  # type: ignore[attr-defined]
            return users or []
        except AttributeError:
            # –§–æ–ª–±—ç–∫, –µ—Å–ª–∏ –≤–¥—Ä—É–≥ –Ω–µ—Ç get_users() (—Å—Ç–∞—Ä—ã–π SheetsAPI)
            ws = self.sheets.get_worksheet(USERS_SHEET)
            values = self.sheets._request_with_retry(ws.get_all_values)
            if not values:
                return []
            header = values[0]
            out: List[Dict[str, str]] = []
            for row in values[1:]:
                if any((c or "").strip() for c in row):
                    out.append({header[i]: (row[i] if i < len(header) else "") for i in range(len(header))})
            return out
        except Exception as e:
            logger.exception("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: %s", e)
            return []

    def add_or_update_user(self, user: Dict[str, str]) -> bool:
        """
        –î–æ–±–∞–≤–ª—è–µ—Ç –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–ø–æ Email).
        """
        try:
            self.sheets.upsert_user(user)  # type: ignore[attr-defined]
            return True
        except AttributeError:
            # –§–æ–ª–±—ç–∫ –Ω–∞ —Å—Ç–∞—Ä—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å ‚Äî –ø—Ä–æ–±—É–µ–º –æ–±–Ω–æ–≤–∏—Ç—å –Ω–∞–±–æ—Ä –ø–æ–ª–µ–π
            try:
                email = user.get("Email") or user.get("email")
                if not email:
                    raise ValueError("user.Email is required")
                fields = {k: v for k, v in user.items() if k != "Email"}
                self.sheets.update_user_fields(email=email, fields=fields)  # type: ignore[attr-defined]
                return True
            except Exception as e:
                logger.exception("Fallback upsert_user failed: %s", e)
                return False
        except Exception as e:
            logger.exception("add_or_update_user error: %s", e)
            return False

    def delete_user(self, email: str) -> bool:
        """
        –£–¥–∞–ª—è–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ Email.
        """
        try:
            return bool(self.sheets.delete_user(email))  # type: ignore[attr-defined]
        except Exception as e:
            logger.exception("delete_user error for %s: %s", email, e)
            return False

    # -------------------------------------------------------------------------
    # Groups
    # -------------------------------------------------------------------------
    def list_groups_from_sheet(self) -> list[str]:
        """
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –≥—Ä—É–ø–ø –∏–∑ –ª–∏—Å—Ç–∞ 'Groups' (–∫–æ–ª–æ–Ω–∫–∞ 'Group').
        –ü—É—Å—Ç—ã–µ/–¥—É–±–ª–∏–∫–∞—Ç—ã —Ñ–∏–ª—å—Ç—Ä—É—é—Ç—Å—è.
        """
        try:
            ws = self.sheets.get_worksheet("Groups")
            values = self.sheets._request_with_retry(ws.get_all_values)
            groups = []
            for row in values[1:]:  # –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫
                if not row:
                    continue
                g = (row[0] or "").strip()
                if g:
                    groups.append(g)
            return sorted(set(groups))
        except Exception as e:
            logger.warning("list_groups_from_sheet failed: %s", e)
            return []

    # -------------------------------------------------------------------------
    # Active sessions
    # -------------------------------------------------------------------------
    def get_active_sessions(self) -> List[Dict]:
        """
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Å–µ –∑–∞–ø–∏—Å–∏ –ª–∏—Å—Ç–∞ ActiveSessions (—Å–ª–æ–≤–∞—Ä–∏ –∫–æ–ª–æ–Ω–æ–∫).
        """
        try:
            sessions = self.sheets.get_all_active_sessions()  # type: ignore[attr-defined]
            return sessions or []
        except Exception as e:
            logger.exception("get_active_sessions error: %s", e)
            return []

    def force_logout(self, email: str) -> bool:
        """
        –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∑–∞–≤–µ—Ä—à–∞–µ—Ç –ü–û–°–õ–ï–î–ù–Æ–Æ –∞–∫—Ç–∏–≤–Ω—É—é —Å–µ—Å—Å–∏—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç True, –µ—Å–ª–∏ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å —Å—Ç—Ä–æ–∫—É.
        """
        try:
            ok = self.sheets.kick_active_session(email=email)  # type: ignore[attr-defined]
            if ok:
                logger.info("Force logout success for %s", email)
            else:
                logger.info("Force logout: –∞–∫—Ç–∏–≤–Ω–∞—è —Å–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –¥–ª—è %s", email)
            return bool(ok)
        except Exception as e:
            logger.exception("force_logout error for %s: %s", email, e)
            return False

    # -------------------------------------------------------------------------
    # Schedule (Shift calendar)
    # -------------------------------------------------------------------------
    def _list_titles(self) -> List[str]:
        """
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –Ω–∞–∑–≤–∞–Ω–∏–π –ª–∏—Å—Ç–æ–≤ –∫–Ω–∏–≥–∏.
        """
        try:
            if hasattr(self.sheets, "list_worksheet_titles"):
                return list(self.sheets.list_worksheet_titles())  # type: ignore[attr-defined]
        except Exception:
            pass

        # –§–æ–ª–±—ç–∫ —á–µ—Ä–µ–∑ –æ—Ç–∫—Ä—ã—Ç—É—é –∫–Ω–∏–≥—É
        try:
            spreadsheet = self.sheets._request_with_retry(self.sheets.client.open, GOOGLE_SHEET_NAME)
            worksheets = self.sheets._request_with_retry(spreadsheet.worksheets)
            return [ws.title for ws in worksheets]
        except Exception as e:
            logger.warning("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ª–∏—Å—Ç–æ–≤: %s", e)
            return []

    def _pick_schedule_title(self, titles: List[str]) -> Optional[str]:
        """
        –í—ã–±–∏—Ä–∞–µ—Ç –Ω–∞–∑–≤–∞–Ω–∏–µ –ª–∏—Å—Ç–∞ –≥—Ä–∞—Ñ–∏–∫–∞ –∏–∑ –∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤.
        """
        available = set(titles)
        for cand in CANDIDATE_SCHEDULE_TITLES:
            if cand in available:
                return cand
        return None

    def get_shift_calendar(self) -> List[List[str]]:
        """
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–∞–±–ª–∏—Ü—É –≥—Ä–∞—Ñ–∏–∫–∞ –∫–∞–∫ —Å–ø–∏—Å–æ–∫ —Å–ø–∏—Å–∫–æ–≤:
        [ [header...], [row1...], ... ]. –ï—Å–ª–∏ –ª–∏—Å—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç ‚Äî [].
        """
        try:
            titles = self._list_titles()
            if not titles:
                logger.info("–í –∫–Ω–∏–≥–µ '%s' –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –ª–∏—Å—Ç–æ–≤.", GOOGLE_SHEET_NAME)
                return []

            name = self._pick_schedule_title(titles)
            if not name:
                logger.info(
                    "–õ–∏—Å—Ç –≥—Ä–∞—Ñ–∏–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω. –û–∂–∏–¥–∞–ª–∏—Å—å: %s; –µ—Å—Ç—å: %s",
                    ", ".join(CANDIDATE_SCHEDULE_TITLES),
                    ", ".join(titles),
                )
                return []

            ws = self.sheets.get_worksheet(name)
            values = self.sheets._request_with_retry(ws.get_all_values)
            return values or []
        except SheetsAPIError as e:
            logger.warning("–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –ª–∏—Å—Ç—É –≥—Ä–∞—Ñ–∏–∫–∞: %s", e)
            return []
        except Exception as e:
            logger.exception("get_shift_calendar error: %s", e)
            return []

--------------------------------------------------------------------------------
# FILE: admin_app\schedule_parser.py
# SIZE: 4599 bytes | SHA256(text): 5f71b0fd877ad4c30a0ff770ef0ca2e0c748c080591488fa53c0ca65c9fb27c6
--------------------------------------------------------------------------------
# admin_app/schedule_parser.py
"""
DEPRECATED: –ø–æ–º–æ–≥–∞–µ—Ç —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å, –Ω–æ –Ω–µ –¥–æ–ª–∂–µ–Ω –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –≤ –Ω–æ–≤–æ–º –∫–æ–¥–µ.
–¢–µ–ø–µ—Ä—å –≥—Ä–∞—Ñ–∏–∫ —á–∏—Ç–∞–µ—Ç—Å—è —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ —á–µ—Ä–µ–∑ SheetsAPI / AdminRepo.get_shift_calendar().

–ï—Å–ª–∏ –º–æ–¥—É–ª—å –≤—Å—ë –µ—â—ë –∏–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è —Å—Ç–∞—Ä—ã–º–∏ —É—á–∞—Å—Ç–∫–∞–º–∏ –∫–æ–¥–∞, —Ñ—É–Ω–∫—Ü–∏–∏ –Ω–∏–∂–µ –¥–µ–ª–µ–≥–∏—Ä—É—é—Ç —á—Ç–µ–Ω–∏–µ
–≤ Google Sheets —á–µ—Ä–µ–∑ SheetsAPI (–±–µ–∑ pandas/requests –∏ –±–µ–∑ –ø—Ä—è–º—ã—Ö gspread-–≤—ã–∑–æ–≤–æ–≤).
"""

from __future__ import annotations
from typing import List, Optional
import logging
from pathlib import Path
import sys

# –î–æ–±–∞–≤–ª—è–µ–º –∫–æ—Ä–µ–Ω—å –ø—Ä–æ–µ–∫—Ç–∞ –≤ sys.path, —á—Ç–æ–±—ã –±—ã–ª–∏ –¥–æ—Å—Ç—É–ø–Ω—ã config –∏ sheets_api –ø—Ä–∏ –ø—Ä—è–º–æ–º –∑–∞–ø—É—Å–∫–µ
ROOT_PATH = str(Path(__file__).parent.parent.resolve())
if ROOT_PATH not in sys.path:
    sys.path.insert(0, ROOT_PATH)

from sheets_api import SheetsAPI, SheetsAPIError  # —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π —Å–ª–æ–π
from config import GOOGLE_SHEET_NAME  # —Ç–æ–ª—å–∫–æ –¥–ª—è —Å–æ–æ–±—â–µ–Ω–∏–π

logger = logging.getLogger(__name__)
if not logger.hasHandlers():
    logging.basicConfig(level=logging.INFO)

# –í–æ–∑–º–æ–∂–Ω—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è –ª–∏—Å—Ç–∞ —Å –≥—Ä–∞—Ñ–∏–∫–æ–º (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –ø–æ –ø–æ—Ä—è–¥–∫—É)
CANDIDATE_SCHEDULE_TITLES = ["ShiftCalendar", "Schedule", "–ì—Ä–∞—Ñ–∏–∫"]


def _list_titles(sheets: SheetsAPI) -> List[str]:
    """–ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –Ω–∞–∑–≤–∞–Ω–∏–π –ª–∏—Å—Ç–æ–≤ —á–µ—Ä–µ–∑ SheetsAPI, —Å —Ñ–æ–ª–±—ç–∫–æ–º."""
    try:
        # –ù–æ–≤–∞—è –≤–µ—Ä—Å–∏—è SheetsAPI –º–æ–∂–µ—Ç –∏–º–µ—Ç—å list_worksheet_titles()
        if hasattr(sheets, "list_worksheet_titles"):
            return list(sheets.list_worksheet_titles())  # type: ignore
    except Exception:
        pass

    # –§–æ–ª–±—ç–∫: –Ω–∞–ø—Ä—è–º—É—é —á–µ—Ä–µ–∑ –æ—Ç–∫—Ä—ã—Ç—É—é –∫–Ω–∏–≥—É (–≤—Å—ë —Ä–∞–≤–Ω–æ —á–µ—Ä–µ–∑ _request_with_retry)
    try:
        spreadsheet = sheets._request_with_retry(sheets.client.open, GOOGLE_SHEET_NAME)
        worksheets = sheets._request_with_retry(spreadsheet.worksheets)
        return [ws.title for ws in worksheets]
    except Exception as e:
        logger.warning("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ª–∏—Å—Ç–æ–≤: %s", e)
        return []


def _pick_schedule_sheet_title(titles: List[str]) -> Optional[str]:
    """–í—ã–±–∏—Ä–∞–µ–º –ø–µ—Ä–≤—ã–π –ø–æ–¥—Ö–æ–¥—è—â–∏–π –ª–∏—Å—Ç –∏–∑ –∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤."""
    tset = set(titles)
    for cand in CANDIDATE_SCHEDULE_TITLES:
        if cand in tset:
            return cand
    return None


def get_shift_calendar() -> List[List[str]]:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç ¬´—Ç–∞–±–ª–∏—Ü—É –≥—Ä–∞—Ñ–∏–∫–∞¬ª –∫–∞–∫ —Å–ø–∏—Å–æ–∫ —Å–ø–∏—Å–∫–æ–≤: [ [header...], [row1...], ... ].
    –ï—Å–ª–∏ –ª–∏—Å—Ç –≥—Ä–∞—Ñ–∏–∫–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç ‚Äî –≤–µ—Ä–Ω—ë—Ç [].
    –í –Ω–æ–≤–æ–º –∫–æ–¥–µ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ AdminRepo.get_shift_calendar().
    """
    sheets = SheetsAPI()

    titles = _list_titles(sheets)
    if not titles:
        logger.info("–í –∫–Ω–∏–≥–µ '%s' –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –Ω–∏ –æ–¥–Ω–æ–≥–æ –ª–∏—Å—Ç–∞.", GOOGLE_SHEET_NAME)
        return []

    sheet_name = _pick_schedule_sheet_title(titles)
    if not sheet_name:
        logger.info(
            "–õ–∏—Å—Ç –≥—Ä–∞—Ñ–∏–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω. –û–∂–∏–¥–∞–ª–∏—Å—å –æ–¥–∏–Ω –∏–∑: %s; –µ—Å—Ç—å: %s",
            ", ".join(CANDIDATE_SCHEDULE_TITLES), ", ".join(titles),
        )
        return []

    try:
        ws = sheets.get_worksheet(sheet_name)
        values = sheets._request_with_retry(ws.get_all_values)
        if not values:
            logger.info("–õ–∏—Å—Ç '%s' –ø—É—Å—Ç–æ–π.", sheet_name)
            return []
        return values
    except SheetsAPIError as e:
        logger.warning("–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –ª–∏—Å—Ç—É '%s': %s", sheet_name, e)
        return []
    except Exception as e:
        logger.exception("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å –ª–∏—Å—Ç '%s': %s", sheet_name, e)
        return []


# –î–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å–æ —Å—Ç–∞—Ä—ã–º –∏–º–µ–Ω–µ–º
def get_shift_info() -> List[List[str]]:
    """–°—Ç–∞—Ä–æ–µ –∏–º—è —Ñ—É–Ω–∫—Ü–∏–∏, –æ—Å—Ç–∞–≤–ª–µ–Ω–æ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏."""
    logger.warning("schedule_parser.get_shift_info() —É—Å—Ç–∞—Ä–µ–ª–∞ ‚Äî –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ AdminRepo.get_shift_calendar().")
    return get_shift_calendar()

--------------------------------------------------------------------------------
# FILE: archiver.py
# SIZE: 7712 bytes | SHA256(text): bdfd07e45105c2a0c310884e7ac82791d9cabb3eccfefbe7f52395601d450874
--------------------------------------------------------------------------------
# archiver.py (reworked to use centralized SheetsAPI only)
from __future__ import annotations

import sys
import os
from pathlib import Path
from datetime import datetime, timedelta, timezone
from typing import List, Tuple, Optional, Dict
import logging
import argparse

# Ensure project root is importable (so we can import config and sheets_api when run directly)
ROOT_PATH = str(Path(__file__).parent.resolve())
if ROOT_PATH not in sys.path:
    sys.path.insert(0, ROOT_PATH)

from config import GOOGLE_SHEET_NAME, WORKLOG_SHEET, ARCHIVE_SHEET  # type: ignore
from sheets_api import SheetsAPI, SheetsAPIError  # type: ignore

logger = logging.getLogger(__name__)


# ---- helpers ----

TS_HEADER_CANDIDATES = ("timestamp", "Timestamp", "time", "Time", "–î–∞—Ç–∞", "–í—Ä–µ–º—è", "DateTime", "datetime")

def _parse_ts(s: str) -> Optional[datetime]:
    """
    Parse timestamp in flexible formats. Prefer ISO-8601 with timezone.
    Returns timezone-aware datetime in local timezone for date comparison.
    """
    s = (s or "").strip()
    if not s:
        return None
    fmts = [
        "%Y-%m-%dT%H:%M:%S%z",
        "%Y-%m-%dT%H:%M:%S.%f%z",
        "%Y-%m-%d %H:%M:%S%z",
        "%Y-%m-%d %H:%M:%S",
        "%d.%m.%Y %H:%M:%S",
        "%d.%m.%Y",
        "%Y-%m-%d",
    ]
    for f in fmts:
        try:
            dt = datetime.strptime(s, f)
            if dt.tzinfo is None:
                dt = dt.replace(tzinfo=timezone.utc)
            return dt.astimezone()
        except Exception:
            continue
    try:
        dt = datetime.fromisoformat(s)
        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=timezone.utc)
        return dt.astimezone()
    except Exception:
        return None


def _yesterday_local(base: Optional[datetime] = None) -> datetime.date:
    now_local = (base or datetime.now().astimezone())
    return (now_local.date() - timedelta(days=1))


def _find_timestamp_index(header: List[str]) -> Optional[int]:
    idx_map = { (h or "").strip(): i for i, h in enumerate(header) }
    for key in TS_HEADER_CANDIDATES:
        for h,i in idx_map.items():
            if h.lower() == key.lower():
                return i
    if len(header) >= 6 and header[5].lower().startswith("time"):
        return 5
    return None


def _ensure_archive_sheet(sheets: SheetsAPI, header: List[str]) -> object:
    """
    Get archive worksheet; if missing ‚Äî create and put header.
    """
    try:
        ws = sheets.get_worksheet(ARCHIVE_SHEET)
        values = sheets._request_with_retry(ws.get_all_values)
        if not values:
            sheets._request_with_retry(ws.update, "A1", [header])
        elif values and values[0] != header:
            pass
        return ws
    except SheetsAPIError:
        from config import GOOGLE_SHEET_NAME  # lazy import
        spreadsheet = sheets._request_with_retry(sheets.client.open, GOOGLE_SHEET_NAME)
        ws = sheets._request_with_retry(spreadsheet.add_worksheet, title=ARCHIVE_SHEET, rows=1, cols=max(1, len(header)))
        sheets._request_with_retry(ws.update, "A1", [header])
        return ws


def _collect_rows_for_date(values: List[List[str]], day: datetime.date) -> Tuple[List[List[str]], List[List[str]], List[str]]:
    """
    Split table rows to (to_archive, to_keep).
    Returns (to_archive_rows, keep_rows, header)
    """
    if not values:
        return [], [], []

    header = values[0]
    body = values[1:]
    ts_idx = _find_timestamp_index(header)
    if ts_idx is None:
        logger.warning("Timestamp column not found in header: %s", header)
        return [], values[1:], header

    to_archive: List[List[str]] = []
    keep_rows: List[List[str]] = []

    for row in body:
        ts_raw = row[ts_idx] if ts_idx < len(row) else ""
        dt = _parse_ts(ts_raw)
        if dt and dt.date() == day:
            to_archive.append(row)
        else:
            keep_rows.append(row)

    return to_archive, keep_rows, header


def _process_sheet(sheets: SheetsAPI, sheet_name: str, day: datetime.date, dry_run: bool = False) -> Tuple[int,int]:
    """
    Process one sheet: move rows for `day` to ARCHIVE_SHEET.
    Returns (archived_count, kept_count)
    """
    try:
        ws = sheets.get_worksheet(sheet_name)
        values = sheets._request_with_retry(ws.get_all_values)
        to_move, keep, header = _collect_rows_for_date(values, day)
        if not header:
            logger.info("[%s] empty or no header ‚Äî skipping", sheet_name)
            return 0, len(keep)

        archived = len(to_move)
        if archived == 0:
            logger.info("[%s] no rows for %s", sheet_name, day.isoformat())
            return 0, len(keep)

        logger.info("[%s] archiving %d rows for %s", sheet_name, archived, day.isoformat())

        if dry_run:
            return archived, len(keep)

        arch = _ensure_archive_sheet(sheets, header)
        sheets._request_with_retry(arch.append_rows, to_move, value_input_option="USER_ENTERED")

        new_data = [header] + keep if keep else [header]
        sheets._request_with_retry(ws.clear)
        sheets._request_with_retry(ws.update, "A1", new_data)

        return archived, len(keep)
    except Exception as e:
        logger.exception("Failed to process sheet %s: %s", sheet_name, e)
        return 0, 0


def run_archive(target_date: Optional[str] = None, dry_run: bool = False, only_sheet: Optional[str] = None) -> None:
    """
    Archive rows for yesterday (or for specific date YYYY-MM-DD) from WorkLog sheets to Archive.
    - If `only_sheet` is provided, process only that sheet.
    - Otherwise process WORKLOG_SHEET and all 'WorkLog_*' sheets that exist.
    """
    sheets = SheetsAPI()

    if target_date:
        try:
            day = datetime.strptime(target_date, "%Y-%m-%d").date()
        except Exception:
            raise SystemExit("Invalid --date format. Use YYYY-MM-DD")
    else:
        day = _yesterday_local()

    titles: List[str] = []
    try:
        titles = sheets.list_worksheet_titles()
    except Exception:
        pass

    candidates: List[str] = []
    if only_sheet:
        if only_sheet not in titles:
            raise SystemExit(f"Sheet '{only_sheet}' not found in {GOOGLE_SHEET_NAME}")
        candidates = [only_sheet]
    else:
        for t in titles:
            if t == WORKLOG_SHEET or t.startswith(f"{WORKLOG_SHEET}_"):
                candidates.append(t)

    if not candidates:
        logger.warning("No WorkLog-like sheets found. Nothing to do.")
        return

    total_archived = 0
    for name in candidates:
        a, _k = _process_sheet(sheets, name, day, dry_run=dry_run)
        total_archived += a

    if dry_run:
        logger.info("DRY-RUN complete. Would archive %d rows total for %s.", total_archived, day.isoformat())
    else:
        logger.info("Archive complete. Archived %d rows total for %s.", total_archived, day.isoformat())


def main():
    ap = argparse.ArgumentParser(description="Archive yesterday's rows from WorkLog sheets to Archive via SheetsAPI.")
    ap.add_argument("--date", help="Target date YYYY-MM-DD (default: yesterday in local tz)", default=None)
    ap.add_argument("--dry-run", action="store_true", help="Do not modify sheets, just report.")
    ap.add_argument("--only-sheet", help="Process only given sheet name", default=None)
    args = ap.parse_args()
    run_archive(target_date=args.date, dry_run=args.dry_run, only_sheet=args.only_sheet)

if __name__ == "__main__":
    main()

--------------------------------------------------------------------------------
# FILE: auto_sync.py
# SIZE: 22760 bytes | SHA256(text): ae8962e4c852506b031ec63650b245dbc6fd3c1cb39b170bc47cc10c23553088
--------------------------------------------------------------------------------
import sys
import logging
import time
import signal
from datetime import datetime
from threading import Event, RLock, Thread
from pathlib import Path
from typing import Dict, List, Optional
import socket
from time import monotonic

PROJECT_ROOT = Path(__file__).parent
sys.path.insert(0, str(PROJECT_ROOT))

try:
    from PyQt5.QtCore import QObject, pyqtSignal
except ImportError:
    logging.warning("PyQt5 –Ω–µ –Ω–∞–π–¥–µ–Ω. –°–∏–≥–Ω–∞–ª—ã GUI –Ω–µ –±—É–¥—É—Ç —Ä–∞–±–æ—Ç–∞—Ç—å. –ó–∞–ø—É—Å–∫ –≤ —Ä–µ–∂–∏–º–µ CLI.")
    class QObject: pass
    class pyqtSignal:
        def __init__(self): pass
        def emit(self, *args, **kwargs): pass

try:
    from config import (
        SYNC_INTERVAL,
        API_MAX_RETRIES,
        SYNC_BATCH_SIZE,
        SYNC_RETRY_STRATEGY,
        SYNC_INTERVAL_ONLINE,
        SYNC_INTERVAL_OFFLINE_RECOVERY
    )
    from user_app.db_local import LocalDB
    from sheets_api import sheets_api
    from sync.network import is_internet_available
except ImportError as e:
    logging.error(f"–û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ –º–æ–¥—É–ª–µ–π: {e}")
    raise

logger = logging.getLogger(__name__)

PING_PORT = 43333
PING_TIMEOUT = 3600  # 1 —á–∞—Å

class SyncSignals(QObject):
    force_logout = pyqtSignal()
    sync_status_updated = pyqtSignal(dict)

class SyncManager(QObject):
    def __init__(self, signals: Optional[SyncSignals] = None, background_mode: bool = True):
        super().__init__()
        logger.info(f"–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è SyncManager: background_mode={background_mode}")
        self._db = LocalDB()
        self._db_lock = RLock()
        self._stop_event = Event()
        self.signals = signals
        self._background_mode = background_mode
        self._sync_interval = SYNC_INTERVAL if background_mode else 0
        self._last_sync_time = None
        self._is_offline_recovery = False  # –§–ª–∞–≥ –¥–ª—è —Ä–µ–∂–∏–º–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
        self._stats = {
            'total_synced': 0,
            'last_sync': None,
            'last_duration': 0,
            'success_rate': 1.0,
            'queue_size': 0
        }
        self._last_ping = time.time()
        self._last_loop_started = monotonic()
        if background_mode:
            self._ping_thread = Thread(target=self._ping_listener, daemon=True)
            self._ping_thread.start()
            logger.debug("Ping listener –ø–æ—Ç–æ–∫ –∑–∞–ø—É—â–µ–Ω")

    def _check_remote_commands(self):
        logger.info("=== –ü–†–û–í–ï–†–ö–ê –ö–û–ú–ê–ù–î ===")
        if not is_internet_available():
            logger.debug("–ü—Ä–æ–≤–µ—Ä–∫–∞ —É–¥–∞–ª–µ–Ω–Ω—ã—Ö –∫–æ–º–∞–Ω–¥ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–∞: –Ω–µ—Ç –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞.")
            return

        with self._db_lock:
            email = self._db.get_current_user_email()
            logger.debug(f"–¢–µ–∫—É—â–∏–π email –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {email}")
            session = self._db.get_active_session(email) if email else None
            session_id = session["session_id"] if session else None
            logger.debug(f"–ê–∫—Ç–∏–≤–Ω–∞—è —Å–µ—Å—Å–∏—è: session_id={session_id}")

        if not email or not session_id:
            logger.debug("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π —Å–µ—Å—Å–∏–∏ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —É–¥–∞–ª–µ–Ω–Ω—ã—Ö –∫–æ–º–∞–Ω–¥.")
            return

        try:
            logger.info(f"–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ —Å–µ—Å—Å–∏–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {email}, session_id: {session_id}")
            remote_status = self._check_user_session_status(email, session_id)
            logger.debug(f"–ü–æ–ª—É—á–µ–Ω —É–¥–∞–ª–µ–Ω–Ω—ã–π —Å—Ç–∞—Ç—É—Å: {remote_status}")
            
            if remote_status == "kicked":
                logger.info(f"[ADMIN_LOGOUT] –û–±–Ω–∞—Ä—É–∂–µ–Ω —Å—Ç–∞—Ç—É—Å 'kicked' –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {email}. –ò—Å–ø—É—Å–∫–∞–µ–º force_logout.")
                if self.signals:
                    self.signals.force_logout.emit()
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º ACK –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã
                try:
                    sheets_api.ack_remote_command(email=email, session_id=session_id)
                    logger.info(f"ACK –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –¥–ª—è –∫–æ–º–∞–Ω–¥—ã kick –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {email}")
                except Exception as ack_error:
                    logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ ACK: {ack_error}")
                return
            elif remote_status == "finished":
                logger.warning(f"–ü–æ–ª—É—á–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ 'finished' –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {email}. –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–∏–≥–Ω–∞–ª–∞ –≤ GUI.")
                if self.signals:
                    logger.info("Emit force_logout signal to GUI")
                    self.signals.force_logout.emit()
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º ACK –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã
                try:
                    sheets_api.ack_remote_command(email=email, session_id=session_id)
                    logger.info(f"ACK –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –¥–ª—è –∫–æ–º–∞–Ω–¥—ã finished –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {email}")
                except Exception as ack_error:
                    logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ ACK: {ack_error}")
                # –ù–ï –≤—ã–∑—ã–≤–∞–µ–º self.stop() –∑–¥–µ—Å—å!
            else:
                logger.debug(f"–°—Ç–∞—Ç—É—Å —Å–µ—Å—Å–∏–∏ –≤ –Ω–æ—Ä–º–µ: {remote_status}")
                
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —É–¥–∞–ª–µ–Ω–Ω—ã—Ö –∫–æ–º–∞–Ω–¥ –¥–ª—è {email}: {e}", exc_info=True)

    def _check_user_session_status(self, email: str, session_id: str) -> str:
        """
        –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Å—Ç–∞—Ç—É—Å —É–∫–∞–∑–∞–Ω–Ω–æ–π —Å–µ—Å—Å–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ Google Sheets.
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç: 'active', 'kicked', 'finished', 'expired', 'unknown'
        """
        try:
            return sheets_api.check_user_session_status(email, session_id)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —Å—Ç–∞—Ç—É—Å–∞ —Å–µ—Å—Å–∏–∏: {e}")
            return "unknown"

    def _ping_listener(self):
        logger.info(f"–ó–∞–ø—É—Å–∫ ping listener –Ω–∞ UDP –ø–æ—Ä—Ç—É {PING_PORT}")
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.bind(("127.0.0.1", PING_PORT))
        s.settimeout(2)
        logger.info(f"Ping listener –∑–∞–ø—É—â–µ–Ω –Ω–∞ UDP –ø–æ—Ä—Ç—É {PING_PORT}")
        while not self._stop_event.is_set():
            try:
                data, addr = s.recvfrom(1024)
                logger.debug(f"–ü–æ–ª—É—á–µ–Ω UDP –ø–∞–∫–µ—Ç –æ—Ç {addr}: {data}")
                if data == b"ping":
                    self._last_ping = time.time()
                    logger.debug("–ü–æ–ª—É—á–µ–Ω ping, –æ–±–Ω–æ–≤–ª–µ–Ω–æ –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ ping")
            except socket.timeout:
                continue
            except Exception as e:
                logger.warning(f"–û—à–∏–±–∫–∞ –≤ ping listener: {e}", exc_info=True)
        s.close()
        logger.info("Ping listener –∑–∞–≤–µ—Ä—à–µ–Ω")

    def _prepare_batch(self) -> Optional[Dict[str, List[Dict]]]:
        logger.debug("–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –ø–∞–∫–µ—Ç–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏")
        with self._db_lock:
            try:
                unsynced = self._db.get_unsynced_actions(SYNC_BATCH_SIZE)
                logger.debug(f"–ù–∞–π–¥–µ–Ω–æ {len(unsynced)} –Ω–µ—Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π")
                
                if not unsynced:
                    logger.debug("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ –ø–∞–∫–µ—Ç–∞")
                    return None
                
                batch = {}
                for action in unsynced:
                    email = action[1]
                    if email not in batch:
                        batch[email] = []
                    batch[email].append({
                        'id': action[0],
                        'email': action[1],
                        'name': action[2],
                        'status': action[3],
                        'action_type': action[4],
                        'comment': action[5],
                        'timestamp': action[6],
                        'session_id': action[7],
                        'status_start_time': action[8],
                        'status_end_time': action[9],
                        'reason': action[10],        # NEW
                        'user_group': action[11],    # NEW
                    })
                
                logger.info(f"–ü–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω –ø–∞–∫–µ—Ç –¥–ª—è {len(batch)} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –≤—Å–µ–≥–æ –¥–µ–π—Å—Ç–≤–∏–π: {sum(len(actions) for actions in batch.values())}")
                return batch
                
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ –ø–∞–∫–µ—Ç–∞: {e}", exc_info=True)
                return None

    def _sync_batch(self, batch: Dict[str, List[Dict]]) -> bool:
        if not batch:
            logger.debug("–ü—É—Å—Ç–æ–π –ø–∞–∫–µ—Ç, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é")
            return True
            
        start_time = time.time()
        total_actions = sum(len(actions) for actions in batch.values())
        success_count = 0
        synced_ids = []
        
        logger.info(f"–ù–∞—á–∞–ª–æ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –ø–∞–∫–µ—Ç–∞ –∏–∑ {total_actions} –¥–µ–π—Å—Ç–≤–∏–π –¥–ª—è {len(batch)} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π")
        
        for email, actions in batch.items():
            logger.debug(f"–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {email}: {len(actions)} –¥–µ–π—Å—Ç–≤–∏–π")
            
            for attempt in range(API_MAX_RETRIES):
                try:
                    logger.debug(f"–ü–æ–ø—ã—Ç–∫–∞ {attempt + 1}/{API_MAX_RETRIES} –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {email}")
                    
                    if not is_internet_available():
                        logger.warning("–ò–Ω—Ç–µ—Ä–Ω–µ—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é.")
                        return False
                    
                    # –ü–æ–ª—É—á–∞–µ–º –≥—Ä—É–ø–ø—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –ª–∏—Å—Ç–∞ Users
                    user = sheets_api.get_user_by_email(email)
                    user_group = user.get("group") if user else None
                    
                    # –ì–æ—Ç–æ–≤–∏–º —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤–∞—Ä–µ–π –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏
                    actions_payload = []
                    for a in actions:
                        actions_payload.append({
                            "session_id": a['session_id'],
                            "email": a['email'],
                            "name": a['name'],
                            "status": a['status'],
                            "action_type": a['action_type'],
                            "comment": a['comment'],
                            "timestamp": a['timestamp'],
                            "status_start_time": a['status_start_time'],
                            "status_end_time": a['status_end_time'],
                            "reason": a.get('reason'),
                        })

                    # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—É—é —Å–∏–≥–Ω–∞—Ç—É—Ä—É API —Å –ø–µ—Ä–µ–¥–∞—á–µ–π user_group
                    if sheets_api.log_user_actions(actions_payload, email, user_group=user_group):
                        success_count += len(actions)
                        synced_ids.extend([a['id'] for a in actions])
                        logger.info(f"–£—Å–ø–µ—à–Ω–æ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–æ {len(actions)} –¥–µ–π—Å—Ç–≤–∏–π –¥–ª—è {email}")
                        break
                    else:
                        logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞—Ç—å –¥–µ–π—Å—Ç–≤–∏—è –¥–ª—è {email}, –ø–æ–ø—ã—Ç–∫–∞ {attempt + 1}")
                        
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –¥–ª—è {email} (–ø–æ–ø—ã—Ç–∫–∞ {attempt + 1}): {e}", exc_info=True)
                
                if attempt < API_MAX_RETRIES - 1:
                    delay = SYNC_RETRY_STRATEGY[min(attempt, len(SYNC_RETRY_STRATEGY) - 1)]
                    logger.info(f"–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ —á–µ—Ä–µ–∑ {delay} —Å–µ–∫...")
                    time.sleep(delay)
        
        if synced_ids:
            with self._db_lock:
                try:
                    logger.debug(f"–ü–æ–º–µ—á–∞–µ–º –∫–∞–∫ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ {len(synced_ids)} –∑–∞–ø–∏—Å–µ–π")
                    self._db.mark_actions_synced(synced_ids)
                    logger.info(f"–£—Å–ø–µ—à–Ω–æ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–æ –∏ –æ—Ç–º–µ—á–µ–Ω–æ {len(synced_ids)} –∑–∞–ø–∏—Å–µ–π.")
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ –∑–∞–ø–∏—Å–µ–π –≤ –ª–æ–∫–∞–ª—å–Ω–æ–π –ë–î: {e}", exc_info=True)
        
        duration = time.time() - start_time
        logger.info(f"–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –∑–∞ {duration:.2f} —Å–µ–∫. –£—Å–ø–µ—à–Ω–æ: {success_count}/{total_actions}")
        
        self._update_stats(success_count, total_actions, duration)
        return success_count == total_actions

    def _update_stats(self, success_count: int, total_actions: int, duration: float):
        logger.debug(f"–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: success={success_count}, total={total_actions}, duration={duration:.2f}")
        with self._db_lock:
            self._stats['total_synced'] += success_count
            self._stats['last_sync'] = datetime.now().isoformat(timespec='seconds')
            self._stats['last_duration'] = round(duration, 3)
            if total_actions > 0:
                rate = success_count / total_actions
                self._stats['success_rate'] = 0.9 * self._stats['success_rate'] + 0.1 * rate
            self._stats['queue_size'] = self._db.get_unsynced_count()
            
        logger.debug(f"–û–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞: {self._stats}")
        if self.signals:
            self.signals.sync_status_updated.emit(self._stats.copy())
            logger.debug("–°–∏–≥–Ω–∞–ª sync_status_updated –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω")

    def sync_once(self) -> bool:
        logger.info("=== –ó–ê–ü–£–°–ö –†–ê–ó–û–í–û–ô –°–ò–ù–•–†–û–ù–ò–ó–ê–¶–ò–ò ===")
        start = time.time()
        ok = False
        try:
            batch = self._prepare_batch()
            if not batch:
                logger.debug("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏.")
                return True

            total_actions = sum(len(actions) for actions in batch.values())
            logger.info(f"–ù–∞—á–∞–ª–æ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –ø–∞–∫–µ—Ç–∞ –∏–∑ {total_actions} –∑–∞–ø–∏—Å–µ–π.")

            # –ï—Å–ª–∏ –æ—á–µ—Ä–µ–¥—å –æ—á–µ–Ω—å –±–æ–ª—å—à–∞—è, –∞–∫—Ç–∏–≤–∏—Ä—É–µ–º —Ä–µ–∂–∏–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
            if total_actions > 100 and not self._is_offline_recovery:
                self._is_offline_recovery = True
                self._sync_interval = SYNC_INTERVAL_OFFLINE_RECOVERY
                logger.info(f"–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –±–æ–ª—å—à–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–µ–π—Å—Ç–≤–∏–π ({total_actions}). –ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω —Ä–µ–∂–∏–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è.")

            ok = self._sync_batch(batch)
            logger.info(f"–†–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞–∑–æ–≤–æ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏: {'–£–°–ü–ï–•' if ok else '–ù–ï–£–î–ê–ß–ê'}")
        finally:
            elapsed = time.time() - start
            self._stats['last_sync'] = datetime.now().isoformat(timespec='seconds')
            self._stats['last_duration'] = round(elapsed, 3)
            self._stats['queue_size'] = self._db.get_unsynced_count()
            if ok:
                self._stats['total_synced'] += 1
            if self.signals:
                self.signals.sync_status_updated.emit(dict(self._stats))
        return ok

    def run_service(self):
        logger.info(f"–°–µ—Ä–≤–∏—Å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –∑–∞–ø—É—â–µ–Ω. –ò–Ω—Ç–µ—Ä–≤–∞–ª: {self._sync_interval} —Å–µ–∫.")
        cycle_count = 0
        
        while not self._stop_event.is_set():
            cycle_count += 1
            self._last_loop_started = monotonic()
            logger.debug(f"=== –¶–ò–ö–õ –°–ò–ù–•–†–û–ù–ò–ó–ê–¶–ò–ò #{cycle_count} ===")
            
            now = time.time()
            if (now - self._last_ping) > PING_TIMEOUT:
                logger.warning("Ping –Ω–µ –ø–æ–ª—É—á–µ–Ω –±–æ–ª–µ–µ —á–∞—Å–∞ ‚Äî –∑–∞–≤–µ—Ä—à–∞–µ–º —Ä–∞–±–æ—Ç—É —Å–µ—Ä–≤–∏—Å–∞.")
                break
            
            start_time = time.time()
            try:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç
                internet_available = is_internet_available()
                logger.debug(f"–î–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞: {internet_available}")
                
                if internet_available:
                    # –ï—Å–ª–∏ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç –µ—Å—Ç—å, –ø—Ä–æ–≤–µ—Ä—è–µ–º, –≤ –∫–∞–∫–æ–º —Ä–µ–∂–∏–º–µ –º—ã –Ω–∞—Ö–æ–¥–∏–º—Å—è
                    if self._is_offline_recovery:
                        # –ï—Å–ª–∏ –º—ã –≤ —Ä–µ–∂–∏–º–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è, –ø—Ä–æ–≤–µ—Ä—è–µ–º, —Å–∫–æ–ª—å–∫–æ –∑–∞–ø–∏—Å–µ–π –æ—Å—Ç–∞–ª–æ—Å—å
                        queue_size = self._db.get_unsynced_count()
                        logger.debug(f"–†–µ–∂–∏–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è. –†–∞–∑–º–µ—Ä –æ—á–µ—Ä–µ–¥–∏: {queue_size}")
                        
                        if queue_size < 50:  # –ï—Å–ª–∏ –æ—Å—Ç–∞–ª–æ—Å—å –º–µ–Ω—å—à–µ 50 –∑–∞–ø–∏—Å–µ–π, —Å—á–∏—Ç–∞–µ–º, —á—Ç–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ
                            self._is_offline_recovery = False
                            self._sync_interval = SYNC_INTERVAL  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–º—É –∏–Ω—Ç–µ—Ä–≤–∞–ª—É
                            logger.info("–†–µ–∂–∏–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω. –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–º—É –∏–Ω—Ç–µ—Ä–≤–∞–ª—É —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏.")
                        else:
                            self._sync_interval = SYNC_INTERVAL_OFFLINE_RECOVERY
                    else:
                        # –ù–æ—Ä–º–∞–ª—å–Ω—ã–π —Ä–µ–∂–∏–º
                        self._sync_interval = SYNC_INTERVAL_ONLINE
                else:
                    # –ù–µ—Ç –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞ ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è –µ–≥–æ –ø–æ—è–≤–ª–µ–Ω–∏—è
                    self._sync_interval = 10
                    logger.debug("–ù–µ—Ç –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞, —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏–Ω—Ç–µ—Ä–≤–∞–ª 10 —Å–µ–∫")

                logger.debug(f"–¢–µ–∫—É—â–∏–π –∏–Ω—Ç–µ—Ä–≤–∞–ª —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏: {self._sync_interval} —Å–µ–∫")
                
                # –í—ã–ø–æ–ª–Ω—è–µ–º —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é
                self.sync_once()
                self._check_remote_commands()
                
            except Exception as e:
                logger.critical(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ —Ü–∏–∫–ª–µ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏: {e}", exc_info=True)
            
            elapsed = time.time() - start_time
            sleep_time = max(1, self._sync_interval - elapsed)
            logger.debug(f"–¶–∏–∫–ª –∑–∞–≤–µ—Ä—à–µ–Ω –∑–∞ {elapsed:.2f} —Å–µ–∫. –û–∂–∏–¥–∞–Ω–∏–µ {sleep_time:.2f} —Å–µ–∫")
            
            self._stop_event.wait(sleep_time)

        logger.info("–°–µ—Ä–≤–∏—Å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –∑–∞–≤–µ—Ä—à—ë–Ω.")

    def stop(self):
        logger.info("–û—Å—Ç–∞–Ω–æ–≤–∫–∞ SyncManager...")
        self._stop_event.set()
        try:
            self._db.close()
            logger.debug("–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∑–∞–∫—Ä—ã—Ç–∞")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ –ë–î: {e}", exc_info=True)
        logger.info("–°–µ—Ä–≤–∏—Å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.")

def configure_logging(background_mode: bool):
    log_file = 'auto_sync.log' if background_mode else None
    handlers = [logging.StreamHandler()]
    if log_file:
        handlers.append(logging.FileHandler(log_file, encoding='utf-8'))
    
    # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —É—Ä–æ–≤–µ–Ω—å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –¥–æ DEBUG –¥–ª—è –±–æ–ª–µ–µ –¥–µ—Ç–∞–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
    logging.basicConfig(
        level=logging.DEBUG,  # –ò–∑–º–µ–Ω–µ–Ω–æ —Å INFO –Ω–∞ DEBUG
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=handlers
    )
    
    # –î–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –±–æ–ª–µ–µ –≤—ã—Å–æ–∫–∏–π —É—Ä–æ–≤–µ–Ω—å, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –ª–æ–≥–æ–≤
    logging.getLogger('urllib3').setLevel(logging.INFO)
    logging.getLogger('googleapiclient').setLevel(logging.INFO)

def handle_shutdown(signum, frame):
    logger.info("–ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–∞–±–æ—Ç—ã (SIGTERM/SIGINT)")
    raise SystemExit("–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ø–æ —Å–∏–≥–Ω–∞–ª—É.")

def main(background_mode: bool = True):
    configure_logging(background_mode)
    manager = None
    try:
        signal.signal(signal.SIGINT, handle_shutdown)
        signal.signal(signal.SIGTERM, handle_shutdown)

        demo_signals = SyncSignals()
        def on_force_logout():
            logger.info("--- –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è: –ø–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª force_logout! –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –≤—ã–π—Ç–∏. ---")
        demo_signals.force_logout.connect(on_force_logout)

        manager = SyncManager(signals=demo_signals, background_mode=background_mode)

        if background_mode:
            logger.info("–ó–∞–ø—É—Å–∫ –≤ —Ä–µ–∂–∏–º–µ —Å–µ—Ä–≤–∏—Å–∞ (–¥–µ–º–æ)")
            manager.run_service()
        else:
            logger.info("–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ä–∞–∑–æ–≤–æ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ (–¥–µ–º–æ)")
            manager.sync_once()
            manager._check_remote_commands()

    except SystemExit as e:
        logger.info(f"–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã: {e}")
    except Exception as e:
        logger.critical(f"–§–∞—Ç–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞ –≤ main: {e}", exc_info=True)
    finally:
        if manager:
            manager.stop()

if __name__ == "__main__":
    main(background_mode=True)

--------------------------------------------------------------------------------
# FILE: build_admin.py
# SIZE: 2141 bytes | SHA256(text): 61314b2fa48430cce7746bb0fdb899626af3e0abb44d0cccd4eee315f3035c98
--------------------------------------------------------------------------------
# build_admin.py
import os
import sys
import logging
import shutil
from pathlib import Path
from PyInstaller.__main__ import run

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('build_admin.log', mode='w', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

def main():
    try:
        logger.info("üöÄ –°–±–æ—Ä–∫–∞ –∞–¥–º–∏–Ω–∫–∏...")
        app_name = "WorkTimeTracker_Admin"
        main_script = "admin_app/main_admin.py" # –ü—É—Ç—å –æ—Ç –∫–æ—Ä–Ω—è
        icon_file = "user_app/sberhealf.ico" # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç—É –∂–µ –∏–∫–æ–Ω–∫—É

        for dir_name in ['dist', 'build']:
            if Path(dir_name).exists():
                shutil.rmtree(dir_name)
                logger.info(f"üßπ –û—á–∏—â–µ–Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è: {dir_name}")

        options = [
            main_script,
            f'--name={app_name}',
            '--onedir',
            '--windowed',
            '--clean',
            '--noconfirm',
            '--log-level=WARN',
            f'--icon={icon_file}' if Path(icon_file).exists() else None,
            '--paths=.', # –ö–ª—é—á–µ–≤–∞—è —Å—Ç—Ä–æ–∫–∞
            '--add-data=secret_creds.zip;.',
            '--add-data=config.py;.',
            '--add-data=user_app/sberhealf.png;user_app',
            '--hidden-import=auto_sync',
            '--hidden-import=sheets_api',
            '--hidden-import=user_app.db_local',
        ]

        options = [opt for opt in options if opt is not None]

        logger.info(f"‚öôÔ∏è  –ó–∞–ø—É—Å–∫: {' '.join(options)}")
        run(options)

        exe_path = Path('dist') / app_name / f"{app_name}.exe"
        if exe_path.exists():
            logger.info(f"‚úÖ –£—Å–ø–µ—Ö! {exe_path}")
        else:
            raise RuntimeError("–°–±–æ—Ä–∫–∞ –ø—Ä–æ—à–ª–∞, –Ω–æ exe –Ω–µ –Ω–∞–π–¥–µ–Ω.")

    except Exception as e:
        logger.critical(f"‚ùå –û—à–∏–±–∫–∞: {e}", exc_info=True)
        sys.exit(1)

if __name__ == "__main__":
    main()

--------------------------------------------------------------------------------
# FILE: build_user.py
# SIZE: 2979 bytes | SHA256(text): 4216f57927b7d0a06a8307c71e8e7ad393eec607de641709d5b8061c3f154ff3
--------------------------------------------------------------------------------
# build_user.py
import os
import sys
import logging
import shutil
from pathlib import Path
from PyInstaller.__main__ import run

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('build_user.log', mode='w', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

def main():
    try:
        logger.info("üöÄ –°–±–æ—Ä–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–π —á–∞—Å—Ç–∏...")
        app_name = "WorkTimeTracker_User"
        main_script = "user_app/main.py"
        icon_file = "user_app/sberhealf.ico"

        # –û—á–∏—Å—Ç–∫–∞
        for dir_name in ['dist', 'build']:
            if Path(dir_name).exists():
                shutil.rmtree(dir_name)
                logger.info(f"üßπ –û—á–∏—â–µ–Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è: {dir_name}")

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è —Ñ–∞–π–ª–æ–≤
        required_files = [
            'secret_creds.zip',
            'config.py',
            'auto_sync.py',
            'sheets_api.py',
            'user_app',
            'sync'
        ]
        for file in required_files:
            if not Path(file).exists():
                logger.critical(f"‚ùå –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: {file} –Ω–µ –Ω–∞–π–¥–µ–Ω!")
                sys.exit(1)

        options = [
            main_script,
            f'--name={app_name}',
            '--onedir',
            '--windowed',
            '--clean',
            '--noconfirm',
            '--log-level=WARN',
            f'--icon={icon_file}' if Path(icon_file).exists() else None,
            '--paths=.',
            '--add-data=secret_creds.zip;.',
            '--add-data=config.py;.',
            '--add-data=auto_sync.py;.',
            '--add-data=sheets_api.py;.',
            '--add-data=user_app;user_app',
            '--add-data=sync;sync',
            '--hidden-import=PyQt5.sip',
            '--hidden-import=gspread',
            '--hidden-import=oauth2client',
            '--hidden-import=google.auth',
            '--hidden-import=googleapiclient',
            '--hidden-import=google.oauth2',
            '--hidden-import=googleapiclient.discovery',
            '--hidden-import=httplib2',
            '--hidden-import=OpenSSL',
            '--hidden-import=requests',
        ]

        options = [opt for opt in options if opt is not None]
        logger.info(f"‚öôÔ∏è –ó–∞–ø—É—Å–∫: {' '.join(options)}")
        run(options)

        exe_path = Path('dist') / app_name / f"{app_name}.exe"
        if exe_path.exists():
            logger.info(f"‚úÖ –£—Å–ø–µ—Ö! {exe_path}")
        else:
            raise RuntimeError("–°–±–æ—Ä–∫–∞ –ø—Ä–æ—à–ª–∞, –Ω–æ exe –Ω–µ –Ω–∞–π–¥–µ–Ω.")

    except Exception as e:
        logger.critical(f"‚ùå –û—à–∏–±–∫–∞: {e}", exc_info=True)
        sys.exit(1)

if __name__ == "__main__":
    main()

--------------------------------------------------------------------------------
# FILE: bundle_project.py
# SIZE: 21101 bytes | SHA256(text): b6c1f1599c20041b8ed5c6b641e5fd454d41846711bd7674452a97216ce01493
--------------------------------------------------------------------------------
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
inspect_and_bundle.py ‚Äî –µ–¥–∏–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç:
  1) –°–Ω–∏–º–æ–∫ –¥–µ—Ä–µ–≤–∞ –ø—Ä–æ–µ–∫—Ç–∞ (—Å –∏—Å–∫–ª—é—á–µ–Ω–∏—è–º–∏)
  2) TXT-–±–∞–Ω–¥–ª –∏—Å—Ö–æ–¥–Ω–∏–∫–æ–≤/–∫–æ–Ω—Ñ–∏–≥–æ–≤
  3) –û–±–∑–æ—Ä –ª–æ–∫–∞–ª—å–Ω–æ–π SQLite (—Å—Ö–µ–º–∞, –∏–Ω–¥–µ–∫—Å—ã, —Ç—Ä–∏–≥–≥–µ—Ä—ã, —Å—á—ë—Ç—á–∏–∫–∏, –ø—Ä–∏–º–µ—Ä—ã)
  4) –û–±–∑–æ—Ä Google Sheets (–∫–Ω–∏–≥–∞, –ª–∏—Å—Ç—ã, –∑–∞–≥–æ–ª–æ–≤–∫–∏, –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–æ–∫, –ø—Ä–∏–º–µ—Ä—ã)

–ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏:
  - stdlib
  - –í–∞—à –ø—Ä–æ–µ–∫—Ç (config.py, sheets_api.py) ‚Äî –¥–ª—è –ø—É—Ç–µ–π/–¥–æ—Å—Ç—É–ø–∞ –∫ Google Sheets.
    sheets_api —É–∂–µ —Å–æ–¥–µ—Ä–∂–∏—Ç ¬´–ª–µ–Ω–∏–≤—ã–π¬ª –ø—Ä–æ–∫—Å–∏/–∫–ª–∏–µ–Ω—Ç –∏ —Ä–µ—Ç—Ä–∞–∏.

–ü—Ä–∏–º–µ—Ä—ã:
  python inspect_and_bundle.py -r . -o project_report.txt
  python inspect_and_bundle.py -r . -o report.txt --db C:/path/to/local_backup.db
  python inspect_and_bundle.py --git-only --no-sheets
"""

from __future__ import annotations

import argparse
import hashlib
import mimetypes
import os
import sqlite3
import sys
import time
from pathlib import Path
from typing import Iterable, List, Dict, Optional, Tuple

# -----------------------------------
# 1) –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è –¥–µ—Ä–µ–≤–∞ –∏ –±–∞–Ω–¥–ª–∞
# -----------------------------------

EXCLUDE_TREE = {'.venv', '__pycache__', '.git', '.idea', 'dist', 'build', '.vscode', '.mypy_cache', '.pytest_cache', '.ruff_cache', 'node_modules', 'target', 'out'}
DEFAULT_EXCLUDE_DIRS = {
    ".git", ".hg", ".svn", ".idea", ".vscode",
    ".venv", "venv", "env",
    "__pycache__", ".mypy_cache", ".pytest_cache", ".ruff_cache",
    "build", "dist", ".cache", ".eggs", ".tox", ".coverage",
    "node_modules", "target", "out"
}

# –¢–µ–∫—Å—Ç–æ–≤—ã–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è (–º–æ–∂–Ω–æ —Ä–∞—Å—à–∏—Ä–∏—Ç—å —á–µ—Ä–µ–∑ --include-ext)
DEFAULT_INCLUDE_EXTS = {
    # code
    ".py", ".pyw", ".ipynb",
    ".js", ".jsx", ".ts", ".tsx", ".vue", ".svelte",
    ".java", ".kt", ".kts", ".scala", ".go", ".rb", ".php",
    ".c", ".cc", ".cpp", ".h", ".hpp", ".cs", ".rs", ".swift",
    # web / markup
    ".html", ".htm", ".css", ".scss", ".sass",
    ".xml", ".xsd", ".xslt",
    # config
    ".json", ".jsonc", ".yaml", ".yml", ".ini", ".cfg", ".toml", ".env",
    # scripts
    ".bat", ".cmd", ".ps1", ".psm1", ".sh", ".bash",
    # data-ish (text)
    ".md", ".rst", ".txt", ".csv", ".tsv", ".sql",
    # project files
    ".sln", ".csproj", ".vbproj", ".props", ".targets", ".cmake", "CMakeLists.txt",
    ".gradle", ".pro", ".pri", "Makefile", "Dockerfile", "Procfile",
}
SPECIAL_FILENAMES = {"Makefile", "Dockerfile", "Procfile", "CMakeLists.txt", ".gitignore", ".gitattributes"}

# -----------------------------------
# 2) –í—Å–ø–æ–º–æ–≥–∞–ª–∫–∏
# -----------------------------------

def normalize_extensions_set(exts: Iterable[str]) -> set[str]:
    out = set()
    for e in exts:
        e = (e or "").strip()
        if not e:
            continue
        if not e.startswith(".") and e not in SPECIAL_FILENAMES:
            e = "." + e
        out.add(e)
    return out

def is_binary_by_chunk(p: Path, chunk_size: int = 2048) -> bool:
    try:
        with p.open("rb") as f:
            chunk = f.read(chunk_size)
        if b"\x00" in chunk:
            return True
        text_chars = bytearray({7,8,9,10,12,13,27} | set(range(0x20, 0x100)) - {0x7f})
        nontext = chunk.translate(None, text_chars)
        return len(nontext) / max(1, len(chunk)) > 0.30
    except Exception:
        return True

def should_include_file(p: Path, include_exts: set[str]) -> bool:
    name = p.name
    if name in SPECIAL_FILENAMES:
        return True
    ext = p.suffix
    if ext in include_exts:
        return True
    mtype, _ = mimetypes.guess_type(str(p))
    if mtype and mtype.startswith("text/"):
        return True
    return False

def sha256_of_text(s: str) -> str:
    import hashlib as _h
    return _h.sha256(s.encode("utf-8", errors="replace")).hexdigest()

def read_text_best_effort(p: Path) -> str:
    for enc in ("utf-8", "utf-8-sig", "cp1251", "latin-1"):
        try:
            return p.read_text(encoding=enc)
        except Exception:
            continue
    try:
        return p.read_bytes().decode("latin-1", errors="replace")
    except Exception:
        return ""

# -----------------------------------
# 3) –î–µ—Ä–µ–≤–æ –ø—Ä–æ–µ–∫—Ç–∞ (–≤ —Å—Ç—Ä–æ–∫—É)
# -----------------------------------

def render_tree(dir_path: Path, prefix: str = "", exclude: set[str] = None) -> str:
    exclude = exclude or set()
    lines: List[str] = []
    try:
        entries = [e for e in os.listdir(dir_path) if e not in exclude]
    except Exception as e:
        return f"[tree] –û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ {dir_path}: {e}\n"
    entries.sort()
    for i, name in enumerate(entries):
        path = dir_path / name
        connector = "‚îî‚îÄ‚îÄ " if i == len(entries) - 1 else "‚îú‚îÄ‚îÄ "
        lines.append(prefix + connector + name)
        if path.is_dir():
            extension = "    " if i == len(entries) - 1 else "‚îÇ   "
            lines.append(render_tree(path, prefix + extension, exclude))
    return "\n".join(lines)

# -----------------------------------
# 4) –°–±–æ—Ä —Ñ–∞–π–ª–æ–≤ –ø—Ä–æ–µ–∫—Ç–∞ –≤ TXT
# -----------------------------------

def collect_files(root: Path, include_exts: set[str], exclude_dirs: set[str], max_bytes: int) -> List[Path]:
    files: List[Path] = []
    for dirpath, dirnames, filenames in os.walk(root):
        dirnames[:] = [d for d in dirnames if d not in exclude_dirs]
        dp = Path(dirpath)
        for fname in filenames:
            p = dp / fname
            try:
                if not p.is_file():
                    continue
                if p.stat().st_size > max_bytes:
                    continue
                if not should_include_file(p, include_exts):
                    continue
                if is_binary_by_chunk(p):
                    continue
                files.append(p)
            except Exception:
                continue
    files.sort(key=lambda x: str(x).lower())
    return files

def write_bundle(out, root: Path, files: List[Path]) -> None:
    ts = time.strftime("%Y-%m-%d %H:%M:%S")
    header = [
        "=" * 80,
        f"PROJECT REPORT",
        f"Generated:   {ts}",
        f"Root:        {root}",
        f"Python:      {sys.version.split()[0]}",
        f"Files:       {len(files)}",
        "=" * 80,
        ""
    ]
    out.write("\n".join(header) + "\n")
    for p in files:
        try:
            rel = p.relative_to(root)
        except Exception:
            rel = p
        try:
            text = read_text_best_effort(p)
            size = p.stat().st_size
            h = sha256_of_text(text)
            out.write("\n" + "-" * 80 + "\n")
            out.write(f"# FILE: {rel}\n")
            out.write(f"# SIZE: {size} bytes | SHA256(text): {h}\n")
            out.write("-" * 80 + "\n")
            out.write(text)
            if not text.endswith("\n"):
                out.write("\n")
        except Exception as e:
            out.write("\n" + "-" * 80 + "\n")
            out.write(f"# FILE: {rel}\n")
            out.write(f"# ERROR: {e}\n")
            out.write("-" * 80 + "\n\n")

# -----------------------------------
# 5) –ò–Ω—Å–ø–µ–∫—Ü–∏—è SQLite
# -----------------------------------

def _sql_fetchall_safe(cur: sqlite3.Cursor, sql: str, params: Tuple = ()) -> List[Tuple]:
    try:
        cur.execute(sql, params)
        return cur.fetchall()
    except Exception:
        return []

def introspect_sqlite(db_path: Path, sample_limit: int = 5) -> str:
    out: List[str] = []
    out.append("=" * 80)
    out.append("LOCAL SQLITE OVERVIEW")
    out.append(f"DB Path: {db_path}")
    out.append("=" * 80)

    if not db_path.exists():
        out.append(f"[warn] –§–∞–π–ª –ë–î –Ω–µ –Ω–∞–π–¥–µ–Ω: {db_path}")
        return "\n".join(out) + "\n"

    try:
        conn = sqlite3.connect(str(db_path))
        cur = conn.cursor()

        # –ë–∞–∑–æ–≤–∞—è –∏–Ω—Ñ–æ
        db_list = _sql_fetchall_safe(cur, "PRAGMA database_list;")
        out.append(f"database_list: {db_list}")

        # –¢–∞–±–ª–∏—Ü—ã (–∫—Ä–æ–º–µ —Å–ª—É–∂–µ–±–Ω—ã—Ö)
        tables = _sql_fetchall_safe(
            cur, "SELECT name, sql FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%' ORDER BY name;"
        )
        for name, create_sql in tables:
            out.append("-" * 80)
            out.append(f"[TABLE] {name}")
            out.append(f"schema: {create_sql}")

            # –ö–æ–ª–æ–Ω–∫–∏
            cols = _sql_fetchall_safe(cur, f"PRAGMA table_info({name});")
            if cols:
                out.append("columns:")
                for cid, cname, ctype, notnull, dflt, pk in cols:
                    out.append(f"  - {cname} {ctype or ''} NOTNULL={notnull} PK={pk} DEFAULT={dflt}")

            # –ò–Ω–¥–µ–∫—Å—ã
            idxs = _sql_fetchall_safe(cur, f"PRAGMA index_list({name});")
            if idxs:
                out.append("indexes:")
                for idx in idxs:
                    iname = idx[1]
                    unique = idx[2]
                    out.append(f"  - {iname} UNIQUE={unique}")
                    idxcols = _sql_fetchall_safe(cur, f"PRAGMA index_info({iname});")
                    for _, seqno, cname in idxcols:
                        out.append(f"      * {seqno}: {cname}")

            # –¢—Ä–∏–≥–≥–µ—Ä—ã –ø–æ —Ç–∞–±–ª–∏—Ü–µ
            trigs = _sql_fetchall_safe(
                cur, "SELECT name, sql FROM sqlite_master WHERE type='trigger' AND tbl_name=? ORDER BY name;", (name,)
            )
            if trigs:
                out.append("triggers:")
                for tname, tsql in trigs:
                    out.append(f"  - {tname}: {tsql}")

            # –°—á—ë—Ç—á–∏–∫ —Å—Ç—Ä–æ–∫
            cnt = _sql_fetchall_safe(cur, f"SELECT COUNT(*) FROM {name};")
            if cnt:
                out.append(f"rows_count: {cnt[0][0]}")

            # –ü—Ä–∏–º–µ—Ä—ã —Å—Ç—Ä–æ–∫
            samples = _sql_fetchall_safe(cur, f"SELECT * FROM {name} ORDER BY ROWID DESC LIMIT {int(sample_limit)};")
            if samples:
                out.append("sample rows (last):")
                for row in samples:
                    out.append(f"  ‚Ä¢ {row}")

        # –ì–ª–æ–±–∞–ª—å–Ω—ã–µ —Ç—Ä–∏–≥–≥–µ—Ä—ã
        gtrigs = _sql_fetchall_safe(cur, "SELECT name, tbl_name, sql FROM sqlite_master WHERE type='trigger' ORDER BY name;")
        if gtrigs:
            out.append("-" * 80)
            out.append("[TRIGGERS GLOBAL]")
            for name, tbl, sql in gtrigs:
                out.append(f"  - {name} on {tbl}: {sql}")

        conn.close()
    except Exception as e:
        out.append(f"[error] –û—à–∏–±–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è/—á—Ç–µ–Ω–∏—è SQLite: {e}")

    out.append("")
    return "\n".join(out)

# -----------------------------------
# 6) –ò–Ω—Å–ø–µ–∫—Ü–∏—è Google Sheets
# -----------------------------------

def introspect_gsheets(sample_limit: int = 3) -> str:
    """
    –ü—ã—Ç–∞–µ—Ç—Å—è –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –≤–∞—à sheets_api –∏ –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –æ–±–∑–æ—Ä –∫–Ω–∏–≥–∏:
      - –ù–∞–∑–≤–∞–Ω–∏–µ –∫–Ω–∏–≥–∏ –∏–∑ config
      - –°–ø–∏—Å–æ–∫ –ª–∏—Å—Ç–æ–≤
      - –ó–∞–≥–æ–ª–æ–≤–æ–∫ –∫–∞–∂–¥–æ–π —Ç–∞–±–ª–∏—Ü—ã
      - –ö–æ–ª-–≤–æ –Ω–µ–ø—É—Å—Ç—ã—Ö —Å—Ç—Ä–æ–∫ (–ø–æ get_all_values)
      - –ü–µ—Ä–≤—ã–µ sample_limit —Å—Ç—Ä–æ–∫
    """
    out: List[str] = []
    out.append("=" * 80)
    out.append("GOOGLE SHEETS OVERVIEW")
    out.append("=" * 80)

    try:
        # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –ª–µ–Ω–∏–≤—ã–π –ø—Ä–æ–∫—Å–∏/–∫–ª–∏–µ–Ω—Ç –∏–∑ –≤–∞—à–µ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞
        # –í –ø—Ä–æ–µ–∫—Ç–µ –µ—Å—Ç—å –º–µ—Ç–æ–¥—ã list_worksheet_titles(), get_users(), get_all_active_sessions() –∏ —Ç.–ø. :contentReference[oaicite:2]{index=2}
        import importlib

        try:
            sheets_mod = importlib.import_module("sheets_api")
        except Exception as e:
            out.append(f"[warn] –ù–µ —É–¥–∞–ª–æ—Å—å –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å sheets_api: {e}")
            return "\n".join(out) + "\n"

        # –í–æ–∑—å–º—ë–º —Ä–µ–∞–ª—å–Ω—ã–π –∏–Ω—Å—Ç–∞–Ω—Å
        if hasattr(sheets_mod, "get_sheets_api"):
            sheets = sheets_mod.get_sheets_api()
        elif hasattr(sheets_mod, "SheetsAPI"):
            sheets = sheets_mod.SheetsAPI()
        else:
            out.append("[warn] sheets_api –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç SheetsAPI/get_sheets_api")
            return "\n".join(out) + "\n"

        # –ó–∞–≥–æ–ª–æ–≤–æ–∫ –∏ –ª–∏—Å—Ç—ã
        try:
            from config import GOOGLE_SHEET_NAME  # –∏–º—è –∫–Ω–∏–≥–∏ —Ö—Ä–∞–Ω–∏—Ç—Å—è –≤ –∫–æ–Ω—Ñ–∏–≥–µ :contentReference[oaicite:3]{index=3}
        except Exception:
            GOOGLE_SHEET_NAME = "(—Å–º. config)"

        out.append(f"Spreadsheet: {GOOGLE_SHEET_NAME}")

        titles: List[str] = []
        try:
            titles = list(sheets.list_worksheet_titles())
        except Exception as e:
            out.append(f"[warn] list_worksheet_titles error: {e}")

        if not titles:
            out.append("[warn] –õ–∏—Å—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –∏–ª–∏ –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
            return "\n".join(out) + "\n"

        for t in titles:
            out.append("-" * 80)
            out.append(f"[SHEET] {t}")

            try:
                ws = sheets._get_ws(t)  # –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π helper —É –≤–∞—Å –µ—Å—Ç—å
            except Exception:
                # fallback: —á–µ—Ä–µ–∑ –∫–ª–∏–µ–Ω—Ç
                try:
                    ss = sheets.client.open(GOOGLE_SHEET_NAME)
                    ws = ss.worksheet(t)
                except Exception as e:
                    out.append(f"  [warn] –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –ª–∏—Å—Ç '{t}': {e}")
                    continue

            # –ó–∞–≥–æ–ª–æ–≤–æ–∫
            try:
                header = sheets._request_with_retry(lambda: ws.row_values(1))
                out.append(f"header: {header}")
            except Exception as e:
                out.append(f"  [warn] header read error: {e}")
                header = []

            # –í—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è, —á—Ç–æ–±—ã –ø–æ—Å—á–∏—Ç–∞—Ç—å –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏ (–±–µ–∑ –ø—É—Å—Ç—ã—Ö —Ö–≤–æ—Å—Ç–æ–≤)
            values: List[List[str]] = []
            try:
                values = sheets._request_with_retry(lambda: ws.get_all_values())
            except Exception as e:
                out.append(f"  [warn] get_all_values error: {e}")

            if values:
                # –ù–µ–ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ (–≥—Ä—É–±–∞—è –æ—Ü–µ–Ω–∫–∞)
                nonempty = [r for r in values[1:] if any((c or "").strip() for c in r)]
                out.append(f"rows_count (non-empty): {len(nonempty)}")
                # –ü—Ä–∏–º–µ—Ä—ã –ø–µ—Ä–≤—ã—Ö N
                if nonempty:
                    out.append(f"sample rows (first {sample_limit}):")
                    for row in nonempty[:sample_limit]:
                        out.append("  ‚Ä¢ " + str(row))

    except Exception as e:
        out.append(f"[error] –û—à–∏–±–∫–∞ –æ–±–∑–æ—Ä–∞ Google Sheets: {e}")

    out.append("")
    return "\n".join(out)

# -----------------------------------
# 7) –ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è/CLI
# -----------------------------------

def main():
    ap = argparse.ArgumentParser(description="–°–æ–±—Ä–∞—Ç—å –æ—Ç—á—ë—Ç –ø–æ –ø—Ä–æ–µ–∫—Ç—É (–¥–µ—Ä–µ–≤–æ, –±–∞–Ω–¥–ª, SQLite, Google Sheets).")
    ap.add_argument("-r", "--root", type=str, default=".", help="–ö–æ—Ä–µ–Ω—å –ø—Ä–æ–µ–∫—Ç–∞ (default .)")
    ap.add_argument("-o", "--output", type=str, default="project_report.txt", help="–ü—É—Ç—å –∫ –≤—ã—Ö–æ–¥–Ω–æ–º—É TXT.")
    ap.add_argument("--max-bytes", type=int, default=3_000_000, help="–ú–∞–∫—Å. —Ä–∞–∑–º–µ—Ä –æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ (–±–∞–π—Ç).")
    ap.add_argument("--include-ext", type=str, nargs="*", default=None, help="–î–æ–ø. —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è (py toml conf ...)")
    ap.add_argument("--exclude-dir", type=str, nargs="*", default=None, help="–î–æ–ø. –∫–∞—Ç–∞–ª–æ–≥–∏ –¥–ª—è –∏—Å–∫–ª—é—á–µ–Ω–∏—è (–∏–º–µ–Ω–∞).")
    ap.add_argument("--git-only", action="store_true", help="–°–æ–±–∏—Ä–∞–µ—Ç —Ç–æ–ª—å–∫–æ —Ñ–∞–π–ª—ã, –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º—ã–µ Git.")
    ap.add_argument("--no-tree", action="store_true", help="–ù–µ –¥–æ–±–∞–≤–ª—è—Ç—å –¥–µ—Ä–µ–≤–æ –ø—Ä–æ–µ–∫—Ç–∞.")
    ap.add_argument("--no-db", action="store_true", help="–ù–µ –¥–æ–±–∞–≤–ª—è—Ç—å –æ–±–∑–æ—Ä SQLite.")
    ap.add_argument("--no-sheets", action="store_true", help="–ù–µ –¥–æ–±–∞–≤–ª—è—Ç—å –æ–±–∑–æ—Ä Google Sheets.")
    ap.add_argument("--db", type=str, default=None, help="–ü—É—Ç—å –∫ SQLite (–∏–Ω–∞—á–µ –≤–æ–∑—å–º—ë–º –∏–∑ config.LOCAL_DB_PATH).")
    ap.add_argument("--db-sample", type=int, default=5, help="–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–æ–∫-–ø—Ä–∏–º–µ—Ä–æ–≤ –∏–∑ —Ç–∞–±–ª–∏—Ü SQLite.")
    ap.add_argument("--sheets-sample", type=int, default=3, help="–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–æ–∫-–ø—Ä–∏–º–µ—Ä–æ–≤ –∏–∑ –ª–∏—Å—Ç–æ–≤ Google Sheets.")

    args = ap.parse_args()

    root = Path(args.root).resolve()
    out_path = Path(args.output).resolve()
    out_path.parent.mkdir(parents=True, exist_ok=True)

    include_exts = set(DEFAULT_INCLUDE_EXTS)
    if args.include_ext:
        include_exts |= normalize_extensions_set(set(args.include_ext))

    exclude_dirs = set(DEFAULT_EXCLUDE_DIRS)
    if args.exclude_dir:
        exclude_dirs |= set(args.exclude_dir)

    # --- –ü–æ–¥–≥–æ—Ç–æ–≤–∏–º —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ ---
    if args.git_only:
        try:
            import subprocess
            res = subprocess.run(
                ["git", "ls-files"],
                check=True,
                cwd=str(root),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                encoding="utf-8",
            )
            files = []
            tracked = [root / line.strip() for line in res.stdout.splitlines() if line.strip()]
            for p in tracked:
                try:
                    if not p.exists() or not p.is_file():
                        continue
                    if p.stat().st_size > args.max_bytes:
                        continue
                    if not should_include_file(p, include_exts):
                        continue
                    if is_binary_by_chunk(p):
                        continue
                    files.append(p)
                except Exception:
                    continue
            files.sort(key=lambda x: str(x).lower())
        except Exception as e:
            print(f"[WARN] git-only —Ä–µ–∂–∏–º –Ω–µ —É–¥–∞–ª—Å—è: {e}. –ü–µ—Ä–µ—Ö–æ–¥ –∫ —Ñ–∞–π–ª–æ–≤–æ–º—É –æ–±—Ö–æ–¥—É.", file=sys.stderr)
            files = collect_files(root, include_exts, exclude_dirs, args.max_bytes)
    else:
        files = collect_files(root, include_exts, exclude_dirs, args.max_bytes)

    # --- –ü—É—Ç—å –∫ –ª–æ–∫–∞–ª—å–Ω–æ–π –ë–î ---
    db_path: Optional[Path] = None
    if not args.no_db:
        if args.db:
            db_path = Path(args.db)
        else:
            # –ü–æ–ø—Ä–æ–±—É–µ–º –¥–æ—Å—Ç–∞—Ç—å –∏–∑ config.LOCAL_DB_PATH (—É –≤–∞—Å —Ç–∞–∫ –∏ —Å–¥–µ–ª–∞–Ω–æ –≤ –ø—Ä–æ–µ–∫—Ç–µ) :contentReference[oaicite:4]{index=4}
            try:
                import importlib
                cfg = importlib.import_module("config")
                db_path = Path(getattr(cfg, "LOCAL_DB_PATH"))
            except Exception:
                # –§–æ–ª–±—ç–∫ ‚Äî –∏—â–µ–º *.db —Ä—è–¥–æ–º
                candidates = list(root.glob("**/*.db"))
                db_path = candidates[0] if candidates else None

    # --- –ó–∞–ø–∏—Å—å –æ—Ç—á—ë—Ç–∞ ---
    with out_path.open("w", encoding="utf-8", newline="\n") as out:
        # –®–∞–ø–∫–∞ + TREE
        ts = time.strftime("%Y-%m-%d %H:%M:%S")
        out.write("=" * 80 + "\n")
        out.write("PROJECT SNAPSHOT\n")
        out.write(f"Generated:   {ts}\n")
        out.write(f"Root:        {root}\n")
        out.write(f"Python:      {sys.version.split()[0]}\n")
        out.write("=" * 80 + "\n\n")

        if not args.no_tree:
            out.write("=" * 80 + "\n")
            out.write("PROJECT TREE\n")
            out.write("=" * 80 + "\n")
            out.write(render_tree(root, exclude=EXCLUDE_TREE))
            out.write("\n\n")

        # DB overview
        if not args.no_db and db_path:
            out.write(introspect_sqlite(db_path, sample_limit=args.db_sample))

        # Sheets overview
        if not args.no_sheets:
            out.write(introspect_gsheets(sample_limit=args.sheets_sample))

        # –ë–∞–Ω–¥–ª –∏—Å—Ö–æ–¥–Ω–∏–∫–æ–≤
        write_bundle(out, root, files)

    print(f"‚úì –ì–æ—Ç–æ–≤–æ: {out_path}")

if __name__ == "__main__":
    main()

--------------------------------------------------------------------------------
# FILE: config.py
# SIZE: 13794 bytes | SHA256(text): 2c1974d45eb66463e295ed01cce1a7b722213ca30c9967b4f06f69f00f148742
--------------------------------------------------------------------------------
# config.py
import os
import sys
import platform
from pathlib import Path
from typing import Dict, List, Set, Optional
from contextlib import contextmanager
import atexit

# ==================== –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è –∏–∑ .env ====================
from dotenv import load_dotenv
load_dotenv()

# ==================== –ò–º–ø–æ—Ä—Ç –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–º credentials ====================
import pyzipper
import tempfile

# ==================== –ë–∞–∑–æ–≤—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ ====================
if getattr(sys, 'frozen', False):
    # –†–µ–∂–∏–º —Å–±–æ—Ä–∫–∏ (PyInstaller)
    BASE_DIR = Path(sys.executable).parent
else:
    # –†–µ–∂–∏–º —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
    BASE_DIR = Path(__file__).parent.absolute()

# --- –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: –°–æ–∑–¥–∞–µ–º LOG_DIR —Å—Ä–∞–∑—É ---
if platform.system() == "Windows":
    LOG_DIR = Path(os.getenv('APPDATA')) / "WorkTimeTracker" / "logs"
else:
    LOG_DIR = Path.home() / ".local" / "share" / "WorkTimeTracker" / "logs"
LOG_DIR.mkdir(parents=True, exist_ok=True) # –°–æ–∑–¥–∞–µ–º –ø—Ä–∏ –∏–º–ø–æ—Ä—Ç–µ –º–æ–¥—É–ª—è
# ---

# ==================== –ü—É—Ç–∏ –∫ —Ñ–∞–π–ª–∞–º ====================
# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∞—Ä—Ö–∏–≤–∞ —Å credentials
CREDENTIALS_ZIP = BASE_DIR / 'secret_creds.zip'  # –∞—Ä—Ö–∏–≤ –¥–æ–ª–∂–µ–Ω –ª–µ–∂–∞—Ç—å —Ä—è–¥–æ–º —Å exe

# –ü–∞—Ä–æ–ª—å –±–µ—Ä—ë—Ç—Å—è –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –æ–∫—Ä—É–∂–µ–Ω–∏—è
CREDENTIALS_ZIP_PASSWORD = os.getenv("CREDENTIALS_ZIP_PASSWORD")
if CREDENTIALS_ZIP_PASSWORD is None:
    raise RuntimeError("CREDENTIALS_ZIP_PASSWORD –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ .env —Ñ–∞–π–ª–µ!")
CREDENTIALS_ZIP_PASSWORD = CREDENTIALS_ZIP_PASSWORD.encode('utf-8')

# --- –õ–µ–Ω–∏–≤–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ credentials ---
_CREDS_TMP_DIR = Path(tempfile.gettempdir()) / "wtt_creds"
_CREDS_TMP_DIR.mkdir(parents=True, exist_ok=True)
_CREDENTIALS_FILE: Optional[Path] = None

def _cleanup_credentials():
    """–£–¥–∞–ª—è–µ—Ç –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª —Å —É—á–µ—Ç–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏ –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ –∏–∑ –ø—Ä–æ—Ü–µ—Å—Å–∞."""
    try:
        if _CREDENTIALS_FILE and _CREDENTIALS_FILE.exists():
            _CREDENTIALS_FILE.unlink()
    except Exception:
        pass

# –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –æ—á–∏—Å—Ç–∫—É –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ
atexit.register(_cleanup_credentials)

@contextmanager
def credentials_path() -> Path:
    """
    –õ–µ–Ω–∏–≤–æ –∏ –≤—Ä–µ–º–µ–Ω–Ω–æ –∏–∑–≤–ª–µ–∫–∞–µ—Ç service_account.json –∏–∑ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ ZIP.
    –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: with credentials_path() as p: ...
    """
    global _CREDENTIALS_FILE
    
    # –ï—Å–ª–∏ —Ñ–∞–π–ª —É–∂–µ –∏–∑–≤–ª–µ—á–µ–Ω –∏ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ
    if _CREDENTIALS_FILE and _CREDENTIALS_FILE.exists():
        yield _CREDENTIALS_FILE
        return
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ ZIP-–∞—Ä—Ö–∏–≤–∞
    if not CREDENTIALS_ZIP.exists():
        raise FileNotFoundError(f"Zip —Å credentials –Ω–µ –Ω–∞–π–¥–µ–Ω: {CREDENTIALS_ZIP}")
    
    # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ñ–∞–π–ª –∏–∑ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∞—Ä—Ö–∏–≤–∞
    with pyzipper.AESZipFile(CREDENTIALS_ZIP) as zf:
        zf.pwd = CREDENTIALS_ZIP_PASSWORD
        try:
            data = zf.read('service_account.json')
        except KeyError:
            raise FileNotFoundError("–§–∞–π–ª 'service_account.json' –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –∞—Ä—Ö–∏–≤–µ")
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤–æ –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
        temp_file = _CREDS_TMP_DIR / 'service_account.json'
        with open(temp_file, 'wb') as f:
            f.write(data)
        
        _CREDENTIALS_FILE = temp_file
        yield _CREDENTIALS_FILE

def get_credentials_file() -> Path:
    """–û–±—Ä–∞—Ç–Ω–∞—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å: –ø–æ–ª—É—á–∏—Ç—å –ø—É—Ç—å –∫ JSON (–∏–∑–≤–ª–µ—á—ë—Ç –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –≤—ã–∑–æ–≤–µ)."""
    with credentials_path() as p:
        return Path(p)

LOCAL_DB_PATH = BASE_DIR / 'local_backup.db'
ERROR_LOG_FILE = LOG_DIR / 'error.log'
SYNC_LOG_FILE = LOG_DIR / 'sync.log'  # –î–æ–±–∞–≤–ª–µ–Ω –ª–æ–≥ –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏

# ==================== –ù–∞—Å—Ç—Ä–æ–π–∫–∏ Google Sheets ====================
GOOGLE_SHEET_NAME = "WorkLog"
USERS_SHEET = "Users"
WORKLOG_SHEET = "WorkLog"
ARCHIVE_SHEET = "Archive"
ACTIVE_SESSIONS_SHEET = "ActiveSessions"
SHIFT_CALENDAR_SHEET = ""  # –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: 'ShiftCalendar' / '–ì—Ä–∞—Ñ–∏–∫' –µ—Å–ª–∏ –ø–æ—è–≤–∏—Ç—Å—è –ª–∏—Å—Ç –≥—Ä–∞—Ñ–∏–∫–∞

# ==================== –õ–∏–º–∏—Ç—ã API ====================
GOOGLE_API_LIMITS: Dict[str, int] = {
    'max_requests_per_minute': 60,
    'max_rows_per_request': 50,
    'max_cells_per_request': 10000,
    'daily_limit': 100000
}

# ==================== –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ ====================
SYNC_INTERVAL: int = 100
SYNC_BATCH_SIZE: int = 35
API_MAX_RETRIES: int = 5  # –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ—Ç—Ä–∞–µ–≤
API_DELAY_SECONDS: float = 1.5  # –£–≤–µ–ª–∏—á–µ–Ω –±–∞–∑–æ–≤—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª
SYNC_RETRY_STRATEGY: List[int] = [60, 300, 900, 1800, 3600]  # 1, 5, 15, 30, 60 –º–∏–Ω—É—Ç - —É–≤–µ–ª–∏—á–µ–Ω–Ω–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è

# –ò–Ω—Ç–µ—Ä–≤–∞–ª—ã —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ä–µ–∂–∏–º–æ–≤ —Ä–∞–±–æ—Ç—ã
SYNC_INTERVAL_ONLINE: int = 60  # 60 —Å–µ–∫—É–Ω–¥ –ø—Ä–∏ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–π —Ä–∞–±–æ—Ç–µ
SYNC_INTERVAL_OFFLINE_RECOVERY: int = 300  # 300 —Å–µ–∫—É–Ω–¥ (5 –º–∏–Ω—É—Ç) –ø—Ä–∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–æ—Å–ª–µ –æ—Ñ—Ñ–ª–∞–π–Ω–∞

# ==================== –ì—Ä—É–ø–ø—ã –æ–±—Ä–∞–±–æ—Ç–∫–∏ ====================
GROUP_MAPPING: Dict[str, str] = {
    "call": "–í—Ö–æ–¥—è—â–∏–µ",
    "appointment": "–ó–∞–ø–∏—Å—å",
    "mail": "–ü–æ—á—Ç–∞",
    "dental": "–°—Ç–æ–º–∞—Ç–æ–ª–æ–≥–∏—è",
    "default": "–í—Ö–æ–¥—è—â–∏–µ"
}

# ==================== –°—Ç–∞—Ç—É—Å—ã —Å–∏—Å—Ç–µ–º—ã ====================
STATUSES: List[str] = [
    "–í —Ä–∞–±–æ—Ç–µ",
    "–ß–∞—Ç",
    "–ê—É–¥–∏–æ",
    "–ó–∞–ø–∏—Å—å",
    "–ê–Ω–∫–µ—Ç—ã",
    "–ü–µ—Ä–µ—Ä—ã–≤",
    "–û–±–µ–¥",
    "–¶–ò–¢–û",
    "–û–±—É—á–µ–Ω–∏–µ"
]

# –ì—Ä—É–ø–ø—ã –¥–ª—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ (—Ä–∞—Å–∫–ª–∞–¥–∫–∞ –∫–Ω–æ–ø–æ–∫)
STATUS_GROUPS: List[List[str]] = [
    ["–í —Ä–∞–±–æ—Ç–µ", "–ß–∞—Ç", "–ê—É–¥–∏–æ", "–ó–∞–ø–∏—Å—å", "–ê–Ω–∫–µ—Ç—ã"],   # –û—Å–Ω–æ–≤–Ω–∞—è —Ä–∞–±–æ—Ç–∞
    ["–ü–µ—Ä–µ—Ä—ã–≤", "–û–±–µ–¥"],                                # –ü–µ—Ä–µ—Ä—ã–≤—ã
    ["–¶–ò–¢–û", "–û–±—É—á–µ–Ω–∏–µ"]                                # –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ
]

CONFIRMATION_STATUSES: Set[str] = {"–ü–µ—Ä–µ—Ä—ã–≤", "–û–±–µ–¥", "–¶–ò–¢–û"}
RESTRICTED_STATUSES_FIRST_2H: Set[str] = {"–ü–µ—Ä–µ—Ä—ã–≤", "–û–±–µ–¥"}
MAX_COMMENT_LENGTH: int = 500
MAX_HISTORY_DAYS: int = 30

# ==================== –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ ====================
PASSWORD_MIN_LENGTH: int = 8
SESSION_TIMEOUT: int = 3600  # —Å–µ–∫—É–Ω–¥—ã
ALLOWED_DOMAINS: List[str] = ["company.com", "sberhealth.ru"]

# ==================== Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è ====================
TELEGRAM_BOT_TOKEN: str | None = os.getenv("8318266102:AAESpe4TIQpkTEAFuFD_ECZKWBkc5Tk32LU") or None
# –õ–∏—á–Ω—ã–π —á–∞—Ç –∞–¥–º–∏–Ω–∞:
TELEGRAM_ADMIN_CHAT_ID: str | None = os.getenv("1053909260") or None
# –û–±—â–∏–π –∫–∞–Ω–∞–ª –¥–ª—è –≥—Ä—É–ø–ø–æ–≤—ã—Ö –æ–±—ä—è–≤–ª–µ–Ω–∏–π (–º–æ–∂–µ—Ç –±—ã—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–π id):
TELEGRAM_BROADCAST_CHAT_ID: str | None = os.getenv("TELEGRAM_BROADCAST_CHAT_ID") or None
# –ê–Ω—Ç–∏-—Å–ø–∞–º –∫–ª—é—á–µ–π (–º–∏–Ω—É—Ç –º–µ–∂–¥—É –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º–∏ —Å–æ–±—ã—Ç–∏—è–º–∏)
TELEGRAM_MIN_INTERVAL_SEC: int = int(os.getenv("TELEGRAM_MIN_INTERVAL_SEC", "600"))
# –¢–∏—Ö–∏–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
TELEGRAM_SILENT: bool = os.getenv("TELEGRAM_SILENT", "0") == "1"
TELEGRAM_ALERTS_ENABLED: bool = bool(TELEGRAM_BOT_TOKEN and (TELEGRAM_ADMIN_CHAT_ID or TELEGRAM_BROADCAST_CHAT_ID))

# ==================== –ê—Ä—Ö–∏–≤–∏—Ä–æ–≤–∞–Ω–∏–µ ====================
ARCHIVE_DELETE_SOURCE_ROWS: bool = os.getenv("ARCHIVE_DELETE_SOURCE_ROWS", "1") == "1"

# ==================== –ü–æ—Ä–æ–≥–∏ –ø—Ä–∞–≤–∏–ª —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π ====================
# –æ–ø–æ–∑–¥–∞–Ω–∏–µ –Ω–∞ –ª–æ–≥–∏–Ω, –º–∏–Ω—É—Ç
LATE_LOGIN_MINUTES: int = int(os.getenv("LATE_LOGIN_MINUTES", "15"))
# —Å–ª–∏—à–∫–æ–º —á–∞—Å—Ç–∞—è —Å–º–µ–Ω–∞ —Å—Ç–∞—Ç—É—Å–æ–≤, —à—Ç—É–∫ –∑–∞ —á–∞—Å
OVER_STATUS_MAX_PER_HOUR: int = int(os.getenv("OVER_STATUS_MAX_PER_HOUR", "10"))
# –ø–æ—Ä–æ–≥ –æ—á–µ—Ä–µ–¥–∏ –Ω–µ—Å–∏–Ω—Ö—Ä–æ–Ω–∞
NOTIFY_QUEUE_THRESHOLD: int = int(os.getenv("NOTIFY_QUEUE_THRESHOLD", "50"))

# ==================== –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è ====================
LOG_LEVEL: str = "INFO"  # DEBUG, INFO, WARNING, ERROR, CRITICAL
LOG_ROTATION_SIZE: int = 10 * 1024 * 1024  # 10MB
LOG_BACKUP_COUNT: int = 5  # –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–∑–µ—Ä–≤–Ω—ã—Ö –∫–æ–ø–∏–π –ª–æ–≥–æ–≤

# ==================== –í–∞–ª–∏–¥–∞—Ü–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ ====================
def validate_config() -> None:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ."""
    errors = []
    
    # –õ–µ–Ω–∏–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —É—á–µ—Ç–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    try:
        with credentials_path() as creds_file:
            if not creds_file.exists():
                errors.append(f"–§–∞–π–ª —É—á–µ—Ç–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –Ω–µ –Ω–∞–π–¥–µ–Ω: {creds_file}")
    except Exception as e:
        errors.append(f"–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ —É—á–µ—Ç–Ω—ã–º –¥–∞–Ω–Ω—ã–º: {e}")
    
    if not LOG_DIR.exists():
        try:
            LOG_DIR.mkdir(parents=True)
        except Exception as e:
            errors.append(f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –ª–æ–≥–æ–≤: {e}")
    
    if not GROUP_MAPPING.get("default"):
        errors.append("–ù–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –≥—Ä—É–ø–ø—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤ GROUP_MAPPING")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
    if not CREDENTIALS_ZIP.exists():
        errors.append(f"–§–∞–π–ª secret_creds.zip –Ω–µ –Ω–∞–π–¥–µ–Ω: {CREDENTIALS_ZIP}")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä–∞—Ç–µ–≥–∏—é —Ä–µ—Ç—Ä–∞–µ–≤
    if len(SYNC_RETRY_STRATEGY) < 3:
        errors.append("–°—Ç—Ä–∞—Ç–µ–≥–∏—è –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –¥–æ–ª–∂–Ω–∞ —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 3 –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞")
    
    if max(SYNC_RETRY_STRATEGY) < 1800:
        errors.append("–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–µ –º–µ–Ω–µ–µ 1800 —Å–µ–∫—É–Ω–¥ (30 –º–∏–Ω—É—Ç)")
    
    if errors:
        raise ValueError("–û—à–∏–±–∫–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏:\n- " + "\n- ".join(errors))

# ==================== –£—Ç–∏–ª–∏—Ç—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ ====================
def get_sync_retry_delay(attempt: int) -> int:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–∞–¥–µ—Ä–∂–∫—É –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏.
    
    Args:
        attempt: –ù–æ–º–µ—Ä –ø–æ–ø—ã—Ç–∫–∏ (–Ω–∞—á–∏–Ω–∞—è —Å 0)
    
    Returns:
        –ó–∞–¥–µ—Ä–∂–∫–∞ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
    """
    if attempt < len(SYNC_RETRY_STRATEGY):
        return SYNC_RETRY_STRATEGY[attempt]
    return SYNC_RETRY_STRATEGY[-1]  # –ü–æ—Å–ª–µ–¥–Ω–∏–π –∏–Ω—Ç–µ—Ä–≤–∞–ª –¥–ª—è –≤—Å–µ—Ö –ø–æ—Å–ª–µ–¥—É—é—â–∏—Ö –ø–æ–ø—ã—Ç–æ–∫

def should_retry_sync(error: Exception) -> bool:
    """
    –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, —Å–ª–µ–¥—É–µ—Ç –ª–∏ –ø–æ–≤—Ç–æ—Ä—è—Ç—å –ø–æ–ø—ã—Ç–∫—É —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –ø—Ä–∏ –¥–∞–Ω–Ω–æ–π –æ—à–∏–±–∫–µ.
    
    Args:
        error: –ò—Å–∫–ª—é—á–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –ø—Ä–æ–∏–∑–æ—à–ª–æ
        
    Returns:
        True –µ—Å–ª–∏ —Å–ª–µ–¥—É–µ—Ç –ø–æ–≤—Ç–æ—Ä–∏—Ç—å, False –µ—Å–ª–∏ –Ω–µ—Ç
    """
    # –û—à–∏–±–∫–∏, –ø—Ä–∏ –∫–æ—Ç–æ—Ä—ã—Ö —Å—Ç–æ–∏—Ç –ø–æ–≤—Ç–æ—Ä—è—Ç—å –ø–æ–ø—ã—Ç–∫—É
    retryable_errors = [
        "ConnectionError",
        "TimeoutError",
        "HttpError",
        "ServiceUnavailable",
        "RateLimitExceeded"
    ]
    
    error_name = type(error).__name__
    return any(retryable in error_name for retryable in retryable_errors)

# ==================== –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ ====================
try:
    validate_config()
    print("‚úì –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–æ –ø—Ä–æ–≤–µ—Ä–µ–Ω–∞")
    print(f"‚úì –°—Ç—Ä–∞—Ç–µ–≥–∏—è –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫: {SYNC_RETRY_STRATEGY}")
except Exception as e:
    print(f"‚úó –û—à–∏–±–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")
    raise

# ==================== –£—Ç–∏–ª–∏—Ç—ã –¥–ª—è PyInstaller ====================
def get_resource_path(relative_path: str) -> str:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∞–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—É—Ç—å –∫ —Ä–µ—Å—É—Ä—Å—É, —É—á–∏—Ç—ã–≤–∞—è PyInstaller."""
    if hasattr(sys, '_MEIPASS'):
        base_path = Path(sys._MEIPASS)
    else:
        base_path = BASE_DIR
    return str(base_path / relative_path)

# ==================== –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è ====================
if __name__ == "__main__":
    print(f"BASE_DIR: {BASE_DIR}")
    print(f"LOG_DIR: {LOG_DIR}")
    print(f"CREDENTIALS_ZIP: {CREDENTIALS_ZIP}")
    print(f"SYNC_RETRY_STRATEGY: {SYNC_RETRY_STRATEGY}")
    print(f"–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞: {max(SYNC_RETRY_STRATEGY)} —Å–µ–∫—É–Ω–¥ ({max(SYNC_RETRY_STRATEGY)/60} –º–∏–Ω—É—Ç)")
    
    # –¢–µ—Å—Ç–∏—Ä—É–µ–º –ª–µ–Ω–∏–≤—É—é –∑–∞–≥—Ä—É–∑–∫—É credentials
    try:
        with credentials_path() as creds:
            print(f"‚úì Credentials file: {creds}")
            print(f"‚úì File exists: {creds.exists()}")
    except Exception as e:
        print(f"‚úó Error accessing credentials: {e}")

--------------------------------------------------------------------------------
# FILE: diagnostics_report.json
# SIZE: 10268 bytes | SHA256(text): 24d3d43f0e8dcf768c19369a3df6144f027ebd4d14aa43e3310cb20bda4f8f25
--------------------------------------------------------------------------------
{
  "ts": "2025-09-02T17:13:19",
  "log_dir": "C:\\Users\\–°–µ—Ä–≥–µ–π\\AppData\\Roaming\\WorkTimeTracker\\logs",
  "credentials_file": "C:\\Temp\\wtt_creds\\service_account.json",
  "sqlite": {
    "objects": [
      {
        "name": "app_logs",
        "type": "table",
        "sql": "CREATE TABLE app_logs (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                ts TEXT NOT NULL,\n                level TEXT NOT NULL,\n                message TEXT NOT NULL\n            )"
      },
      {
        "name": "app_logs_legacy_20250826175446",
        "type": "table",
        "sql": "CREATE TABLE \"app_logs_legacy_20250826175446\" (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                ts TEXT NOT NULL,\n                level TEXT NOT NULL,\n                message TEXT NOT NULL\n            )"
      },
      {
        "name": "check_comment_length",
        "type": "trigger",
        "sql": "CREATE TRIGGER check_comment_length\n            BEFORE INSERT ON logs\n            FOR EACH ROW\n            WHEN length(NEW.comment) > 500\n            BEGIN\n                SELECT RAISE(ABORT, 'Comment too long');\n            END"
      },
      {
        "name": "idx_app_logs_ts",
        "type": "index",
        "sql": "CREATE INDEX idx_app_logs_ts ON app_logs(ts)"
      },
      {
        "name": "idx_logs_email",
        "type": "index",
        "sql": "CREATE INDEX idx_logs_email ON logs(email)"
      },
      {
        "name": "idx_logs_session",
        "type": "index",
        "sql": "CREATE INDEX idx_logs_session ON logs(session_id)"
      },
      {
        "name": "idx_logs_synced",
        "type": "index",
        "sql": "CREATE INDEX idx_logs_synced ON logs(synced)"
      },
      {
        "name": "idx_logs_timestamp",
        "type": "index",
        "sql": "CREATE INDEX idx_logs_timestamp ON logs(timestamp)"
      },
      {
        "name": "idx_logs_ts",
        "type": "index",
        "sql": "CREATE INDEX idx_logs_ts ON \"app_logs_legacy_20250826175446\"(ts)"
      },
      {
        "name": "idx_offline_actions_status_ts",
        "type": "index",
        "sql": "CREATE INDEX idx_offline_actions_status_ts ON offline_actions(status, ts)"
      },
      {
        "name": "logs",
        "type": "table",
        "sql": "CREATE TABLE logs (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                session_id TEXT NOT NULL,\n                email TEXT NOT NULL,\n                name TEXT NOT NULL,\n                status TEXT,\n                action_type TEXT NOT NULL,\n                comment TEXT,\n                timestamp TEXT NOT NULL,\n                synced INTEGER DEFAULT 0,\n                sync_attempts INTEGER DEFAULT 0,\n                last_sync_attempt TEXT,\n                priority INTEGER DEFAULT 1,\n                status_start_time TEXT,\n                status_end_time TEXT,\n                reason TEXT,\n                user_group TEXT\n            )"
      },
      {
        "name": "offline_actions",
        "type": "table",
        "sql": "CREATE TABLE offline_actions (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                ts TEXT NOT NULL,\n                action_type TEXT NOT NULL,\n                payload TEXT NOT NULL,  -- JSON-—Å—Ç—Ä–æ–∫–∞\n                status TEXT NOT NULL DEFAULT 'pending'  -- pending|synced|failed\n            )"
      },
      {
        "name": "prevent_duplicate_logout",
        "type": "trigger",
        "sql": "CREATE TRIGGER prevent_duplicate_logout\n            BEFORE INSERT ON logs\n            FOR EACH ROW\n            WHEN LOWER(NEW.action_type) = 'logout' AND EXISTS (\n                SELECT 1 FROM logs\n                WHERE session_id = NEW.session_id\n                  AND LOWER(action_type) = 'logout'\n                  AND timestamp > datetime('now', '-5 minutes')\n            )\n            BEGIN\n                SELECT RAISE(ABORT, 'Duplicate LOGOUT action');\n            END"
      },
      {
        "name": "sqlite_sequence",
        "type": "table",
        "sql": "CREATE TABLE sqlite_sequence(name,seq)"
      }
    ],
    "stats": {
      "app_logs": 0,
      "app_logs_legacy_20250826175446": 0,
      "logs": 26,
      "offline_actions": 0
    },
    "samples": {
      "app_logs": [],
      "app_logs_legacy_20250826175446": [],
      "logs": [
        [
          26,
          "10@ya.ru_20250902102558",
          "10@ya.ru",
          "—Ç–µ—Å—Ç —Å—Ç–æ–º 3",
          "–ó–∞–≤–µ—Ä—à–µ–Ω–æ",
          "LOGOUT",
          "–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Å–º–µ–Ω—ã (–Ω–æ—Ä–º–∞–ª—å–Ω–æ–µ)",
          "2025-09-02T07:31:20.622314+00:00",
          0,
          0,
          null,
          1,
          "2025-09-02T10:31:20.622249",
          "2025-09-02T10:31:20.622249",
          "user",
          "–°—Ç–æ–º–∞—Ç–æ–ª–æ–≥–∏—è"
        ],
        [
          25,
          "10@ya.ru_20250902102558",
          "10@ya.ru",
          "—Ç–µ—Å—Ç —Å—Ç–æ–º 3",
          "–ê—É–¥–∏–æ",
          "STATUS_CHANGE",
          null,
          "2025-09-02T07:30:03.200596+00:00",
          1,
          1,
          "2025-09-02T07:30:05.016279+00:00",
          1,
          "2025-09-02T10:30:03.197439",
          "2025-09-02T07:31:20.619894+00:00",
          null,
          null
        ],
        [
          24,
          "10@ya.ru_20250902102558",
          "10@ya.ru",
          "—Ç–µ—Å—Ç —Å—Ç–æ–º 3",
          "–ß–∞—Ç",
          "STATUS_CHANGE",
          null,
          "2025-09-02T07:29:57.160421+00:00",
          1,
          2,
          "2025-09-02T07:30:03.496395+00:00",
          1,
          "2025-09-02T10:29:57.156445",
          "2025-09-02T10:30:03.197439",
          null,
          null
        ],
        [
          23,
          "10@ya.ru_20250902102558",
          "10@ya.ru",
          "—Ç–µ—Å—Ç —Å—Ç–æ–º 3",
          "–í —Ä–∞–±–æ—Ç–µ",
          "LOGIN",
          "–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã",
          "2025-09-02T07:25:58.866299+00:00",
          1,
          2,
          "2025-09-02T07:29:57.501512+00:00",
          1,
          "2025-09-02T10:25:58.866228",
          "2025-09-02T10:29:57.156445",
          null,
          null
        ],
        [
          22,
          "10@ya.ru_20250901175741",
          "10@ya.ru",
          "—Ç–µ—Å—Ç —Å—Ç–æ–º 3",
          "–ó–∞–≤–µ—Ä—à–µ–Ω–æ",
          "LOGOUT",
          "–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ —á–µ—Ä–µ–∑ –∫—Ä–µ—Å—Ç–∏–∫",
          "2025-09-02T05:58:06.182047+00:00",
          0,
          0,
          null,
          1,
          "2025-09-02T08:58:06.181994",
          "2025-09-02T08:58:06.181994",
          "user",
          "–°—Ç–æ–º–∞—Ç–æ–ª–æ–≥–∏—è"
        ]
      ],
      "offline_actions": []
    },
    "extra": {
      "logs_unsynced": 2,
      "offline_actions_pending": 0
    }
  },
  "sheets": {
    "worksheets": [
      {
        "title": "Admins",
        "header": [
          "Login",
          "Password"
        ],
        "rows_hint": 1000,
        "cols_hint": 26
      },
      {
        "title": "Users",
        "header": [
          "Email",
          "Name",
          "Phone",
          "Role",
          "Telegram",
          "ShiftHours",
          "Hours",
          "NotifyTelegram",
          "Group"
        ],
        "rows_hint": 999,
        "cols_hint": 26
      },
      {
        "title": "Groups",
        "header": [
          "Group",
          "Sheet",
          "Statuses",
          "–í–æ–∑–º–æ–∂–Ω—ã–µ —Å—Ç–∞—Ç—É—Å—ã: \"–í —Ä–∞–±–æ—Ç–µ\",\n    \"–ß–∞—Ç\",\n    \"–ê—É–¥–∏–æ\",\n    \"–ó–∞–ø–∏—Å—å\",\n    \"–ê–Ω–∫–µ—Ç—ã\",\n    \"–ü–µ—Ä–µ—Ä—ã–≤\",\n    \"–û–±–µ–¥\",\n    \"–¶–ò–¢–û\",\n    \"–û–±—É—á–µ–Ω–∏–µ\" \n–£–∫–∞–∑—ã–≤–∞—Ç—å —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é, –±–µ–∑ –∫–æ–≤—ã—á–µ–∫"
        ],
        "rows_hint": 1000,
        "cols_hint": 18
      },
      {
        "title": "WorkLog_–ó–∞–ø–∏—Å—å",
        "header": [
          "123@ya.ru",
          "—Ç–µ—Å—Ç –∑–∞–ø–∏—Å–∏",
          "–í —Ä–∞–±–æ—Ç–µ",
          "LOGIN",
          "–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã",
          "2025-08-25T17:49:24.965579",
          "123@ya.r_20250825174924",
          "2025-08-25T17:49:24.965517"
        ],
        "rows_hint": 1000,
        "cols_hint": 20
      },
      {
        "title": "WorkLog_–í—Ö–æ–¥—è—â–∏–µ",
        "header": [
          "Email",
          "Name",
          "Status",
          "ActionType",
          "Comment",
          "Timestamp",
          "SessionID",
          "StatusStartTime",
          "StatusEndTime"
        ],
        "rows_hint": 28,
        "cols_hint": 20
      },
      {
        "title": "ActiveSessions",
        "header": [
          "Email",
          "Name",
          "SessionID",
          "LoginTime",
          "Status",
          "LogoutTime",
          "RemoteCommand"
        ],
        "rows_hint": 905,
        "cols_hint": 26
      },
      {
        "title": "WorkLog_–°—Ç–æ–º–∞—Ç–æ–ª–æ–≥–∏—è",
        "header": [
          "10@ya.ru",
          "—Ç–µ—Å—Ç —Å—Ç–æ–º 3",
          "–í —Ä–∞–±–æ—Ç–µ",
          "LOGIN",
          "–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã",
          "2025-09-01 16:05:14",
          "10@ya.ru_20250901160514",
          "2025-09-01 19:05:14",
          "2025-09-01 16:05:20"
        ],
        "rows_hint": 775,
        "cols_hint": 18
      },
      {
        "title": "WorkLog_–ü–æ—á—Ç–∞",
        "header": [
          "7@ya.ru",
          "–¢–µ—Å—Ç –ø–æ—á—Ç—ã",
          "–í —Ä–∞–±–æ—Ç–µ",
          "LOGIN",
          "–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã",
          "2025-08-25T14:21:50.941225",
          "7@ya.ru_20250825142150",
          "2025-08-25T14:21:50.941160"
        ],
        "rows_hint": 891,
        "cols_hint": 20
      },
      {
        "title": "AccessControl",
        "header": [
          "KeyType",
          "KeyValue",
          "AccessStatus",
          "BlockUntil",
          "Reason",
          "UpdatedAt"
        ],
        "rows_hint": 1000,
        "cols_hint": 26
      }
    ],
    "expectations": []
  }
}

--------------------------------------------------------------------------------
# FILE: pyproject.toml
# SIZE: 942 bytes | SHA256(text): 07a7e3d090a15914467ec8bda005dd0dfae354d6526669f2bbc98c7782ff9545
--------------------------------------------------------------------------------
[build-system]
requires = ["setuptools>=68", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "work-time-tracker"
version = "0.4.0"
description = "Work Time Tracker"
authors = [{ name = "WTT Team" }]
requires-python = ">=3.10"
dependencies = [
  "PyQt5>=5.15",
  "gspread>=6.0.0",
  "google-auth>=2.0.0",
  "google-auth-oauthlib>=1.0.0",
  "requests>=2.31",
  "urllib3>=2.0",
  "python-dateutil>=2.9.0.post0",
]

[project.scripts]
wtt-user    = "user_app.main:main"
wtt-admin   = "admin_app.main_admin:main"
wtt-doctor  = "tools.doctor:main"
wtt-archive = "tools.archive_cli:main"
wtt-telebot = "telegram_bot.main:main"
wtt-send    = "tools.tg_send:main"
wtt-tg-env  = "tools.tg_envcheck:main"

[tool.setuptools.packages.find]
where   = ["."]
include = ["admin_app*", "user_app*", "sync*", "tools*", "telegram_bot*"]

[tool.setuptools]
py-modules = ["logging_setup", "config", "sheets_api"]

--------------------------------------------------------------------------------
# FILE: requirements.txt
# SIZE: 200 bytes | SHA256(text): eb1445194b8c0f11a15010dc9dc4033a0f2e331f9998654be26fb23e7e6db72a
--------------------------------------------------------------------------------
# === Core Google Sheets stack ===
gspread>=6.0.0
google-auth>=2.28.0
requests>=2.31.0

# === Desktop UI ===
PyQt5>=5.15.11

# === Config & secrets ===
python-dotenv>=1.0.1
pyzipper>=0.3.6

--------------------------------------------------------------------------------
# FILE: sheets_api.py
# SIZE: 35469 bytes | SHA256(text): 024aacb9b5e25c991ba2accfcf930f5129c28cdab18b7a28f9630a03d5cc4b21
--------------------------------------------------------------------------------
# sheets_api.py
import gspread
import time
import json
import sys
import os
import random
import logging
from datetime import datetime, timezone
from typing import Dict, List, Optional, Any
from pathlib import Path
from google.auth.transport.requests import AuthorizedSession
from google.oauth2.service_account import Credentials
from dataclasses import dataclass
import threading
from zoneinfo import ZoneInfo  # stdlib (Python 3.9+)

logger = logging.getLogger("sheets_api")  # –Ω–∏–∫–∞–∫–∏—Ö handlers –∑–¥–µ—Å—å ‚Äî –∫–æ–Ω—Ñ–∏–≥ —Ç–æ–ª—å–∫–æ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏


@dataclass
class QuotaInfo:
    remaining: int
    reset_time: int
    daily_used: float


class SheetsAPIError(Exception):
    def __init__(self, message: str, is_retryable: bool = False, details: str = None):
        super().__init__(message)
        self.is_retryable = is_retryable
        self.details = details
        logger.error(
            f"SheetsAPIError: {message}\n"
            f"Retryable: {is_retryable}\n"
            f"Details: {details if details else 'None'}"
        )


class SheetsAPI:
    """–°–∏–Ω–≥–ª—Ç–æ–Ω-–æ–±—ë—Ä—Ç–∫–∞ –Ω–∞–¥ gspread —Å —Ä–µ—Ç—Ä–∞—è–º–∏, –∫—ç—à–µ–º –∏ batch-–æ–ø–µ—Ä–∞—Ü–∏—è–º–∏."""
    _instance = None
    _lock = threading.Lock()

    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
                    cls._instance._initialize()
        return cls._instance

    def _initialize(self):
        from config import get_credentials_file, GOOGLE_SHEET_NAME
        self._last_request_time = None
        self._sheet_cache: Dict[str, Any] = {}
        self._session: Optional[AuthorizedSession] = None
        self._quota_info = QuotaInfo(remaining=100, reset_time=60, daily_used=0.0)
        self._quota_lock = threading.Lock()
        try:
            logger.debug("=== SheetsAPI Initialization Debug ===")
            logger.debug(f"sys.frozen: {getattr(sys, 'frozen', False)}")
            logger.debug(f"sys._MEIPASS: {getattr(sys, '_MEIPASS', 'N/A')}")
            logger.debug(f"cwd: {os.getcwd()}")
            logger.debug(f"sys.path ok, len={len(sys.path)}")

            self.credentials_path = Path(get_credentials_file()).resolve()
            logger.info(f"Initializing with credentials: {self.credentials_path}")
            logger.debug(f"Credentials exists: {os.path.exists(self.credentials_path)}")
            if not self.credentials_path.exists():
                if getattr(sys, 'frozen', False):
                    logger.error("Running in frozen mode but credentials not found!")
                raise FileNotFoundError(f"Credentials file missing at: {self.credentials_path}")
            self._init_client()
        except Exception as e:
            logger.critical("Initialization failed", exc_info=True)
            raise SheetsAPIError(
                "Google Sheets API initialization failed",
                is_retryable=False,
                details=str(e)
            )

    # ---------- low-level client/bootstrap ----------

    def _init_client(self, max_retries: int = 3) -> None:
        for attempt in range(max_retries):
            try:
                logger.info(f"Client init attempt {attempt + 1}/{max_retries}")
                with open(self.credentials_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    required = {'type', 'project_id', 'private_key_id', 'private_key', 'client_email', 'client_id'}
                    if not required.issubset(data.keys()):
                        missing = required - set(data.keys())
                        raise ValueError(f"Missing fields in credentials: {missing}")

                scopes = [
                    "https://www.googleapis.com/auth/spreadsheets",
                    "https://www.googleapis.com/auth/drive",
                ]
                credentials = Credentials.from_service_account_file(str(self.credentials_path), scopes=scopes)
                self.client = gspread.client.Client(auth=credentials)
                # gspread >=5
                self.client.session = AuthorizedSession(credentials)
                # –ù–∞ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –≤–µ—Ä—Å–∏—è—Ö http_client –º–æ–∂–µ—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤–æ–≤–∞—Ç—å ‚Äî –æ—Å—Ç–∞–≤–ª—è–µ–º, –∫–∞–∫ –±—ã–ª–æ —É —Ç–µ–±—è
                if hasattr(self.client, "http_client") and hasattr(self.client.http_client, "timeout"):
                    self.client.http_client.timeout = 30

                self._session = AuthorizedSession(credentials)
                # –£ –æ–±—ä–µ–∫—Ç–∞ AuthorizedSession –Ω–µ—Ç –∞—Ç—Ä–∏–±—É—Ç–∞ timeout –≤–æ –≤—Å–µ—Ö –≤–µ—Ä—Å–∏—è—Ö,
                # –Ω–æ –µ—Å–ª–∏ –µ—Å—Ç—å ‚Äî –≤—ã—Å—Ç–∞–≤–∏–º.
                try:
                    self._session.timeout = 30  # type: ignore[attr-defined]
                except Exception:
                    pass

                self._test_connection()
                self._update_quota_info()
                logger.info("Google Sheets client initialized successfully")
                return
            except Exception as e:
                logger.error(f"Init attempt {attempt + 1} failed: {e}")
                if attempt == max_retries - 1:
                    logger.critical("Client init failed after max attempts")
                    raise SheetsAPIError(
                        "Failed to initialize Google Sheets client",
                        is_retryable=True,
                        details=str(e)
                    )
                wait = 2 ** attempt + 5
                logger.warning(f"Retrying in {wait} seconds...")
                time.sleep(wait)

    def _test_connection(self) -> None:
        try:
            logger.info("Testing API connection...")
            start = time.time()
            _ = list(self.client.list_spreadsheet_files())
            elapsed = time.time() - start
            logger.debug(f"API test OK in {elapsed:.2f}s")
            self._update_quota_info()
        except Exception as e:
            logger.error(f"API connection test failed: {e}")
            try:
                import urllib.request
                urllib.request.urlopen('https://www.google.com', timeout=5)
                logger.debug("Internet connection is available")
            except Exception:
                logger.error("No internet connection detected")
            raise SheetsAPIError(
                "Google Sheets API connection test failed",
                is_retryable=True,
                details=str(e)
            )

    def _update_quota_info(self) -> None:
        try:
            resp = self._session.get(  # type: ignore[union-attr]
                "https://www.googleapis.com/drive/v3/about",
                params={'fields': 'user,storageQuota'},
                timeout=10
            )
            resp.raise_for_status()
            with self._quota_lock:
                self._quota_info.remaining = int(resp.headers.get('x-ratelimit-remaining', 100))
                self._quota_info.reset_time = int(resp.headers.get('x-ratelimit-reset', 60))
                self._quota_info.daily_used = float(resp.json().get('storageQuota', {}).get('usage', 0) or 0.0)
            logger.debug(f"Quota updated: {self._quota_info}")
        except Exception as e:
            logger.warning(f"Failed to update quota info: {e}")
            with self._quota_lock:
                self._quota_info.remaining = max(1, self._quota_info.remaining)
                self._quota_info.reset_time = 60

    def _check_quota(self, required: int = 1) -> bool:
        with self._quota_lock:
            if self._quota_info.remaining >= required:
                return True
            wait_time = max(1, self._quota_info.reset_time - time.time() % self._quota_info.reset_time)
            logger.warning(f"Quota low. Waiting {wait_time:.1f}s")
        time.sleep(wait_time + 1)
        self._update_quota_info()
        with self._quota_lock:
            return self._quota_info.remaining >= required

    def _check_rate_limit(self, delay: float) -> None:
        if self._last_request_time:
            elapsed = time.time() - self._last_request_time
            if elapsed < delay:
                wait = delay - elapsed
                logger.debug(f"Rate limit: waiting {wait:.2f}s")
                time.sleep(wait)
        self._last_request_time = time.time()

    def _request_with_retry(self, func, *args, **kwargs):
        from config import API_MAX_RETRIES, API_DELAY_SECONDS, GOOGLE_API_LIMITS
        last_exc: Optional[Exception] = None
        for attempt in range(API_MAX_RETRIES):
            try:
                if not self._check_quota(required=1):
                    raise SheetsAPIError("Insufficient API quota", is_retryable=True)
                self._check_rate_limit(API_DELAY_SECONDS)
                name = getattr(func, "__name__", "<callable>")
                logger.debug(f"Attempt {attempt + 1}: {name}")
                result = func(*args, **kwargs)
                with self._quota_lock:
                    self._quota_info.remaining = max(0, self._quota_info.remaining - 1)
                return result
            except Exception as e:
                last_exc = e
                # –ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è: 429/5xx/—Å–µ—Ç–µ–≤—ã–µ ‚Äî –ø–æ–≤—Ç–æ—Ä–∏–º—ã–µ
                msg = str(e).lower()
                retryable = any(x in msg for x in ("rate limit", "quota", "429", "timeout", "temporarily", "unavailable", "socket"))
                if attempt == API_MAX_RETRIES - 1 or not retryable:
                    logger.error(f"Request failed after {API_MAX_RETRIES} attempts")
                    if isinstance(e, SheetsAPIError):
                        raise
                    raise SheetsAPIError(
                        f"API request failed: {e}",
                        is_retryable=True,
                        details=str(e)
                    )
                # Full jitter: base * 2^n + random(0..base)
                base = max(1.0, float(API_DELAY_SECONDS))
                wait = base * (2 ** attempt)
                wait = wait + random.uniform(0, base)
                # –º—è–≥–∫–∞—è –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–¥ –º–∏–Ω—É—Ç–Ω—ã–π –ª–∏–º–∏—Ç
                per_min = max(1, GOOGLE_API_LIMITS.get("max_requests_per_minute", 60))
                min_gap = 60.0 / per_min
                wait = max(wait, min_gap)
                logger.warning(f"Retry {attempt + 1}/{API_MAX_RETRIES} in {wait:.2f}s (error: {e})")
                time.sleep(wait)
        raise last_exc or Exception("Unknown request error")

    # ---------- timezone helpers ----------

    def _get_tz(self):
        """
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å:
        1) config.APP_TIMEZONE –∏–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –æ–∫—Ä—É–∂–µ–Ω–∏—è APP_TIMEZONE (–Ω–∞–ø—Ä–∏–º–µ—Ä, 'Europe/Moscow')
        2) –ø—Ä–∏ –æ—à–∏–±–∫–µ ‚Äî —Å–∏—Å—Ç–µ–º–Ω—ã–π –ª–æ–∫–∞–ª—å–Ω—ã–π TZ (datetime.now().astimezone().tzinfo)
        3) –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ ‚Äî UTC
        """
        try:
            try:
                from config import APP_TIMEZONE  # –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ
                tz_name = APP_TIMEZONE or os.getenv("APP_TIMEZONE", "Europe/Moscow")
            except Exception:
                tz_name = os.getenv("APP_TIMEZONE", "Europe/Moscow")
            try:
                return ZoneInfo(tz_name)
            except Exception:
                local_tz = datetime.now().astimezone().tzinfo
                if local_tz:
                    logger.warning(f"ZoneInfo('{tz_name}') unavailable; using system local TZ")
                    return local_tz
                logger.warning(f"ZoneInfo('{tz_name}') unavailable; fallback to UTC")
                return timezone.utc
        except Exception:
            return timezone.utc

    def _fmt_local(self, dt: Optional[datetime] = None) -> str:
        """
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É 'YYYY-MM-DD HH:MM:SS' –≤ –ª–æ–∫–∞–ª—å–Ω–æ–º TZ (–¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –ø–∞—Ä—Å–∏–Ω–≥–∞ –≤ Google Sheets).
        """
        tz = self._get_tz()
        if dt is None:
            dt = datetime.now(tz)
        else:
            if dt.tzinfo is None:
                # —Å—á–∏—Ç–∞–µ–º –≤—Ö–æ–¥ –∫–∞–∫ UTC-–º–µ—Ç–∫—É –±–µ–∑ tzinfo
                dt = dt.replace(tzinfo=timezone.utc)
            dt = dt.astimezone(tz)
        return dt.strftime("%Y-%m-%d %H:%M:%S")

    def _ensure_local_str(self, ts: Optional[str]) -> str:
        """
        –ü—Ä–∏–Ω–∏–º–∞–µ—Ç ISO-—Å—Ç—Ä–æ–∫—É (–≤ —Ç.—á. ...Z –∏–ª–∏ +00:00), –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ª–æ–∫–∞–ª—å–Ω—É—é —Å—Ç—Ä–æ–∫—É –¥–ª—è Sheets.
        –ï—Å–ª–∏ –Ω–µ —É–¥–∞—ë—Ç—Å—è —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏—Å—Ö–æ–¥–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ.
        """
        if not ts:
            return self._fmt_local()
        try:
            dt = datetime.fromisoformat(ts.replace("Z", "+00:00"))
            return self._fmt_local(dt)
        except Exception:
            return ts

    # ---------- worksheet cache + discovery ----------

    def get_worksheet(self, sheet_name: str):
        from config import GOOGLE_SHEET_NAME
        if sheet_name not in self._sheet_cache:
            try:
                logger.debug(f"Opening spreadsheet: {GOOGLE_SHEET_NAME}")
                spreadsheet = self._request_with_retry(self.client.open, GOOGLE_SHEET_NAME)
                logger.debug(f"Caching worksheet: {sheet_name}")
                self._sheet_cache[sheet_name] = self._request_with_retry(spreadsheet.worksheet, sheet_name)
                logger.info(f"Worksheet '{sheet_name}' cached")
            except Exception as e:
                logger.error(f"Failed to access worksheet '{sheet_name}': {e}")
                try:
                    sheets = [ws.title for ws in spreadsheet.worksheets()]  # type: ignore[UnboundLocalVariable]
                    logger.debug(f"Available worksheets: {sheets}")
                except Exception:
                    pass
                raise SheetsAPIError(
                    f"Worksheet access error: {sheet_name}",
                    is_retryable=True,
                    details=str(e)
                )
        return self._sheet_cache[sheet_name]

    def _get_ws(self, name: str):
        """–ï–¥–∏–Ω–∞—è —Ç–æ—á–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –ª–∏—Å—Ç–∞–º (—á–µ—Ä–µ–∑ –∫—ç—à)."""
        return self.get_worksheet(name)

    def list_worksheet_titles(self) -> List[str]:
        """–°–ø–∏—Å–æ–∫ –Ω–∞–∑–≤–∞–Ω–∏–π –ª–∏—Å—Ç–æ–≤ –∫–Ω–∏–≥–∏ –±–µ–∑ –ª–∏—à–Ω–∏—Ö –æ—à–∏–±–æ–∫ –≤ –ª–æ–≥–∞—Ö."""
        from config import GOOGLE_SHEET_NAME
        spreadsheet = self._request_with_retry(self.client.open, GOOGLE_SHEET_NAME)
        sheets = self._request_with_retry(spreadsheet.worksheets)
        return [ws.title for ws in sheets]

    def has_worksheet(self, name: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ª–∏—Å—Ç–∞ –ø–æ –∏–º–µ–Ω–∏."""
        try:
            return name in self.list_worksheet_titles()
        except Exception:
            return False

    # ---------- helpers for tables ----------

    @staticmethod
    def _num_to_a1_col(n: int) -> str:
        s = ""
        while n:
            n, r = divmod(n - 1, 26)
            s = chr(65 + r) + s
        return s

    def _read_table(self, ws) -> List[Dict[str, str]]:
        rows = self._request_with_retry(lambda: ws.get_all_values())
        if not rows:
            return []
        header = rows[0]
        out: List[Dict[str, str]] = []
        for r in rows[1:]:
            if any((c or "").strip() for c in r):
                out.append({header[i]: (r[i] if i < len(header) else "") for i in range(len(header))})
        return out

    def _header_map(self, ws) -> Dict[str, int]:
        header = self._request_with_retry(lambda: ws.row_values(1))
        return {name: i + 1 for i, name in enumerate(header)}  # 1-based

    def _find_row_by(self, ws, col_name: str, value: str) -> Optional[int]:
        table = self._read_table(ws)
        val = (value or "").strip().lower()
        for idx, row in enumerate(table, start=2):  # +1 header, 1-based
            if (row.get(col_name, "") or "").strip().lower() == val:
                return idx
        return None

    # ---------- generic batch append ----------

    def batch_update(self, sheet_name: str, data: List[List[str]]) -> bool:
        if not data:
            logger.debug("No data to update - skipping")
            return True
        try:
            logger.info(f"Batch append -> '{sheet_name}' ({len(data)} rows)")
            ws = self._get_ws(sheet_name)
            chunk = 50
            for i in range(0, len(data), chunk):
                part = data[i:i + chunk]
                required_quota = max(1, len(part) // 10)
                if not self._check_quota(required=required_quota):
                    raise SheetsAPIError("Insufficient quota", is_retryable=True)
                self._request_with_retry(ws.append_rows, part, value_input_option='USER_ENTERED')
            logger.info(f"Batch append for '{sheet_name}' completed")
            return True
        except Exception as e:
            logger.error(f"Batch update failed for '{sheet_name}': {e}")
            raise SheetsAPIError(
                f"Failed to update worksheet: {sheet_name}",
                is_retryable=True,
                details=str(e)
            )

    # ========= USERS =========

    def get_users(self) -> List[Dict[str, str]]:
        from config import USERS_SHEET
        ws = self._get_ws(USERS_SHEET)
        return self._read_table(ws)

    def upsert_user(self, user: Dict[str, str]) -> None:
        from config import USERS_SHEET
        if not user.get("Email"):
            raise ValueError("user.Email is required")
        ws = self._get_ws(USERS_SHEET)
        hmap = self._header_map(ws)
        row_idx = self._find_row_by(ws, "Email", user["Email"])

        values = [[""] * len(hmap)]
        for k, v in user.items():
            if k in hmap:
                values[0][hmap[k] - 1] = str(v)

        if row_idx:
            left = self._num_to_a1_col(1)
            right = self._num_to_a1_col(len(hmap))
            rng = f"{left}{row_idx}:{right}{row_idx}"
            self._request_with_retry(lambda: ws.update(rng, values))
        else:
            self._request_with_retry(ws.append_rows, values, value_input_option='USER_ENTERED')

    def update_user_fields(self, email: str, fields: Dict[str, str]) -> None:
        from config import USERS_SHEET
        ws = self._get_ws(USERS_SHEET)
        hmap = self._header_map(ws)
        row_idx = self._find_row_by(ws, "Email", email)
        if not row_idx:
            raise ValueError(f"User {email} not found")

        row_vals = self._request_with_retry(lambda: ws.row_values(row_idx))
        row_vals = (row_vals + [""] * (len(hmap) - len(row_vals)))[:len(hmap)]
        for k, v in fields.items():
            if k in hmap:
                row_vals[hmap[k] - 1] = str(v)

        left = self._num_to_a1_col(1)
        right = self._num_to_a1_col(len(hmap))
        rng = f"{left}{row_idx}:{right}{row_idx}"
        self._request_with_retry(lambda: ws.update(rng, [row_vals]))

    def delete_user(self, email: str) -> bool:
        from config import USERS_SHEET
        ws = self._get_ws(USERS_SHEET)
        row_idx = self._find_row_by(ws, "Email", email)
        if not row_idx:
            return False
        self._request_with_retry(lambda: ws.delete_rows(row_idx))
        return True

    def get_user_by_email(self, email: str) -> Optional[Dict[str, str]]:
        """–ë—ã—Å—Ç—Ä—ã–π –ø–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ email –≤ –ª–∏—Å—Ç–µ Users."""
        from config import USERS_SHEET
        try:
            ws = self._get_ws(USERS_SHEET)
            table = self._read_table(ws)
            em = (email or "").strip().lower()
            for row in table:
                if (row.get("Email", "") or "").strip().lower() == em:
                    return {
                        "email": em,
                        "name": row.get("Name", ""),
                        "role": row.get("Role", "—Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç"),
                        "shift_hours": row.get("ShiftHours", "8 —á–∞—Å–æ–≤"),
                        "telegram_login": row.get("Telegram", ""),
                        "group": row.get("Group", ""),
                    }
            return None
        except Exception as e:
            logger.error(f"User lookup failed for '{email}': {e}")
            raise SheetsAPIError("Failed to lookup user", is_retryable=True, details=str(e))

    # ========= ACTIVE SESSIONS =========

    def get_all_active_sessions(self) -> List[Dict[str, str]]:
        from config import ACTIVE_SESSIONS_SHEET
        ws = self._get_ws(ACTIVE_SESSIONS_SHEET)
        return self._read_table(ws)

    def get_active_session(self, email: str) -> Optional[Dict[str, str]]:
        email_lower = (email or "").strip().lower()
        for row in self.get_all_active_sessions():
            if (row.get("Email", "") or "").strip().lower() == email_lower and \
               (row.get("Status", "") or "").strip().lower() == "active":
                return row
        return None

    def set_active_session(self, email: str, name: str, session_id: str, login_time: Optional[str] = None) -> bool:
        from config import ACTIVE_SESSIONS_SHEET
        ws = self._get_ws(ACTIVE_SESSIONS_SHEET)
        lt = self._ensure_local_str(login_time)
        values = [[email, name, session_id, lt, "active", ""]]
        self._request_with_retry(ws.append_rows, values, value_input_option='USER_ENTERED')
        return True

    def check_user_session_status(self, email: str, session_id: str) -> str:
        """–°—Ç–∞—Ç—É—Å –ø–æ —Ç–æ—á–Ω–æ–º—É email+session_id, –∏–Ω–∞—á–µ ‚Äî –ø–æ –ø–æ—Å–ª–µ–¥–Ω–µ–π –∑–∞–ø–∏—Å–∏ email."""
        from config import ACTIVE_SESSIONS_SHEET
        ws = self._get_ws(ACTIVE_SESSIONS_SHEET)
        table = self._read_table(ws)

        em = (email or "").strip().lower()
        sid = str(session_id).strip()

        def key_fn(t):
            idx, r = t
            ts = (r.get("LoginTime") or "").strip()
            return (ts, idx)

        exact = [(i, r) for i, r in enumerate(table, start=2)
                 if (r.get("Email", "") or "").strip().lower() == em
                 and str(r.get("SessionID", "")).strip() == sid]

        if exact:
            _, row = sorted(exact, key=key_fn)[-1]
        else:
            same_email = [(i, r) for i, r in enumerate(table, start=2)
                          if (r.get("Email", "") or "").strip().lower() == em]
            if not same_email:
                return "unknown"
            _, row = sorted(same_email, key=key_fn)[-1]

        status = (row.get("Status", "") or "").strip().lower()
        return status or "unknown"

    def finish_active_session(self, email: str, session_id: str, logout_time: Optional[str] = None) -> bool:
        """Status=finished, LogoutTime=..., batch-–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ–¥–Ω–æ–π –∫–æ–º–∞–Ω–¥–æ–π."""
        from config import ACTIVE_SESSIONS_SHEET
        ws = self._get_ws(ACTIVE_SESSIONS_SHEET)
        table = self._read_table(ws)
        em = (email or "").strip().lower()
        sid = str(session_id).strip()

        row_idx: Optional[int] = None
        for i, r in enumerate(table, start=2):
            if (r.get("Email", "") or "").strip().lower() == em and \
               str(r.get("SessionID", "")).strip() == sid and \
               (r.get("Status", "") or "").strip().lower() == "active":
                row_idx = i
                break
        if not row_idx:
            return False

        hmap = self._header_map(ws)
        lt = self._ensure_local_str(logout_time)

        cols = sorted([hmap["Status"], hmap["LogoutTime"]])
        left = self._num_to_a1_col(cols[0]); right = self._num_to_a1_col(cols[-1])
        rng = f"{left}{row_idx}:{right}{row_idx}"
        buf = [""] * (cols[-1] - cols[0] + 1)
        buf[hmap["Status"] - cols[0]] = "finished"
        buf[hmap["LogoutTime"] - cols[0]] = lt

        self._request_with_retry(lambda: ws.update(rng, [buf]))
        return True

    def kick_active_session(
        self,
        email: str,
        session_id: Optional[str] = None,
        status: str = "kicked",
        remote_cmd: str = "FORCE_LOGOUT",
        logout_time: Optional[datetime] = None
    ) -> bool:
        """
        –ù–∞—Ö–æ–¥–∏—Ç –ü–û–°–õ–ï–î–ù–Æ–Æ –∞–∫—Ç–∏–≤–Ω—É—é —Å–µ—Å—Å–∏—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ –ø–æ SessionID) –∏
        batch-–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º –≤—ã—Å—Ç–∞–≤–ª—è–µ—Ç: Status, LogoutTime (–ª–æ–∫–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è), RemoteCommand.
        """
        from config import ACTIVE_SESSIONS_SHEET
        ws = self._get_ws(ACTIVE_SESSIONS_SHEET)
        table = self._read_table(ws)
        em = (email or "").strip().lower()

        candidates = [
            (i, r) for i, r in enumerate(table, start=2)
            if (r.get("Email", "") or "").strip().lower() == em
            and (r.get("Status", "") or "").strip().lower() == "active"
            and (session_id is None or str(r.get("SessionID", "")).strip() == str(session_id).strip())
        ]
        if not candidates:
            return False

        def key_fn(t):
            idx, r = t
            ts = (r.get("LoginTime") or "").strip()
            return (ts, idx)

        row_idx, _ = sorted(candidates, key=key_fn)[-1]

        hmap = self._header_map(ws)
        need = ["Status", "LogoutTime", "RemoteCommand"]
        if not all(k in hmap for k in need):
            raise RuntimeError("ActiveSessions headers missing one of: " + ", ".join(need))

        if isinstance(logout_time, datetime):
            lt = self._fmt_local(logout_time)
        else:
            lt = self._ensure_local_str(logout_time)

        ordered_cols = sorted([hmap["Status"], hmap["LogoutTime"], hmap["RemoteCommand"]])
        left = self._num_to_a1_col(ordered_cols[0])
        right = self._num_to_a1_col(ordered_cols[-1])
        rng = f"{left}{row_idx}:{right}{row_idx}"

        width = ordered_cols[-1] - ordered_cols[0] + 1
        buf = [""] * width
        buf[hmap["Status"] - ordered_cols[0]] = status
        buf[hmap["LogoutTime"] - ordered_cols[0]] = lt
        buf[hmap["RemoteCommand"] - ordered_cols[0]] = remote_cmd

        self._request_with_retry(lambda: ws.update(rng, [buf]))
        return True

    # ---------- remote command ACK helpers ----------
    def ack_remote_command(self, email: str, session_id: str) -> bool:
        """
        –ü–æ–º–µ—á–∞–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫—É –∫–æ–º–∞–Ω–¥—ã –Ω–∞ –ª–∏—Å—Ç–µ ActiveSessions:
        - –µ—Å–ª–∏ –µ—Å—Ç—å –∫–æ–ª–æ–Ω–∫–∞ RemoteCommandAck ‚Äî —Å—Ç–∞–≤–∏–º –º–µ—Ç–∫—É –≤—Ä–µ–º–µ–Ω–∏ —Ç—É–¥–∞,
        - –∏–Ω–∞—á–µ –º—è–≥–∫–æ –æ—á–∏—â–∞–µ–º RemoteCommand (—á—Ç–æ–±—ã –∫–æ–º–∞–Ω–¥–∞ –Ω–µ —Å—Ä–∞–±–∞—Ç—ã–≤–∞–ª–∞ –ø–æ–≤—Ç–æ—Ä–Ω–æ).
        """
        SHEET = "ActiveSessions"
        try:
            ws = self._get_ws(SHEET)
            header = [h.strip() for h in self._request_with_retry(ws.row_values, 1)]
            # –∏–Ω–¥–µ–∫—Å—ã –Ω—É–∂–Ω—ã—Ö –∫–æ–ª–æ–Ω–æ–∫ (1-based –¥–ª—è update_cell)
            def idx(col: str) -> int | None:
                return header.index(col) + 1 if col in header else None
            c_email = idx("Email")
            c_sess  = idx("SessionID")
            c_cmd   = idx("RemoteCommand")
            c_ack   = idx("RemoteCommandAck")  # –º–æ–∂–µ—Ç –Ω–µ –±—ã—Ç—å ‚Äî —ç—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ
            if not (c_email and c_sess and (c_cmd or c_ack)):
                logger.info("ACK: required columns are not present on %s", SHEET)
                return False
            values = self._request_with_retry(ws.get_all_values)
            # –ü–æ–∏—Å–∫ —Å—Ç—Ä–æ–∫–∏ —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö (—á–∞—â–µ –Ω–æ–≤—ã–µ –≤–Ω–∏–∑—É)
            for i in range(len(values)-1, 0, -1):
                row = values[i]
                if len(row) >= max(c_email, c_sess):
                    if row[c_email-1] == email and row[c_sess-1] == session_id:
                        ts = time.strftime("%Y-%m-%d %H:%M:%S")
                        if c_ack:
                            self._request_with_retry(ws.update_cell, i+1, c_ack, ts)
                            logger.info("ACK set on %s for %s (%s)", SHEET, email, session_id)
                            return True
                        elif c_cmd:
                            # fallback: –æ—á–∏—â–∞–µ–º –∫–æ–º–∞–Ω–¥—É
                            self._request_with_retry(ws.update_cell, i+1, c_cmd, "")
                            logger.info("RemoteCommand cleared on %s for %s (%s)", SHEET, email, session_id)
                            return True
            logger.info("ACK: row not found for %s (%s)", email, session_id)
        except Exception as e:
            logger.warning("ACK failed: %s", e)
        return False

    # ========= LOGGING =========

    def _determine_user_group(self, email: str) -> str:
        """–°–Ω–∞—á–∞–ª–∞ Users.Group, –∑–∞—Ç–µ–º –ø–æ –ø—Ä–µ—Ñ–∏–∫—Å—É GROUP_MAPPING, –∏–Ω–∞—á–µ '–í—Ö–æ–¥—è—â–∏–µ'."""
        try:
            user = self.get_user_by_email(email)
            grp = str((user or {}).get("group", "")).strip()
            if grp:
                return grp
        except Exception as e:
            logger.warning(f"Users lookup failed while determining group for {email}: {e}")

        try:
            from config import GROUP_MAPPING
            email_prefix = str(email).split("@")[0].lower()
            for k, v in GROUP_MAPPING.items():
                if k and k.lower() in email_prefix:
                    return str(v).title()
        except Exception as e:
            logger.warning(f"Failed to determine group from GROUP_MAPPING for {email}: {e}")

        return "–í—Ö–æ–¥—è—â–∏–µ"

    def log_user_actions(self, actions: List[Dict[str, Any]], email: str, user_group: Optional[str] = None) -> bool:
        """
        –°–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –ª–æ–≥–∏—Ä—É–µ—Ç –¥–µ–π—Å—Ç–≤–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ WorkLog_*.
        –§–æ—Ä–º–∞—Ç —Å—Ç—Ä–æ–∫–∏: email, name, status, action_type, comment, timestamp, session_id,
                       status_start_time, status_end_time, reason
        """
        try:
            if not isinstance(email, str):
                guessed = actions[0].get("email") if actions and isinstance(actions[0], dict) else None
                email = guessed or str(email)
            email = (email or "").strip().lower()

            group = (user_group or "").strip() or self._determine_user_group(email)
            sheet_name = f"WorkLog_{group}"

            try:
                ws = self._get_ws(sheet_name)
            except SheetsAPIError:
                user = self.get_user_by_email(email) or {}
                grp2 = str(user.get("group", "")).strip()
                sheet_name = f"WorkLog_{grp2 or '–í—Ö–æ–¥—è—â–∏–µ'}"
                ws = self._get_ws(sheet_name)

            values = []
            for a in actions:
                values.append([
                    a.get("email", ""),
                    a.get("name", ""),
                    a.get("status", ""),
                    a.get("action_type", ""),
                    a.get("comment", ""),
                    self._ensure_local_str(a.get("timestamp")),
                    a.get("session_id", ""),
                    self._ensure_local_str(a.get("status_start_time")),
                    self._ensure_local_str(a.get("status_end_time")),
                    a.get("reason", "")
                ])

            if values:
                self._request_with_retry(ws.append_rows, values, value_input_option='USER_ENTERED')
                logger.info(f"WorkLog appended: {sheet_name} (+{len(values)})")
                return True
            return False
        except Exception as e:
            logger.error(f"Failed to log actions to sheets: {e}")
            return False

    # ---------- back-compat for user_app ----------

    def check_credentials(self) -> bool:
        """
        Back-compat –¥–ª—è user_app: –ø—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –µ—Å—Ç—å —Ñ–∞–π–ª creds –∏ –∫–ª–∏–µ–Ω—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω.
        """
        try:
            return (
                hasattr(self, "credentials_path")
                and self.credentials_path
                and os.path.exists(self.credentials_path)
                and hasattr(self, "client")
                and self.client is not None
            )
        except Exception as e:
            logger.error(f"Credentials validation error: {e}")
            return False

    # ---------- debug ----------

    def print_debug_info(self):
        print("\n=== SheetsAPI Debug Info ===")
        print(f"Credentials path: {self.credentials_path}")
        print(f"Credentials exists: {os.path.exists(self.credentials_path)}")
        print(f"Client initialized: {hasattr(self, 'client') and self.client is not None}")
        if hasattr(self, '_quota_info'):
            print(f"API Quota: {self._quota_info}")
        print("===========================\n")


# --- Lazy proxy for SheetsAPI (–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –æ–±—Ä–∞—â–µ–Ω–∏–∏) ---

class _LazySheetsAPI:
    """
    –õ—ë–≥–∫–∏–π –ø—Ä–æ–∫—Å–∏, –∫–æ—Ç–æ—Ä—ã–π —Å–æ–∑–¥–∞—ë—Ç —Ä–µ–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä SheetsAPI –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –¥–æ—Å—Ç—É–ø–µ
    –∫ –ª—é–±–æ–º—É –µ–≥–æ –∞—Ç—Ä–∏–±—É—Ç—É/–º–µ—Ç–æ–¥—É. –≠—Ç–æ —É–±–∏—Ä–∞–µ—Ç —Å–∞–π–¥-—ç—Ñ—Ñ–µ–∫—Ç—ã –ø—Ä–∏ –∏–º–ø–æ—Ä—Ç–µ –º–æ–¥—É–ª—è.
    """
    __slots__ = ("_inst",)

    def __init__(self):
        self._inst: Optional["SheetsAPI"] = None

    def _ensure(self) -> "SheetsAPI":
        if self._inst is None:
            # –í–∞–∂–Ω–æ: –∑–¥–µ—Å—å –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ç–µ–∫—É—â–∞—è –ª–æ–≥–∏–∫–∞ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞ SheetsAPI ‚Äî 
            # –æ–Ω–∞ —Å–∞–º–∞ –ø–æ–¥—Ç—è–Ω–µ—Ç –ø–∞—Ä–æ–ª—å –∏–∑ .env –∏ —Ä–∞—Å–ø–∞–∫—É–µ—Ç –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π ZIP.
            self._inst = SheetsAPI()
        return self._inst

    def __getattr__(self, name: str):
        # –ü—Ä–æ–∫—Å–∏—Ä—É–µ–º –ª—é–±—ã–µ –æ–±—Ä–∞—â–µ–Ω–∏—è –∫ —Ä–µ–∞–ª—å–Ω–æ–º—É –∏–Ω—Å—Ç–∞–Ω—Å—É
        return getattr(self._ensure(), name)

    def __repr__(self) -> str:  # —á—Ç–æ–±—ã –≤ –ª–æ–≥–∞—Ö –±—ã–ª–æ –ø–æ–Ω—è—Ç–Ω–æ, —á—Ç–æ —ç—Ç–æ –ø—Ä–æ–∫—Å–∏
        return "<SheetsAPI (lazy proxy)>"


# –ü—É–±–ª–∏—á–Ω–∞—è —Ç–æ—á–∫–∞ –≤—Ö–æ–¥–∞, —Å–æ–≤–º–µ—Å—Ç–∏–º–∞—è —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º –∫–æ–¥–æ–º:
sheets_api = _LazySheetsAPI()


def get_sheets_api() -> "SheetsAPI":
    """
    –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è —Ñ–∞–±—Ä–∏–∫–∞ –¥–ª—è —è–≤–Ω–æ–≥–æ –ø–æ–ª—É—á–µ–Ω–∏—è API.
    """
    return sheets_api._ensure()

--------------------------------------------------------------------------------
# FILE: sync\__init__.py
# SIZE: 0 bytes | SHA256(text): e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
# FILE: sync\network.py
# SIZE: 1074 bytes | SHA256(text): 577b3c117e6bc8688b6601dfe84071c1715b2c196fdf182426ec92a343a0166f
--------------------------------------------------------------------------------
# sync/network.py
import urllib.request
import socket
import logging

logger = logging.getLogger(__name__)

def is_internet_available(timeout: int = 3) -> bool:
    """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞."""
    try:
        logger.debug("–ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞...")
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º google.com –∏–ª–∏ –ª—é–±–æ–π —Å—Ç–∞–±–∏–ª—å–Ω—ã–π —Å–∞–π—Ç
        response = urllib.request.urlopen("https://www.google.com", timeout=timeout)
        if response.status == 200:
            logger.debug("–ò–Ω—Ç–µ—Ä–Ω–µ—Ç –¥–æ—Å—Ç—É–ø–µ–Ω")
            return True
        else:
            logger.warning(f"–û—Ç–≤–µ—Ç —Å–µ—Ä–≤–µ—Ä–∞ Google: {response.status}")
            return False
    except (urllib.error.URLError, socket.timeout) as e:
        logger.warning(f"–ò–Ω—Ç–µ—Ä–Ω–µ—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: {e}")
        return False
    except Exception as e:
        logger.error(f"–ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞: {e}")
        return False

--------------------------------------------------------------------------------
# FILE: sync\notifications.py
# SIZE: 2843 bytes | SHA256(text): 8aea8f9ca8bafef8de1b9835771f882c117e3f2929373f75473041a7b0d36230
--------------------------------------------------------------------------------
import logging
from PyQt5.QtWidgets import QMessageBox
from PyQt5.QtCore import Qt

logger = logging.getLogger(__name__)

class Notifier:
    @staticmethod
    def show(title: str, message: str, parent=None):
        """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å–∏—Å—Ç–µ–º–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∏–ª–∏ Qt-—Å–æ–æ–±—â–µ–Ω–∏–µ"""
        try:
            # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –ø–æ–∫–∞–∑–∞—Ç—å —Å–∏—Å—Ç–µ–º–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
            try:
                from plyer import notification
                notification.notify(
                    title=title,
                    message=message,
                    app_name='WorkLog',
                    timeout=5
                )
                return
            except ImportError:
                logger.debug("Plyer –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º Qt-—É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è")
            except Exception as e:
                logger.warning(f"–û—à–∏–±–∫–∞ —Å–∏—Å—Ç–µ–º–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")

            # Fallback –Ω–∞ Qt-—Å–æ–æ–±—â–µ–Ω–∏—è
            msg = QMessageBox(parent)
            msg.setWindowFlags(Qt.WindowStaysOnTopHint)
            msg.setWindowTitle(title)
            msg.setText(message)
            msg.setIcon(QMessageBox.Information)
            msg.setStandardButtons(QMessageBox.Ok)
            msg.exec_()

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–∫–∞–∑–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")
            # –ü–æ—Å–ª–µ–¥–Ω–∏–π —Ä–µ–∑–µ—Ä–≤–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç - –≤—ã–≤–æ–¥ –≤ –∫–æ–Ω—Å–æ–ª—å
            print(f"–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ: {title} - {message}")

    @staticmethod
    def show_warning(title: str, message: str, parent=None):
        """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–∞—é—â–µ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ"""
        try:
            msg = QMessageBox(parent)
            msg.setWindowFlags(Qt.WindowStaysOnTopHint)
            msg.setWindowTitle(title)
            msg.setText(message)
            msg.setIcon(QMessageBox.Warning)
            msg.exec_()
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–∫–∞–∑–∞ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è: {e}")
            print(f"–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ: {title} - {message}")

    @staticmethod
    def show_error(title: str, message: str, parent=None):
        """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ"""
        try:
            msg = QMessageBox(parent)
            msg.setWindowFlags(Qt.WindowStaysOnTopHint)
            msg.setWindowTitle(title)
            msg.setText(message)
            msg.setIcon(QMessageBox.Critical)
            msg.exec_()
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–∫–∞–∑–∞ –æ—à–∏–±–∫–∏: {e}")
            print(f"–û—à–∏–±–∫–∞: {title} - {message}")

--------------------------------------------------------------------------------
# FILE: sync\sync_queue.py
# SIZE: 12030 bytes | SHA256(text): 38c55f49e9e6fd549a3f667fa8621d2870f63800d6cef046542cb625601f231e
--------------------------------------------------------------------------------
import logging
import json
from pathlib import Path
from datetime import datetime, timedelta
from threading import Lock
from typing import List, Dict, Optional
import uuid
from config import MAX_COMMENT_LENGTH

logger = logging.getLogger(__name__)

class SyncQueue:
    """
    –û—á–µ—Ä–µ–¥—å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –Ω–µ—Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π:
    - –ü—Ä–∏–æ—Ä–∏—Ç–µ–∑–∞—Ü–∏–∏ –∑–∞–ø—Ä–æ—Å–æ–≤
    - –≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–≥–æ backoff
    - –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏ –ø–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º
    - –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –≤ —Ñ–∞–π–ª
    """

    def __init__(self, queue_file: Path = Path("sync_queue.json")):
        self.queue_file = queue_file
        self.lock = Lock()
        logger.debug(f"–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è SyncQueue —Å —Ñ–∞–π–ª–æ–º {self.queue_file}")
        self._load_queue()

    def _load_queue(self):
        """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –æ—á–µ—Ä–µ–¥—å –∏–∑ —Ñ–∞–π–ª–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å)"""
        try:
            if self.queue_file.exists():
                with open(self.queue_file, "r", encoding='utf-8') as f:
                    data = json.load(f)
                    if isinstance(data, list):
                        self.queue = data
                        logger.info(f"–û—á–µ—Ä–µ–¥—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞ –∏–∑ {self.queue_file} —Å {len(self.queue)} –∑–∞–ø–∏—Å—è–º–∏")
                    else:
                        self.queue = []
                        logger.warning("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞ –æ—á–µ—Ä–µ–¥–∏, –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—É—Å—Ç–æ–π –æ—á–µ—Ä–µ–¥–∏")
            else:
                self.queue = []
                logger.info("–§–∞–π–ª –æ—á–µ—Ä–µ–¥–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω, –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—É—Å—Ç–æ–π –æ—á–µ—Ä–µ–¥–∏")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –æ—á–µ—Ä–µ–¥–∏: {e}")
            self.queue = []
            self._save_queue()

    def _save_queue(self):
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –æ—á–µ—Ä–µ–¥—å –≤ —Ñ–∞–π–ª"""
        try:
            with self.lock:
                with open(self.queue_file, "w", encoding='utf-8') as f:
                    json.dump(self.queue, f, ensure_ascii=False, indent=2, default=str)
            logger.debug("–û—á–µ—Ä–µ–¥—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ —Ñ–∞–π–ª")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –æ—á–µ—Ä–µ–¥–∏: {e}")

    def add_actions(self, actions: List[Dict]):
        """
        –î–æ–±–∞–≤–ª—è–µ—Ç –¥–µ–π—Å—Ç–≤–∏—è –≤ –æ—á–µ—Ä–µ–¥—å
        Args:
            actions: –°–ø–∏—Å–æ–∫ —Å–ª–æ–≤–∞—Ä–µ–π —Å –¥–µ–π—Å—Ç–≤–∏—è–º–∏:
                {
                    'email': str,
                    'name': str,
                    'status': str,
                    'action_type': str,
                    'comment': str,
                    'timestamp': str (ISO format)
                }
        """
        if not actions:
            logger.debug("add_actions –≤—ã–∑–≤–∞–Ω —Å –ø—É—Å—Ç—ã–º —Å–ø–∏—Å–∫–æ–º")
            return

        with self.lock:
            for action in actions:
                # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π ID –¥–ª—è –¥–µ–π—Å—Ç–≤–∏—è
                action_id = str(uuid.uuid4())
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏ –æ–±—Ä–µ–∑–∞–µ–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π
                comment = action.get('comment', '')
                if len(comment) > MAX_COMMENT_LENGTH:
                    comment = comment[:MAX_COMMENT_LENGTH]
                    logger.warning(f"–û–±—Ä–µ–∑–∞–Ω –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –¥–ª—è –¥–µ–π—Å—Ç–≤–∏—è {action_id}")

                # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç
                priority = self._determine_priority(action['action_type'])

                self.queue.append({
                    'id': action_id,
                    'email': action['email'],
                    'name': action['name'],
                    'status': action['status'],
                    'action_type': action['action_type'],
                    'comment': comment,
                    'timestamp': action['timestamp'],
                    'next_retry': datetime.now().isoformat(),
                    'retry_count': 0,
                    'priority': priority,
                    'last_attempt': None,
                    'attempts': []
                })
                logger.info(f"–î–æ–±–∞–≤–ª–µ–Ω–æ –¥–µ–π—Å—Ç–≤–∏–µ –≤ –æ—á–µ—Ä–µ–¥—å: id={action_id}, action_type={action['action_type']}, email={action['email']}")
            self._save_queue()

    def _determine_priority(self, action_type: str) -> int:
        """–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –¥–µ–π—Å—Ç–≤–∏—è"""
        priority_map = {
            'LOGIN': 3,      # –í—ã—Å–æ–∫–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –¥–ª—è –≤—Ö–æ–¥–æ–≤
            'LOGOUT': 3,     # –í—ã—Å–æ–∫–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –¥–ª—è –≤—ã—Ö–æ–¥–æ–≤
            'STATUS_CHANGE': 1  # –û–±—ã—á–Ω—ã–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –¥–ª—è —Å–º–µ–Ω —Å—Ç–∞—Ç—É—Å–æ–≤
        }
        return priority_map.get(action_type, 1)

    def get_pending_actions(self, limit: int = 50) -> List[Dict]:
        """
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≥–æ—Ç–æ–≤—ã–µ –∫ –æ—Ç–ø—Ä–∞–≤–∫–µ –¥–µ–π—Å—Ç–≤–∏—è —Å —É—á–µ—Ç–æ–º:
        - –í—Ä–µ–º–µ–Ω–∏ —Å–ª–µ–¥—É—é—â–µ–π –ø–æ–ø—ã—Ç–∫–∏
        - –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞
        - –î–∞—Ç—ã —Å–æ–∑–¥–∞–Ω–∏—è
        """
        with self.lock:
            now = datetime.now()
            ready_actions = [
                a for a in self.queue
                if datetime.fromisoformat(a['next_retry']) <= now
            ]

            # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—É (–ø–æ —É–±—ã–≤–∞–Ω–∏—é) –∏ –≤—Ä–µ–º–µ–Ω–∏ —Å–æ–∑–¥–∞–Ω–∏—è (–ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é)
            sorted_actions = sorted(
                ready_actions,
                key=lambda x: (-x['priority'], x['timestamp'])
            )
            logger.debug(f"–ü–æ–ª—É—á–µ–Ω–æ {len(sorted_actions[:limit])} –≥–æ—Ç–æ–≤—ã—Ö –∫ –æ—Ç–ø—Ä–∞–≤–∫–µ –¥–µ–π—Å—Ç–≤–∏–π (limit={limit})")
            return sorted_actions[:limit]

    def mark_as_attempted(self, action_ids: List[str], success: bool):
        """–û–±–Ω–æ–≤–ª—è–µ—Ç —Å—Ç–∞—Ç—É—Å –¥–µ–π—Å—Ç–≤–∏–π –ø–æ—Å–ª–µ –ø–æ–ø—ã—Ç–∫–∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏"""
        if not action_ids:
            logger.debug("mark_as_attempted –≤—ã–∑–≤–∞–Ω —Å –ø—É—Å—Ç—ã–º —Å–ø–∏—Å–∫–æ–º")
            return

        with self.lock:
            now = datetime.now().isoformat()
            for action in self.queue[:]:
                if action['id'] in action_ids:
                    action['last_attempt'] = now
                    action['attempts'].append({
                        'time': now,
                        'success': success
                    })

                    if success:
                        # –£–¥–∞–ª—è–µ–º —É—Å–ø–µ—à–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è –∏–∑ –æ—á–µ—Ä–µ–¥–∏
                        self.queue.remove(action)
                        logger.info(f"–£–¥–∞–ª–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ id={action['id']}")
                    else:
                        # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –ø–æ–ø—ã—Ç–æ–∫
                        action['retry_count'] += 1
                        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Ä–µ–º—è —Å–ª–µ–¥—É—é—â–µ–π –ø–æ–ø—ã—Ç–∫–∏
                        action['next_retry'] = self._calculate_next_retry(
                            action['retry_count']
                        ).isoformat()
                        logger.info(f"–û—Ç–º–µ—á–µ–Ω–æ –Ω–µ—É–¥–∞—á–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ id={action['id']}, retry_count={action['retry_count']}")
            self._save_queue()

    def _calculate_next_retry(self, retry_count: int) -> datetime:
        """–í—ã—á–∏—Å–ª—è–µ—Ç –≤—Ä–µ–º—è —Å–ª–µ–¥—É—é—â–µ–π –ø–æ–ø—ã—Ç–∫–∏ —Å —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–º backoff"""
        base_delay = min(60 * (2 ** retry_count), 86400)  # –ú–∞–∫—Å–∏–º—É–º 1 –¥–µ–Ω—å (86400 —Å–µ–∫—É–Ω–¥)
        jitter = base_delay * 0.1  # –î–æ–±–∞–≤–ª—è–µ–º 10% —Å–ª—É—á–∞–π–Ω–æ—Å—Ç–∏
        next_retry_time = datetime.now() + timedelta(seconds=base_delay + jitter)
        logger.debug(f"–†–∞—Å—á–µ—Ç –≤—Ä–µ–º–µ–Ω–∏ —Å–ª–µ–¥—É—é—â–µ–π –ø–æ–ø—ã—Ç–∫–∏: retry_count={retry_count}, delay={base_delay}s, next_retry={next_retry_time.isoformat()}")
        return next_retry_time

    def clear_processed(self, action_ids: List[str]):
        """–£–¥–∞–ª—è–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è –∏–∑ –æ—á–µ—Ä–µ–¥–∏"""
        if not action_ids:
            logger.debug("clear_processed –≤—ã–∑–≤–∞–Ω —Å –ø—É—Å—Ç—ã–º —Å–ø–∏—Å–∫–æ–º")
            return

        with self.lock:
            before_count = len(self.queue)
            self.queue = [a for a in self.queue if a['id'] not in action_ids]
            removed = before_count - len(self.queue)
            if removed > 0:
                logger.info(f"–£–¥–∞–ª–µ–Ω–æ {removed} –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π –∏–∑ –æ—á–µ—Ä–µ–¥–∏")
                self._save_queue()

    def retry_failed_actions(self, max_retries: int = 5):
        """–û–±–Ω–æ–≤–ª—è–µ—Ç –≤—Ä–µ–º—è –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫ –¥–ª—è –Ω–µ—É–¥–∞—á–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π"""
        with self.lock:
            updated = 0
            for action in self.queue:
                if action['retry_count'] >= max_retries:
                    continue

                if not action['attempts'] or not action['attempts'][-1]['success']:
                    action['next_retry'] = self._calculate_next_retry(
                        action['retry_count']
                    ).isoformat()
                    updated += 1
            if updated > 0:
                logger.info(f"–û–±–Ω–æ–≤–ª–µ–Ω–æ –≤—Ä–µ–º—è –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫ –¥–ª—è {updated} –¥–µ–π—Å—Ç–≤–∏–π")
                self._save_queue()

    def get_stats(self) -> Dict:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –æ—á–µ—Ä–µ–¥–∏"""
        with self.lock:
            now = datetime.now()
            pending = [
                a for a in self.queue
                if datetime.fromisoformat(a['next_retry']) <= now
            ]
            
            stats = {
                'total': len(self.queue),
                'pending': len(pending),
                'oldest': min(
                    [datetime.fromisoformat(a['timestamp']) for a in self.queue],
                    default=None
                ),
                'by_status': self._count_by_status()
            }
            logger.debug(f"–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ—á–µ—Ä–µ–¥–∏: {stats}")
            return stats

    def _count_by_status(self) -> Dict:
        """–°—á–∏—Ç–∞–µ—Ç –¥–µ–π—Å—Ç–≤–∏—è –ø–æ —Ç–∏–ø–∞–º"""
        counts = {}
        for action in self.queue:
            typ = action['action_type']
            counts[typ] = counts.get(typ, 0) + 1
        return counts

    def clean_old_entries(self, days: int = 7):
        """–û—á–∏—â–∞–µ—Ç —Å—Ç–∞—Ä—ã–µ –∑–∞–ø–∏—Å–∏ —Å—Ç–∞—Ä—à–µ —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –¥–Ω–µ–π"""
        with self.lock:
            cutoff = datetime.now() - timedelta(days=days)
            initial_count = len(self.queue)
            
            self.queue = [
                a for a in self.queue
                if datetime.fromisoformat(a['timestamp']) >= cutoff
            ]
            
            removed = initial_count - len(self.queue)
            if removed > 0:
                logger.info(f"–£–¥–∞–ª–µ–Ω–æ {removed} —Å—Ç–∞—Ä—ã—Ö –∑–∞–ø–∏—Å–µ–π –∏–∑ –æ—á–µ—Ä–µ–¥–∏")
                self._save_queue()

    def __len__(self):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ –æ—á–µ—Ä–µ–¥–∏"""
        with self.lock:
            length = len(self.queue)
            logger.debug(f"–¢–µ–∫—É—â–∏–π —Ä–∞–∑–º–µ—Ä –æ—á–µ—Ä–µ–¥–∏: {length}")
            return length

--------------------------------------------------------------------------------
# FILE: telegram_bot\__init__.py
# SIZE: 102 bytes | SHA256(text): 114f7efbc4ccea1547e4a90d1e9955ff1fcdfce1f131ce0cf9c4aa3f0ab84ca2
--------------------------------------------------------------------------------
# telegram_bot/__init__.py
from .notifier import TelegramNotifier

__all__ = ["TelegramNotifier"]

--------------------------------------------------------------------------------
# FILE: telegram_bot\main.py
# SIZE: 4086 bytes | SHA256(text): 0f38db9d0e5d5882bc8e3c126b6b4a18917ae62d9744b3cb9e421f64498acf11
--------------------------------------------------------------------------------
# telegram_bot/main.py
from __future__ import annotations
import logging, re, time, requests, os
from typing import Optional
from config import GOOGLE_SHEET_NAME, USERS_SHEET, TELEGRAM_BOT_TOKEN as CFG_TELEGRAM_BOT_TOKEN
from sheets_api import SheetsAPI

log = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)
EMAIL_RE = re.compile(r"^[^@\s]+@[^@\s]+\.[^@\s]+$")

def _base() -> str:
    # config ‚Üí ENV
    token = (CFG_TELEGRAM_BOT_TOKEN or os.getenv("TELEGRAM_BOT_TOKEN", "")).strip()
    if not token:
        raise SystemExit(
            "TELEGRAM_BOT_TOKEN –Ω–µ –∑–∞–¥–∞–Ω. "
            "–í PowerShell —É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é —Ç–∞–∫:\n"
            '$env:TELEGRAM_BOT_TOKEN = "123456:ABC..."\n'
            "–ë–µ–∑ —É–≥–ª–æ–≤—ã—Ö —Å–∫–æ–±–æ–∫."
        )
    return f"https://api.telegram.org/bot{token}"

def _send(chat_id: int | str, text: str) -> None:
    requests.post(_base()+"/sendMessage", json={"chat_id": chat_id, "text": text, "parse_mode": "HTML"}, timeout=20)

def _num_to_col(n: int) -> str:
    res = ""
    while n:
        n, r = divmod(n - 1, 26)
        res = chr(65 + r) + res
    return res

def _set_user_telegram(email: str, chat_id: int | str) -> bool:
    api = SheetsAPI()
    ws = api.client.open(GOOGLE_SHEET_NAME).worksheet(USERS_SHEET)
    header = api._request_with_retry(ws.row_values, 1) or []
    values = api._request_with_retry(ws.get_all_values) or []
    lh = [str(h or "").strip().lower() for h in header]
    if "email" not in lh:
        raise RuntimeError("–í –ª–∏—Å—Ç–µ Users –Ω–µ—Ç –∫–æ–ª–æ–Ω–∫–∏ 'Email'")
    ix_email = lh.index("email")
    ix_tg = lh.index("telegram") if "telegram" in lh else None
    row_ix = None
    for i, r in enumerate(values[1:], start=2):
        e = (r[ix_email] if ix_email < len(r) else "").strip().lower()
        if e == email:
            row_ix = i; break
    if row_ix is None:
        return False
    if ix_tg is None:
        header.append("Telegram")
        api._request_with_retry(ws.update, "A1", [header])
        ix_tg = len(header) - 1
    cell = f"{_num_to_col(ix_tg + 1)}{row_ix}"
    api._request_with_retry(ws.update, cell, str(chat_id))
    return True

def main():
    log.info("Telegram linker bot started")
    base = _base()
    offset: Optional[int] = None
    hello = ("üëã –ü—Ä–∏–≤–µ—Ç! –û—Ç–ø—Ä–∞–≤—å —Å–≤–æ–π —Ä–∞–±–æ—á–∏–π e-mail (–Ω–∞–ø—Ä–∏–º–µ—Ä, user@company.com), "
             "–∏ —è –ø—Ä–∏–≤—è–∂—É —ç—Ç–æ—Ç —á–∞—Ç –∫ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è–º —Å–∏—Å—Ç–µ–º—ã.")
    while True:
        try:
            params = {"timeout": 60}
            if offset is not None:
                params["offset"] = offset
            r = requests.get(base+"/getUpdates", params=params, timeout=70)
            data = r.json()
            if not data.get("ok"):
                time.sleep(2); continue
            for upd in data.get("result", []):
                offset = upd["update_id"] + 1
                msg = upd.get("message") or {}
                text = (msg.get("text") or "").strip()
                chat_id = (msg.get("chat") or {}).get("id")
                if not chat_id:
                    continue
                if text.startswith("/start"):
                    _send(chat_id, hello); continue
                if EMAIL_RE.match(text):
                    email = text.lower()
                    ok = _set_user_telegram(email, chat_id)
                    _send(chat_id, "‚úÖ –ì–æ—Ç–æ–≤–æ! –°–≤—è–∑–∞–ª <b>%s</b> —Å —ç—Ç–∏–º —á–∞—Ç–æ–º." % email if ok
                                   else "‚ö†Ô∏è –ù–µ –Ω–∞—à—ë–ª e-mail <b>%s</b> –≤ —Å–ø–∏—Å–∫–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π." % email)
                else:
                    _send(chat_id, "–≠—Ç–æ –Ω–µ –ø–æ—Ö–æ–∂–µ –Ω–∞ e-mail. –ü—Ä–∏—à–ª–∏—Ç–µ –∞–¥—Ä–µ—Å –≤–∏–¥–∞ <b>user@company.com</b>.")
        except KeyboardInterrupt:
            break
        except Exception as e:
            log.warning("Loop error: %s", e); time.sleep(3)

if __name__ == "__main__":
    main()

--------------------------------------------------------------------------------
# FILE: telegram_bot\notifier.py
# SIZE: 8782 bytes | SHA256(text): e03a83684833b10d00512c5831de4d026bc0deb396c1ebde4f0530f157cc2c49
--------------------------------------------------------------------------------
# telegram_bot/notifier.py
from __future__ import annotations
import logging, time
from datetime import datetime, timezone
from typing import Dict, Optional, Tuple, List
import requests
import os

from config import (
    GOOGLE_SHEET_NAME,
    USERS_SHEET,
    TELEGRAM_BOT_TOKEN as CFG_TELEGRAM_BOT_TOKEN,
    TELEGRAM_ADMIN_CHAT_ID as CFG_TELEGRAM_ADMIN_CHAT_ID,
    TELEGRAM_BROADCAST_CHAT_ID as CFG_TELEGRAM_BROADCAST_CHAT_ID,
    TELEGRAM_MIN_INTERVAL_SEC as CFG_TELEGRAM_MIN_INTERVAL_SEC,
    TELEGRAM_SILENT as CFG_TELEGRAM_SILENT,
)

from sheets_api import SheetsAPI

log = logging.getLogger(__name__)
NOTIFICATIONS_LOG_SHEET = "NotificationsLog"


def _now_iso() -> str:
    return datetime.now(timezone.utc).astimezone().isoformat(timespec="seconds")


def _bool(v, default=False):
    if v is None:
        return default
    s = str(v).strip().lower()
    return s in ("1", "true", "yes", "y", "–¥–∞")


class TelegramNotifier:
    """
    –¢—Ä–∏ —Ç–∏–ø–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π:
      - service/admin ‚Üí TELEGRAM_ADMIN_CHAT_ID
      - personal(email) ‚Üí chat_id –∏–∑ Users.<Telegram/TelegramChatID/tg>
      - group/broadcast ‚Üí TELEGRAM_BROADCAST_CHAT_ID —Å –ø—Ä–µ—Ñ–∏–∫—Å–æ–º [–ì—Ä—É–ø–ø–∞]/[–í—Å–µ]
    –ê—É–¥–∏—Ç –≤ –ª–∏—Å—Ç NotificationsLog (—Å–æ–∑–¥–∞—ë—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏).
    """
    def __init__(
        self,
        token: Optional[str] = None,
        admin_chat_id: Optional[str] = None,
        broadcast_chat_id: Optional[str] = None,
        min_interval_sec: Optional[int] = None,
        default_silent: Optional[bool] = None,
    ):
        # –±–µ—Ä—ë–º: —è–≤–Ω—ã–π –∞—Ä–≥—É–º–µ–Ω—Ç ‚Üí config ‚Üí ENV
        self.token = (token
                      or (CFG_TELEGRAM_BOT_TOKEN or "")
                      or os.getenv("TELEGRAM_BOT_TOKEN", "")).strip()
        if not self.token:
            raise RuntimeError("TELEGRAM_BOT_TOKEN –Ω–µ –∑–∞–¥–∞–Ω.")
        self.api_url = f"https://api.telegram.org/bot{self.token}"

        self.admin_chat = str(
            admin_chat_id
            or (CFG_TELEGRAM_ADMIN_CHAT_ID or "")
            or os.getenv("TELEGRAM_ADMIN_CHAT_ID", "")
        ).strip()
        self.broadcast_chat = str(
            broadcast_chat_id
            or (CFG_TELEGRAM_BROADCAST_CHAT_ID or "")
            or os.getenv("TELEGRAM_BROADCAST_CHAT_ID", "")
        ).strip()
        self.min_interval = int(
            (min_interval_sec if min_interval_sec is not None else 0)
            or (CFG_TELEGRAM_MIN_INTERVAL_SEC if CFG_TELEGRAM_MIN_INTERVAL_SEC is not None else 0)
            or os.getenv("TELEGRAM_MIN_INTERVAL_SEC", "600")
        )
        self.default_silent = (
            _bool(CFG_TELEGRAM_SILENT)
            if default_silent is None else bool(default_silent)
        )

        self._last_sent: Dict[str, float] = {}      # –∞–Ω—Ç–∏-—Å–ø–∞–º (key -> ts)
        self._links_cache: Dict[str, str] = {}      # email -> chat_id
        self._links_ts: float = 0.0
        self._links_ttl: float = 300.0              # 5 –º–∏–Ω—É—Ç
        self._sheets: SheetsAPI | None = None

    # ---------- –ø—É–±–ª–∏—á–Ω—ã–µ API ----------
    def send_service(self, text: str, *, silent: Optional[bool] = None) -> bool:
        if not self.admin_chat:
            log.warning("TELEGRAM_ADMIN_CHAT_ID –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω (–ø–æ—Å—Ç–∞–≤—å—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è –∏–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ config.py).")
            return False
        key = f"svc:{hash(text)}"
        if self._skip_by_rate(key):
            return False
        ok, err = self._send_text(self.admin_chat, text, silent)
        self._audit("service", f"admin:{self.admin_chat}", text, ok, err)
        return ok

    def send_personal(self, email: str, text: str, *, silent: Optional[bool] = None) -> bool:
        chat_id = self._resolve_chat_id(email)
        if not chat_id:
            self._audit("personal", f"email:{email}", text, False, "chat_id not found")
            return False
        key = f"pm:{email}:{hash(text)}"
        if self._skip_by_rate(key):
            return False
        ok, err = self._send_text(chat_id, text, silent)
        self._audit("personal", f"email:{email}", text, ok, err)
        return ok

    def send_group(self, text: str, *, group: Optional[str] = None, for_all: bool = False,
                   silent: Optional[bool] = None) -> bool:
        if not self.broadcast_chat:
            log.warning("TELEGRAM_BROADCAST_CHAT_ID –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω.")
            return False
        tag = f"[{group}] " if (group and not for_all) else "[–í—Å–µ] " if for_all else ""
        payload_text = f"{tag}{text}"
        key = f"grp:{group or 'all'}:{hash(text)}"
        if self._skip_by_rate(key):
            return False
        ok, err = self._send_text(self.broadcast_chat, payload_text, silent)
        self._audit("group_all" if for_all else "group", f"chat:{self.broadcast_chat}", payload_text, ok, err)
        return ok

    # ---------- helpers ----------
    def _sheets_api(self) -> SheetsAPI:
        if self._sheets is None:
            self._sheets = SheetsAPI()
        return self._sheets

    def _skip_by_rate(self, key: str) -> bool:
        now = time.monotonic()
        last = self._last_sent.get(key, 0.0)
        if (now - last) < max(1, self.min_interval):
            log.debug("–ê–Ω—Ç–∏-—Å–ø–∞–º: –ø—Ä–æ–ø—É—Å–∫ %s", key)
            return True
        self._last_sent[key] = now
        return False

    def _send_text(self, chat_id: str, text: str, silent: Optional[bool]) -> Tuple[bool, Optional[str]]:
        payload = {
            "chat_id": chat_id,
            "text": text,
            "parse_mode": "HTML",
            "disable_notification": self.default_silent if silent is None else bool(silent),
        }
        try:
            r = requests.post(f"{self.api_url}/sendMessage", json=payload, timeout=20)
            data = r.json()
            if not data.get("ok", False):
                err = data.get("description") or r.text
                log.error("Telegram sendMessage error: %s", err)
                return False, err
            return True, None
        except Exception as e:
            log.exception("Telegram sendMessage exception: %s", e)
            return False, str(e)

    def _resolve_chat_id(self, email: str) -> Optional[str]:
        email = (email or "").strip().lower()
        links = self._load_links_cache()
        return links.get(email)

    def _load_links_cache(self) -> Dict[str, str]:
        if (time.monotonic() - self._links_ts) < self._links_ttl and self._links_cache:
            return self._links_cache
        try:
            api = self._sheets_api()
            ws = api.get_worksheet(USERS_SHEET)
            header = api._request_with_retry(ws.row_values, 1) or []
            values = api._request_with_retry(ws.get_all_values) or []
            lh = [str(h or "").strip().lower() for h in header]
            ix_email = lh.index("email") if "email" in lh else None
            ix_tg = None
            for name in ("telegram", "telegramchatid", "tg"):
                if name in lh:
                    ix_tg = lh.index(name); break
            cache: Dict[str, str] = {}
            if ix_email is not None and ix_tg is not None:
                for r in values[1:]:
                    e = (r[ix_email] if ix_email < len(r) else "").strip().lower()
                    c = (r[ix_tg] if ix_tg < len(r) else "").strip()
                    if e and c:
                        cache[e] = c
            self._links_cache, self._links_ts = cache, time.monotonic()
        except Exception as e:
            log.error("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å Users -> Telegram: %s", e)
        return self._links_cache

    def _audit(self, kind: str, target: str, text: str, ok: bool, err: Optional[str]) -> None:
        try:
            api = self._sheets_api()
            ss = api.client.open(GOOGLE_SHEET_NAME)
            titles = [w.title for w in ss.worksheets()]
            if NOTIFICATIONS_LOG_SHEET not in titles:
                ws_new = ss.add_worksheet(title=NOTIFICATIONS_LOG_SHEET, rows=2000, cols=6)
                api._request_with_retry(ws_new.update, "A1", [["Ts","Kind","Target","Status","Preview","Error"]])
            ws = ss.worksheet(NOTIFICATIONS_LOG_SHEET)
            row = [_now_iso(), kind, target, "OK" if ok else "FAIL", (text or "")[:180], (err or "")[:180]]
            api._request_with_retry(ws.append_rows, [row], value_input_option="RAW")
        except Exception as e:
            log.debug("–ê—É–¥–∏—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: %s", e)

--------------------------------------------------------------------------------
# FILE: tools\doctor.py
# SIZE: 7074 bytes | SHA256(text): 7c7ddc0de94f71a8f5f5dccc1ea06e0e47d54899fa48b80f7a02a8f096a45878
--------------------------------------------------------------------------------
# tools/doctor.py
from __future__ import annotations

import argparse
import json
import sqlite3
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, List

from config import LOG_DIR, get_credentials_file
from user_app.db_local import LocalDB
from sheets_api import sheets_api

# –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –æ–∂–∏–¥–∞–Ω–∏—è –ø–æ–¥ –≤–∞—à—É —Ñ–∞–∫—Ç–∏—á–µ—Å–∫—É—é —Å—Ö–µ–º—É:
EXPECTED = {
    "Users": ["Email", "Name", "Group"],  # –±–∞–∑–æ–≤—ã–µ –∞—Ç—Ä–∏–±—É—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    "ActiveSessions": [
        "Email", "Name", "SessionID", "LoginTime", "Status", "LogoutTime", "RemoteCommand"
        # RemoteCommandAck ‚Äî –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ–º –¥–æ–±–∞–≤–∏—Ç—å)
    ],
}


def dump_sqlite_schema(conn: sqlite3.Connection, sample_limit: int = 5) -> Dict[str, Any]:
    cur = conn.cursor()
    cur.execute("SELECT name, type, sql FROM sqlite_master WHERE type IN ('table','index','trigger') ORDER BY name;")
    items = [{"name": n, "type": t, "sql": s} for (n, t, s) in cur.fetchall()]
    tables = [i["name"] for i in items if i["type"] == "table" and not i["name"].startswith("sqlite_")]
    stats = {}
    extra = {}
    samples = {}
    for t in tables:
        try:
            cur.execute(f"SELECT COUNT(*) FROM {t}")
            stats[t] = cur.fetchone()[0]
            cur.execute(f"SELECT * FROM {t} ORDER BY ROWID DESC LIMIT {sample_limit}")
            samples[t] = cur.fetchall()
        except Exception:
            pass
    # —Å–ø–µ—Ü-–º–µ—Ç—Ä–∏–∫–∏: –Ω–µ—Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∑–∞–ø–∏—Å–∏ –≤ –æ—á–µ—Ä–µ–¥–∏/–ª–æ–≥–∞—Ö
    try:
        if "logs" in tables:
            cur.execute("SELECT COUNT(*) FROM logs WHERE synced=0")
            extra["logs_unsynced"] = cur.fetchone()[0]
        if "offline_actions" in tables:
            cur.execute("SELECT COUNT(*) FROM offline_actions WHERE status<>'synced'")
            extra["offline_actions_pending"] = cur.fetchone()[0]
    except Exception:
        pass
    return {"objects": items, "stats": stats, "samples": samples, "extra": extra}


def dump_sheets_structure() -> Dict[str, Any]:
    client = sheets_api
    book_name = "CONFIGURED"
    data: Dict[str, Any] = {"worksheets": []}
    # –ø–µ—Ä–µ—á–∏—Å–ª–∏–º –ª–∏—Å—Ç—ã –∏ –∏—Ö –∑–∞–≥–æ–ª–æ–≤–∫–∏
    titles = client.list_worksheet_titles()
    for t in titles:
        try:
            ws = client._get_ws(t)  # –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –ø–æ–º–æ—â. —Ñ—É–Ω–∫—Ü–∏—è –¥–æ–ø—É—Å—Ç–∏–º–∞ –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
            header = [h.strip() for h in ws.row_values(1)]
            data["worksheets"].append({"title": t, "header": header, "rows_hint": ws.row_count, "cols_hint": ws.col_count})
        except Exception as e:
            data["worksheets"].append({"title": t, "error": str(e)})
    # –ª—ë–≥–∫–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –æ–∂–∏–¥–∞–µ–º—ã—Ö –∫–æ–ª–æ–Ω–æ–∫
    mismatches: List[Dict[str, Any]] = []
    for w in data["worksheets"]:
        if "header" not in w:
            continue
        exp = EXPECTED.get(w["title"])
        if exp:
            missing = [x for x in exp if x not in w["header"]]
            if missing:
                mismatches.append({"sheet": w["title"], "missing": missing})
    data["expectations"] = mismatches
    return data


def dump_sheets(sample_limit: int = 3) -> Dict[str, Any]:
    out = dump_sheets_structure()
    # –¥–æ–±–∞–≤–∏–º –Ω–µ–º–Ω–æ–≥–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø—Ä–∏–º–µ—Ä–∞
    client = sheets_api
    for ws in out["worksheets"]:
        if "error" in ws:
            continue
        try:
            title = ws["title"]
            data = client.get_worksheet_data(title, limit=sample_limit)
            ws["sample"] = data
            ws["rows_count"] = len(data)
        except Exception as e:
            ws["sample_error"] = str(e)
    return out


def render_markdown(report: Dict[str, Any]) -> str:
    lines: List[str] = []
    lines.append(f"# Diagnostics Report ‚Äî {report.get('ts')}")
    lines.append("")
    lines.append("## Credentials")
    cred = report.get("credentials_file", "unknown")
    lines.append(f"- State: **{cred}**")
    lines.append("")
    # SQLite
    s = report.get("sqlite", {})
    lines.append("## SQLite")
    stats = s.get("stats", {})
    if stats:
        lines.append("| Table | Rows |")
        lines.append("|---|---:|")
        for k, v in stats.items():
            lines.append(f"| {k} | {v} |")
        lines.append("")
    # Extra metrics
    extra = s.get("extra", {})
    if extra:
        lines.append("**Extra metrics:**")
        for k, v in extra.items():
            lines.append(f"- {k}: {v}")
        lines.append("")
    # Sheets
    sh = report.get("sheets", {})
    lines.append("## Google Sheets")
    problems = sh.get("expectations", [])
    if problems:
        lines.append("**Missing columns:**")
        for p in problems:
            lines.append(f"- `{p['sheet']}`: {', '.join(p['missing'])}")
        lines.append("")
    ws = sh.get("worksheets", [])
    for w in ws:
        lines.append(f"### {w.get('title','<no title>')}")
        if "error" in w:
            lines.append(f"> Error: {w['error']}")
            continue
        header = w.get("header", [])
        lines.append("**Header:** " + ", ".join(f"`{h}`" for h in header))
        lines.append(f"**Rows:** {w.get('rows_hint', 0)}")
        sample = w.get("sample", [])
        if sample:
            lines.append("")
            lines.append("```")
            for r in sample:
                lines.append(str(r))
            lines.append("```")
        lines.append("")
    return "\n".join(lines)


def run(out: Path) -> None:
    report: Dict[str, Any] = {
        "ts": datetime.now().isoformat(timespec="seconds"),
        "log_dir": str(LOG_DIR),
    }
    # creds check
    try:
        cf = get_credentials_file()
        report["credentials_file"] = str(cf)
    except Exception as e:
        report["credentials_error"] = str(e)

    # DB
    db = LocalDB()
    conn = db.conn  # type: ignore
    report["sqlite"] = dump_sqlite_schema(conn)

    # Sheets
    try:
        report["sheets"] = dump_sheets_structure()
    except Exception as e:
        report["sheets_error"] = str(e)

    out_path = Path(out)
    if out_path.suffix.lower() == ".md":
        out_path.write_text(render_markdown(report), encoding="utf-8")
    else:
        out_path.write_text(json.dumps(report, ensure_ascii=False, indent=2), encoding="utf-8")
    print(f"OK: written {out_path}")


def main():
    ap = argparse.ArgumentParser(description="WorkTimeTracker Doctor: –ª–æ–∫–∞–ª—å–Ω–∞—è –ë–î + —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ Google Sheets + –±—ã—Å—Ç—Ä–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è.")
    ap.add_argument("-o", "--output", default="diagnostics_report.json", help="–ü—É—Ç—å –∫ –∏—Ç–æ–≥–æ–≤–æ–º—É –æ—Ç—á—ë—Ç—É (JSON –∏–ª–∏ MD).")
    args = ap.parse_args()
    run(Path(args.output))


if __name__ == "__main__":
    main()

--------------------------------------------------------------------------------
# FILE: tools\tg_envcheck.py
# SIZE: 934 bytes | SHA256(text): c440e8216adcd0d3c73e5dcc8711572438f554daeea6542d1559dac8494c05e7
--------------------------------------------------------------------------------
from __future__ import annotations
import os
from config import (
    TELEGRAM_BOT_TOKEN as CFG_TELEGRAM_BOT_TOKEN,
    TELEGRAM_ADMIN_CHAT_ID as CFG_TELEGRAM_ADMIN_CHAT_ID,
    TELEGRAM_BROADCAST_CHAT_ID as CFG_TELEGRAM_BROADCAST_CHAT_ID,
)

def _mask(s: str, keep=6) -> str:
    if not s:
        return ""
    s = str(s)
    return s[:keep] + "..." if len(s) > keep else s

def main():
    print("=== TELEGRAM effective settings ===")
    tok = (CFG_TELEGRAM_BOT_TOKEN or os.getenv("TELEGRAM_BOT_TOKEN", ""))
    adm = (CFG_TELEGRAM_ADMIN_CHAT_ID or os.getenv("TELEGRAM_ADMIN_CHAT_ID", ""))
    brc = (CFG_TELEGRAM_BROADCAST_CHAT_ID or os.getenv("TELEGRAM_BROADCAST_CHAT_ID", ""))
    print("TELEGRAM_BOT_TOKEN:", "set" if tok else "EMPTY", _mask(tok))
    print("TELEGRAM_ADMIN_CHAT_ID:", adm or "<empty>")
    print("TELEGRAM_BROADCAST_CHAT_ID:", brc or "<empty>")

if __name__ == "__main__":
    main()

--------------------------------------------------------------------------------
# FILE: tools\tg_send.py
# SIZE: 1398 bytes | SHA256(text): 37dc26d5f8c933c8d6ac0d272e5fda8d8d6fff06f3ca056c2e09cabd7114dd20
--------------------------------------------------------------------------------
# tools/tg_send.py
from __future__ import annotations
import argparse, logging
from telegram_bot.notifier import TelegramNotifier

logging.basicConfig(level=logging.INFO)

def main():
    ap = argparse.ArgumentParser("–û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –≤ Telegram")
    ap.add_argument("--type", choices=["service", "personal", "group"], required=True)
    ap.add_argument("--email", help="–¥–ª—è personal: e-mail —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞")
    ap.add_argument("--group", help="–¥–ª—è group: –ø–æ–º–µ—Ç–∫–∞ –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏")
    ap.add_argument("--all", action="store_true", help="–¥–ª—è group: –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤—Å–µ–º (–±–µ–∑ –º–µ—Ç–∫–∏)")
    ap.add_argument("--text", required=True, help="—Ç–µ–∫—Å—Ç (HTML –¥–æ–ø—É—Å—Ç–∏–º)")
    ap.add_argument("--silent", action="store_true", help="—Ç–∏—Ö–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ")
    args = ap.parse_args()

    n = TelegramNotifier()
    if args.type == "service":
        ok = n.send_service(args.text, silent=args.silent)
    elif args.type == "personal":
        if not args.email: ap.error("--email –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è personal")
        ok = n.send_personal(args.email, args.text, silent=args.silent)
    else:
        ok = n.send_group(args.text, group=None if args.all else args.group, for_all=args.all, silent=args.silent)
    print("OK" if ok else "FAIL")

if __name__ == "__main__":
    main()

--------------------------------------------------------------------------------
# FILE: user_app\__init__.py
# SIZE: 0 bytes | SHA256(text): e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
# FILE: user_app\api.py
# SIZE: 1986 bytes | SHA256(text): 66effaf4453efe34f32ee113e4dfb03709c5c44d2bb0eb2855f898de8e4311d2
--------------------------------------------------------------------------------
# user_app/api.py
from __future__ import annotations
from typing import Optional, Dict, List
from sheets_api import SheetsAPI
from datetime import datetime, timezone
import uuid

class UserNotFound(Exception):
    pass

class UserAPI:
    """
    –°–µ—Ä–≤–∏—Å-—Å–ª–æ–π user_app: –≤—Å—è —Ä–∞–±–æ—Ç–∞ —Å Google Sheets —Ç–æ–ª—å–∫–æ —á–µ—Ä–µ–∑ SheetsAPI.
    """
    def __init__(self, sheets: Optional[SheetsAPI] = None):
        self.sheets = sheets or SheetsAPI()

    # ---- Users ----
    def find_user(self, email: str) -> Dict:
        email = (email or "").strip().lower()
        user = self.sheets.get_user_by_email(email)
        if not user:
            raise UserNotFound(email)
        return user

    # ---- Sessions ----
    def start_session(self, email: str, name: str) -> str:
        """
        –°–æ–∑–¥–∞—ë—Ç –∑–∞–ø–∏—Å—å –≤ ActiveSessions (Status=active).
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç session_id.
        """
        session_id = str(uuid.uuid4())
        self.sheets.set_active_session(
            email=email,
            name=name,
            session_id=session_id,
            login_time=datetime.now(timezone.utc).isoformat()
        )
        return session_id

    def finish_session(self, email: str, session_id: str) -> bool:
        return self.sheets.finish_active_session(email=email, session_id=session_id)

    def force_logout_if_needed(self, email: str, session_id: str) -> bool:
        """
        –ü—É–ª–∏–Ω–≥ —Å—Ç–∞—Ç—É—Å–∞: –µ—Å–ª–∏ –∞–¥–º–∏–Ω –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ —Ä–∞–∑–ª–æ–≥–∏–Ω–∏–ª (Status=kicked) ‚Äî –≤–µ—Ä–Ω—ë–º True.
        """
        st = self.sheets.check_user_session_status(email=email, session_id=session_id)
        return st in ("kicked", "finished")

    # ---- WorkLog ----
    def log_actions(self, actions: List[Dict], email: str, user_group: Optional[str] = None) -> bool:
        return self.sheets.log_user_actions(actions, email=email, user_group=user_group)

--------------------------------------------------------------------------------
# FILE: user_app\db_local.py
# SIZE: 20676 bytes | SHA256(text): 07a1b7e672b1fee5fac5470839188a10ed65d53bb61ec779836e57130b65fc57
--------------------------------------------------------------------------------
# user_app/db_local.py
from __future__ import annotations

import sqlite3
import threading
from pathlib import Path
from datetime import datetime, timedelta, timezone
from typing import Optional, Dict, Any, Iterable, Tuple, List
import logging

from config import LOCAL_DB_PATH, MAX_COMMENT_LENGTH, MAX_HISTORY_DAYS
from user_app.db_migrations import apply_migrations

logger = logging.getLogger(__name__)


class LocalDBError(Exception):
    """–û—à–∏–±–∫–∏ –ª–æ–∫–∞–ª—å–Ω–æ–π –ë–î."""


class LocalDB:
    """
    –õ–æ–∫–∞–ª—å–Ω–∞—è –ë–î —Å –ø–æ–ª–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å—é —Å–æ —Å—Ç–∞—Ä—ã–º –∫–æ–¥–æ–º.
    –ê–≤—Ç–æ-–æ—Ç–∫—Ä—ã—Ç–∏–µ, —Å–∞–º–æ–≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ, –±–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ.
    """

    def __init__(self, db_path: Optional[str] = None) -> None:
        self.conn: Optional[sqlite3.Connection] = None
        self.db_path: Optional[Path] = None
        self._lock = threading.RLock()
        self._opened_path: Optional[Path] = None

        # –∞–≤—Ç–æ–∑–∞–≥—Ä—É–∑–∫–∞ –∫–∞–∫ —Ä–∞–Ω—å—à–µ
        self._bootstrap_open(db_path or str(LOCAL_DB_PATH))

    # ------------------------------------------------------------------ #
    # Bootstrap & lifecycle
    # ------------------------------------------------------------------ #
    def _bootstrap_open(self, primary_path: str) -> None:
        """–ü—Ä–æ–±—É–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –ø—É—Ç—å, –∑–∞—Ç–µ–º –¥–æ–º–∞—à–Ω–∏–π, –∑–∞—Ç–µ–º ':memory:'."""
        try:
            self.open(primary_path)
            return
        except Exception as e:
            logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –ë–î –ø–æ –æ—Å–Ω–æ–≤–Ω–æ–º—É –ø—É—Ç–∏ '%s': %s", primary_path, e)

        home_fallback = Path.home() / "WorkTimeTracker" / "local_backup.db"
        try:
            self.open(str(home_fallback))
            logger.warning("–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ä–µ–∑–µ—Ä–≤–Ω—ã–π –ø—É—Ç—å –ª–æ–∫–∞–ª—å–Ω–æ–π –ë–î: %s", home_fallback)
            return
        except Exception as e:
            logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —Ä–µ–∑–µ—Ä–≤–Ω—É—é –ë–î '%s': %s", home_fallback, e)

        # –∫—Ä–∞–π–Ω–∏–π —Å–ª—É—á–∞–π ‚Äî in-memory (—á—Ç–æ–±—ã UI –Ω–µ –ø–∞–¥–∞–ª)
        with self._lock:
            self.db_path = None
            self.conn = sqlite3.connect(":memory:", timeout=10, check_same_thread=False)
            self.conn.execute("PRAGMA journal_mode=MEMORY;")
            self.conn.execute("PRAGMA synchronous=OFF;")
            self.conn.execute("PRAGMA foreign_keys=ON;")
            self._ensure_schema()
            self._opened_path = None
            logger.warning("–õ–æ–∫–∞–ª—å–Ω–∞—è –ë–î –∑–∞–ø—É—â–µ–Ω–∞ –≤ —Ä–µ–∂–∏–º–µ ':memory:' (–±–µ–∑ –∑–∞–ø–∏—Å–∏ –Ω–∞ –¥–∏—Å–∫).")

    def open(self, db_path: str) -> None:
        with self._lock:
            self.db_path = Path(db_path).resolve()
            self.db_path.parent.mkdir(parents=True, exist_ok=True)

            logger.debug("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è LocalDB –ø–æ –ø—É—Ç–∏: %s", self.db_path)
            try:
                self.conn = sqlite3.connect(str(self.db_path), timeout=10, check_same_thread=False)
                self.conn.execute("PRAGMA journal_mode=WAL;")
                self.conn.execute("PRAGMA synchronous=NORMAL;")
                self.conn.execute("PRAGMA foreign_keys=ON;")
                self._ensure_schema()
                
                # –º–∏–≥—Ä–∞—Ü–∏–∏ –∏–Ω–¥–µ–∫—Å–æ–≤ (–±—ã—Å—Ç—Ä–æ –∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ)
                try:
                    apply_migrations(self.conn)
                    logger.info("DB migrations (indexes) applied")
                except Exception as e:
                    logger.warning("DB migrations failed: %s", e)
                
                self._opened_path = self.db_path
                # –ø—Ä–æ—Ñ–∏–ª–∞–∫—Ç–∏–∫–∞
                self.cleanup_old_action_logs(days=MAX_HISTORY_DAYS)
                logger.info("–õ–æ–∫–∞–ª—å–Ω–∞—è –ë–î —É—Å–ø–µ—à–Ω–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞: %s", self.db_path)
            except sqlite3.Error as e:
                self.conn = None
                raise LocalDBError(f"–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ë–î: {e}")

    def _ensure_open(self) -> None:
        if self.conn is not None:
            return
        base = str(self._opened_path or self.db_path or LOCAL_DB_PATH)
        try:
            self.open(base)
        except Exception as e:
            logger.error("–ü–æ–≤—Ç–æ—Ä–Ω–æ–µ –æ—Ç–∫—Ä—ã—Ç–∏–µ –ë–î –ø–æ '%s' –Ω–µ —É–¥–∞–ª–æ—Å—å: %s", base, e)
            self._bootstrap_open(base)

    def close(self) -> None:
        with self._lock:
            conn = getattr(self, "conn", None)
            if conn is not None:
                try:
                    conn.commit()
                except Exception:
                    pass
                try:
                    conn.close()
                except Exception:
                    pass
            self.conn = None
            logger.info("–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –ª–æ–∫–∞–ª—å–Ω–æ–π –ë–î –∑–∞–∫—Ä—ã—Ç–æ")

    def __del__(self):
        try:
            self.close()
        except Exception:
            pass

    # ------------------------------------------------------------------ #
    # Schema & migration
    # ------------------------------------------------------------------ #
    def _ensure_schema(self) -> None:
        assert self.conn is not None, "–ë–∞–∑–∞ –Ω–µ –æ—Ç–∫—Ä—ã—Ç–∞"
        cur = self.conn.cursor()

        # –ï—Å–ª–∏ –µ—Å—Ç—å —Å—Ç–∞—Ä–∞—è —Ç–∞–±–ª–∏—Ü–∞ logs (–±–µ–∑ –Ω—É–∂–Ω—ã—Ö –∫–æ–ª–æ–Ω–æ–∫) ‚Äî –ø–µ—Ä–µ–∏–º–µ–Ω—É–µ–º
        cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='logs';")
        if cur.fetchone():
            cur.execute("PRAGMA table_info(logs);")
            cols = [r[1] for r in cur.fetchall()]
            required = {'session_id', 'email', 'name', 'action_type', 'timestamp'}
            if not required.issubset(set(cols)):
                legacy_name = f"app_logs_legacy_{datetime.now().strftime('%Y%m%d%H%M%S')}"
                cur.execute(f"ALTER TABLE logs RENAME TO {legacy_name};")
                logger.warning("–û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ —Å—Ç–∞—Ä–∞—è —Å—Ö–µ–º–∞ 'logs' ‚Äî –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∞ –≤ %s", legacy_name)

        # –û—Å–Ω–æ–≤–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ –¥–µ–π—Å—Ç–≤–∏–π
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                session_id TEXT NOT NULL,
                email TEXT NOT NULL,
                name TEXT NOT NULL,
                status TEXT,
                action_type TEXT NOT NULL,
                comment TEXT,
                timestamp TEXT NOT NULL,
                synced INTEGER DEFAULT 0,
                sync_attempts INTEGER DEFAULT 0,
                last_sync_attempt TEXT,
                priority INTEGER DEFAULT 1,
                status_start_time TEXT,
                status_end_time TEXT,
                reason TEXT,
                user_group TEXT
            );
            """
        )

        # –ò–Ω–¥–µ–∫—Å—ã (–±–µ–∑–æ–ø–∞—Å–Ω–æ: –ø—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫–æ–ª–æ–Ω–æ–∫)
        cur.execute("PRAGMA table_info(logs);")
        cols = {r[1] for r in cur.fetchall()}
        if 'email' in cols:
            cur.execute("CREATE INDEX IF NOT EXISTS idx_logs_email ON logs(email);")
        if 'synced' in cols:
            cur.execute("CREATE INDEX IF NOT EXISTS idx_logs_synced ON logs(synced);")
        if 'timestamp' in cols:
            cur.execute("CREATE INDEX IF NOT EXISTS idx_logs_timestamp ON logs(timestamp);")
        if 'session_id' in cols:
            cur.execute("CREATE INDEX IF NOT EXISTS idx_logs_session ON logs(session_id);")

        # –¢—Ä–∏–≥–≥–µ—Ä—ã
        cur.execute(
            f"""
            CREATE TRIGGER IF NOT EXISTS check_comment_length
            BEFORE INSERT ON logs
            FOR EACH ROW
            WHEN length(NEW.comment) > {int(MAX_COMMENT_LENGTH)}
            BEGIN
                SELECT RAISE(ABORT, 'Comment too long');
            END;
            """
        )
        cur.execute(
            """
            CREATE TRIGGER IF NOT EXISTS prevent_duplicate_logout
            BEFORE INSERT ON logs
            FOR EACH ROW
            WHEN LOWER(NEW.action_type) = 'logout' AND EXISTS (
                SELECT 1 FROM logs
                WHERE session_id = NEW.session_id
                  AND LOWER(action_type) = 'logout'
                  AND timestamp > datetime('now', '-5 minutes')
            )
            BEGIN
                SELECT RAISE(ABORT, 'Duplicate LOGOUT action');
            END;
            """
        )

        # –î–∏–∞–≥–Ω–æ—Å—Ç–∏—á–µ—Å–∫–∏–µ –ª–æ–≥–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS app_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ts TEXT NOT NULL,
                level TEXT NOT NULL,
                message TEXT NOT NULL
            );
            """
        )
        cur.execute("CREATE INDEX IF NOT EXISTS idx_app_logs_ts ON app_logs(ts);")

        self.conn.commit()

    # ------------------------------------------------------------------ #
    # App logs (–¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞)
    # ------------------------------------------------------------------ #
    def add_log(self, level: str, message: str) -> int:
        self._ensure_open()
        if self.conn is None:
            return -1
        ts = datetime.now(timezone.utc).isoformat()
        with self._lock:
            cur = self.conn.cursor()
            cur.execute("INSERT INTO app_logs (ts, level, message) VALUES (?, ?, ?)", (ts, level, message))
            self.conn.commit()
            return int(cur.lastrowid)

    def cleanup_old_logs(self, days: int = 30) -> int:
        """–û—á–∏—Å—Ç–∫–∞ app_logs —Å—Ç–∞—Ä—à–µ N –¥–Ω–µ–π (—Å–æ–≤–º. —Å–æ —Å—Ç–∞—Ä—ã–º –≤—ã–∑–æ–≤–æ–º)."""
        self._ensure_open()
        if self.conn is None:
            return 0
        cutoff = (datetime.now(timezone.utc) - timedelta(days=days)).isoformat()
        with self._lock:
            cur = self.conn.cursor()
            cur.execute("SELECT COUNT(*) FROM app_logs WHERE ts < ?", (cutoff,))
            cnt = int(cur.fetchone()[0] or 0)
            cur.execute("DELETE FROM app_logs WHERE ts < ?", (cutoff,))
            self.conn.commit()
            return cnt

    def cleanup_old_action_logs(self, days: int = 30) -> int:
        self._ensure_open()
        if self.conn is None:
            return 0
        cutoff = (datetime.now(timezone.utc) - timedelta(days=days)).isoformat()
        with self._lock:
            cur = self.conn.cursor()
            cur.execute("SELECT COUNT(*) FROM logs WHERE timestamp < ?", (cutoff,))
            cnt = int(cur.fetchone()[0] or 0)
            cur.execute("DELETE FROM logs WHERE timestamp < ?", (cutoff,))
            self.conn.commit()
            return cnt

    # ------------------------------------------------------------------ #
    # Action logs (—Ç–æ, —á—Ç–æ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç—Å—è)
    # ------------------------------------------------------------------ #
    def _gen_session_id(self, email: str) -> str:
        return f"{(email or '')[:8]}_{datetime.now().strftime('%Y%m%d%H%M%S')}"

    def log_action(
        self,
        email: str,
        name: str,
        status: Optional[str],
        action_type: str,
        comment: Optional[str] = None,
        immediate_sync: bool = False,
        priority: int = 1,
        session_id: Optional[str] = None,
        status_start_time: Optional[str] = None,
        status_end_time: Optional[str] = None,
        reason: Optional[str] = None,
        user_group: Optional[str] = None,
    ) -> int:
        if not email or not name or not action_type:
            raise LocalDBError("–û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è –Ω–µ –∑–∞–ø–æ–ª–Ω–µ–Ω—ã (email/name/action_type)")

        if comment and len(comment) > MAX_COMMENT_LENGTH:
            comment = comment[:MAX_COMMENT_LENGTH]

        ts = datetime.now(timezone.utc).isoformat()
        session_id = session_id or self._gen_session_id(email)
        prio = max(1, min(3, int(priority or 1)))

        self._ensure_open()
        if self.conn is None:
            raise LocalDBError("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –ª–æ–∫–∞–ª—å–Ω—É—é –ë–î")

        try:
            with self._lock:
                cur = self.conn.cursor()
                cur.execute(
                    """
                    INSERT INTO logs
                    (email, name, status, action_type, comment, timestamp, priority,
                     session_id, status_start_time, status_end_time, reason, user_group)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                    """,
                    (
                        email.strip(),
                        name.strip(),
                        status,
                        action_type,
                        comment,
                        ts,
                        prio,
                        session_id,
                        status_start_time,
                        status_end_time,
                        reason,
                        user_group,
                    ),
                )
                self.conn.commit()
                return int(cur.lastrowid)
        except sqlite3.Error as e:
            if "Duplicate LOGOUT action" in str(e):
                logger.warning("–ü–æ–ø—ã—Ç–∫–∞ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è LOGOUT (session_id=%s)", session_id)
                return -1
            raise LocalDBError(f"–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏ –≤ –ª–æ–≥: {e}")

    def get_action_by_id(self, action_id: int) -> Optional[Tuple]:
        """–ù—É–∂–µ–Ω GUI –¥–ª—è –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ–¥–Ω–æ–π –∑–∞–ø–∏—Å–∏."""
        self._ensure_open()
        if self.conn is None:
            return None
        with self._lock:
            cur = self.conn.cursor()
            cur.execute("SELECT * FROM logs WHERE id = ?", (int(action_id),))
            return cur.fetchone()

    def get_unsynced_actions(self, limit: int = 100) -> List[Tuple]:
        self._ensure_open()
        if self.conn is None:
            return []
        with self._lock:
            cur = self.conn.cursor()
            cur.execute(
                """
                SELECT id, email, name, status, action_type, comment, timestamp,
                       session_id, status_start_time, status_end_time, reason, user_group
                  FROM logs
                 WHERE synced = 0
              ORDER BY priority DESC, timestamp ASC
                 LIMIT ?
                """,
                (int(limit),),
            )
            return list(cur.fetchall())

    def get_unsynced_count(self) -> int:
        """–ù—É–∂–µ–Ω –∞–≤—Ç–æ-—Å–∏–Ω—Ö—É –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –æ—á–µ—Ä–µ–¥–∏."""
        self._ensure_open()
        if self.conn is None:
            return 0
        with self._lock:
            cur = self.conn.cursor()
            cur.execute("SELECT COUNT(*) FROM logs WHERE synced = 0;")
            row = cur.fetchone()
            return int(row[0] or 0)

    def mark_actions_synced(self, ids: List[int]) -> None:
        if not ids:
            return
        self._ensure_open()
        if self.conn is None:
            return
        with self._lock:
            cur = self.conn.cursor()
            placeholders = ",".join(["?"] * len(ids))
            cur.execute(
                f"""
                UPDATE logs
                   SET synced = 1,
                       sync_attempts = sync_attempts + 1,
                       last_sync_attempt = ?
                 WHERE id IN ({placeholders})
                """,
                [datetime.now(timezone.utc).isoformat(), *ids],
            )
            self.conn.commit()

    def check_existing_logout(self, email: str, session_id: Optional[str] = None) -> bool:
        self._ensure_open()
        if self.conn is None:
            return False
        with self._lock:
            cur = self.conn.cursor()
            if session_id:
                cur.execute(
                    "SELECT COUNT(*) FROM logs WHERE email=? AND session_id=? AND LOWER(action_type)='logout'",
                    (email, session_id),
                )
            else:
                cur.execute(
                    "SELECT COUNT(*) FROM logs WHERE email=? AND LOWER(action_type)='logout'",
                    (email,),
                )
            return (cur.fetchone()[0] or 0) > 0

    def finish_last_status(self, email: str, session_id: str) -> Optional[int]:
        self._ensure_open()
        if self.conn is None:
            return None
        with self._lock:
            cur = self.conn.cursor()
            cur.execute(
                """
                SELECT id FROM logs
                 WHERE email=? AND session_id=? AND status_end_time IS NULL
                   AND (action_type='STATUS_CHANGE' OR action_type='LOGIN')
              ORDER BY id DESC LIMIT 1
                """,
                (email, session_id),
            )
            row = cur.fetchone()
            if not row:
                return None
            rid = int(row[0])
            cur.execute(
                "UPDATE logs SET status_end_time=? WHERE id=?",
                (datetime.now(timezone.utc).isoformat(), rid),
            )
            self.conn.commit()
            return rid

    def get_last_unfinished_session(self, email: str) -> Optional[Dict[str, Any]]:
        self._ensure_open()
        if self.conn is None:
            return None
        with self._lock:
            cur = self.conn.cursor()
            cur.execute(
                """
                SELECT session_id, timestamp
                  FROM logs
                 WHERE email=? AND action_type='LOGIN'
                   AND session_id NOT IN (
                        SELECT session_id FROM logs
                         WHERE email=? AND LOWER(action_type)='logout'
                   )
              ORDER BY timestamp DESC
                 LIMIT 1
                """,
                (email, email),
            )
            row = cur.fetchone()
            return {"session_id": row[0], "timestamp": row[1]} if row else None

    def get_active_session(self, email: str) -> Optional[Dict[str, Any]]:
        return self.get_last_unfinished_session(email)

    def get_current_user_email(self) -> Optional[str]:
        self._ensure_open()
        if self.conn is None:
            return None
        with self._lock:
            cur = self.conn.cursor()
            cur.execute(
                """
                SELECT email
                  FROM logs
                 WHERE status_end_time IS NULL
                   AND action_type IN ('LOGIN','STATUS_CHANGE')
              ORDER BY id DESC
                 LIMIT 1
                """
            )
            row = cur.fetchone()
            return row[0] if row else None


# –°–∏–Ω–≥–ª—Ç–æ–Ω (–ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏)
_DB_SINGLETON: Optional[LocalDB] = None
_SINGLETON_LOCK = threading.Lock()

def get_db() -> LocalDB:
    global _DB_SINGLETON
    if _DB_SINGLETON is None:
        with _SINGLETON_LOCK:
            if _DB_SINGLETON is None:
                _DB_SINGLETON = LocalDB(str(LOCAL_DB_PATH))
    return _DB_SINGLETON


if __name__ == "__main__":
    import argparse

    ap = argparse.ArgumentParser(description="LocalDB helper")
    ap.add_argument("--path", type=str, default=str(LOCAL_DB_PATH))
    ap.add_argument("--add-log", type=str, default=None, help="–î–æ–±–∞–≤–∏—Ç—å app_log (level:msg)")
    ap.add_argument("--cleanup-days", type=int, default=None, help="–£–¥–∞–ª–∏—Ç—å app_logs —Å—Ç–∞—Ä—à–µ N –¥–Ω–µ–π")
    args = ap.parse_args()

    db = LocalDB(args.path)
    if args.add_log:
        try:
            level, msg = args.add_log.split(":", 1)
        except Exception:
            level, msg = "INFO", args.add_log
        rid = db.add_log(level, msg)
        print(f"Inserted app_log id={rid}")

    if args.cleanup_days is not None:
        cnt = db.cleanup_old_logs(days=args.cleanup_days)
        print(f"Deleted {cnt} old app_log rows")

    db.close()

--------------------------------------------------------------------------------
# FILE: user_app\db_migrations.py
# SIZE: 1215 bytes | SHA256(text): 4552095da96ffb8e4de2e3a02f4af41a430ec59bf558e9a26988de74623a6b29
--------------------------------------------------------------------------------
# user_app/db_migrations.py
from __future__ import annotations
import sqlite3
from typing import Iterable

DDL: Iterable[str] = [
    # ActiveSessions: —É—Å–∫–æ—Ä—è–µ–º –ø–æ–∏—Å–∫ –ø–æ e-mail/—Å–µ—Å—Å–∏–∏/—Å—Ç–∞—Ç—É—Å—É
    "CREATE INDEX IF NOT EXISTS idx_active_email_session ON ActiveSessions(Email, SessionID);",
    "CREATE INDEX IF NOT EXISTS idx_active_status ON ActiveSessions(Status);",

    # WorkLog: –ø–æ –æ–ø—ã—Ç—É ‚Äî —Ñ–∏–ª—å—Ç—Ä—ã –ø–æ Email/Timestamp/SessionID
    "CREATE INDEX IF NOT EXISTS idx_worklog_email_ts ON WorkLog(Email, Timestamp);",
    "CREATE INDEX IF NOT EXISTS idx_worklog_session ON WorkLog(SessionID);",

    # ActionLogs/Queue (–µ—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å –æ—á–µ—Ä–µ–¥—å –∏–ª–∏ —Ñ–ª–∞–≥ synced)
    "CREATE INDEX IF NOT EXISTS idx_actions_synced ON ActionLogs(Synced, CreatedAt);",
]

def apply_migrations(conn: sqlite3.Connection) -> None:
    cur = conn.cursor()
    for sql in DDL:
        try:
            cur.execute(sql)
        except Exception as e:
            # –Ω–µ –≤–∞–ª–∏–º –º–∏–≥—Ä–∞—Ü–∏—é, –ø—Ä–æ—Å—Ç–æ –ø–∏—à–µ–º –≤ –ª–æ–≥ —á–µ—Ä–µ–∑ pragma user_version –ø–æ–∑–∂–µ –ø—Ä–∏ —Ä–∞–∑–≤–∏—Ç–∏–∏ —Å—Ö–µ–º—ã
            pass
    conn.commit()

--------------------------------------------------------------------------------
# FILE: user_app\gui.py
# SIZE: 28195 bytes | SHA256(text): 563e907196e31a2bac6583f45b370a77ed13816e3a486610582c427a38858795
--------------------------------------------------------------------------------
import sys
import os
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Optional, Callable
import threading

PROJECT_ROOT = Path(__file__).resolve().parent.parent
sys.path.insert(0, str(PROJECT_ROOT))

from config import STATUSES, STATUS_GROUPS, MAX_COMMENT_LENGTH
from sheets_api import sheets_api
from user_app.db_local import LocalDB, LocalDBError

try:
    from sync.notifications import Notifier
except ImportError:
    try:
        from .sync.notifications import Notifier
    except ImportError:
        from notifications import Notifier

from PyQt5.QtWidgets import (
    QWidget, QLabel, QPushButton, QVBoxLayout,
    QHBoxLayout, QMessageBox, QTextEdit,
    QSizePolicy, QApplication
)
from PyQt5.QtCore import QTimer, Qt, pyqtSignal
from PyQt5.QtGui import QFont, QPixmap, QIcon

logger = logging.getLogger(__name__)

class EmployeeApp(QWidget):
    status_changed = pyqtSignal(str)
    app_closed = pyqtSignal(str)

    def __init__(
        self,
        email: str,
        name: str,
        role: str = "—Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç",
        group: str = "",
        shift_hours: str = "8 —á–∞—Å–æ–≤",
        telegram_login: str = "",
        on_logout_callback: Optional[Callable] = None,
        session_id: Optional[str] = None,
        login_was_performed: bool = True
    ):
        super().__init__()
        self.email = email
        self.name = name
        self.role = role
        self.group = group
        self.shift_hours = shift_hours
        self.telegram_login = telegram_login
        self.on_logout_callback = on_logout_callback

        self.current_status = "–í —Ä–∞–±–æ—Ç–µ"
        self.status_start_time = datetime.now()
        self.shift_start_time = datetime.now()
        self.last_sync_time = None
        self.shift_ended = False

        # –õ–æ–≥–∏–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è: None, "admin_logout", "user_close", "auto_logout"
        self._closing_reason = None

        if session_id is not None:
            self.session_id = session_id
            self._continue_existing_session = True
        else:
            self.session_id = self._generate_session_id()
            self._continue_existing_session = False
        self.status_buttons = {}

        self.login_was_performed = login_was_performed

        self._init_db()
        self._init_ui()
        self._init_timers()
        self._init_shift_check_timer()

    def get_user(self):
        return {
            "Email": self.email,
            "Name": self.name,
            "Role": self.role,
            "Telegram": self.telegram_login,
            "ShiftHours": self.shift_hours,
            "Group": self.group,
        }

    def _generate_session_id(self) -> str:
        return f"{self.email[:8]}_{datetime.now().strftime('%Y%m%d%H%M%S')}"

    def _make_action_payload_from_row(self, row):
        # –ü–æ—Ä—è–¥–æ–∫ —Å—Ç–æ–ª–±—Ü–æ–≤ –≤ logs:
        # 0:id 1:session_id 2:email 3:name 4:status 5:action_type 6:comment
        # 7:timestamp 8:synced 9:sync_attempts 10:last_sync_attempt 11:priority
        # 12:status_start_time 13:status_end_time 14:reason 15:user_group
        return {
            "session_id": row[1],
            "email": row[2],
            "name": row[3],
            "status": row[4],
            "action_type": row[5],
            "comment": row[6],
            "timestamp": row[7],
            "status_start_time": row[12],
            "status_end_time": row[13],
            "reason": row[14] if len(row) > 14 else None,
        }

    def _send_action_to_sheets(self, record_id, user_group=None):
        threading.Thread(target=self._send_action_to_sheets_worker, args=(record_id, user_group), daemon=True).start()

    def _send_action_to_sheets_worker(self, record_id, user_group=None):
        try:
            row = self.db.get_action_by_id(record_id)
            if not row:
                logger.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –∑–∞–ø–∏—Å—å —Å id={record_id} –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ Sheets")
                return

            action = self._make_action_payload_from_row(row)
            # –í–ê–ñ–ù–û: —Å–Ω–∞—á–∞–ª–∞ actions (—Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤–∞—Ä–µ–π), –∑–∞—Ç–µ–º email
            ok = sheets_api.log_user_actions([action], action["email"], user_group=user_group or self.group)
            if ok:
                self.db.mark_actions_synced([record_id])
            else:
                logger.warning("Sheets: log_user_actions –≤–µ—Ä–Ω—É–ª False ‚Äî –æ—Å—Ç–∞–≤–ª—è—é –∑–∞–ø–∏—Å—å –Ω–µ—Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–π")
        except Exception as e:
            logger.warning(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –¥–µ–π—Å—Ç–≤–∏—è –≤ Google Sheets: {e}")
            Notifier.show("–û—Ñ—Ñ–ª–∞–π–Ω —Ä–µ–∂–∏–º", "–î–∞–Ω–Ω—ã–µ –±—É–¥—É—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –ø—Ä–∏ –ø–æ—è–≤–ª–µ–Ω–∏–∏ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞.")

    def _finish_and_send_previous_status(self):
        prev_id = self.db.finish_last_status(self.email, self.session_id)
        if prev_id:
            threading.Thread(target=self._finish_and_send_previous_status_worker, args=(prev_id,), daemon=True).start()

    def _finish_and_send_previous_status_worker(self, prev_id):
        row = self.db.get_action_by_id(prev_id)
        if not row:
            return
        try:
            action = self._make_action_payload_from_row(row)
            ok = sheets_api.log_user_actions([action], action["email"], user_group=self.group)
            if ok:
                self.db.mark_actions_synced([prev_id])
            else:
                logger.warning("Sheets: log_user_actions –≤–µ—Ä–Ω—É–ª False ‚Äî –æ—Å—Ç–∞–≤–ª—è—é –∑–∞–ø–∏—Å—å –Ω–µ—Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–π")
        except Exception as e:
            logger.warning(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∑–∞–≤–µ—Ä—à—ë–Ω–Ω–æ–≥–æ —Å—Ç–∞—Ç—É—Å–∞ –≤ Sheets: {e}")
            Notifier.show("–û—Ñ—Ñ–ª–∞–π–Ω —Ä–µ–∂–∏–º", "–ü—Ä–µ–¥—ã–¥—É—â–∏–π —Å—Ç–∞—Ç—É—Å –±—É–¥–µ—Ç —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω –ø–æ–∑–∂–µ.")

    def _init_db(self):
        try:
            self.db = LocalDB()
            if self.login_was_performed:
                now = datetime.now().isoformat()
                record_id = self.db.log_action(
                    email=self.email,
                    name=self.name,
                    status=self.current_status,
                    action_type="LOGIN",
                    comment="–ù–∞—á–∞–ª–æ —Å–º–µ–Ω—ã",
                    immediate_sync=False,
                    session_id=self.session_id,
                    status_start_time=now,
                    status_end_time=None,
                    reason=None
                )
                self.status_start_time = datetime.fromisoformat(now)
                self._send_action_to_sheets(record_id)
        except LocalDBError as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ë–î: {e}")
            QMessageBox.critical(self, "–û—à–∏–±–∫–∞", "–ù–µ —É–¥–∞–ª–æ—Å—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –ª–æ–∫–∞–ª—å–Ω—É—é –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö")
            raise

    def _init_ui(self):
        self.setWindowTitle("üïì –£—á—ë—Ç —Ä–∞–±–æ—á–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏")
        self.setWindowIcon(QIcon(str(Path(__file__).parent / "sberhealf.png")))
        self.resize(500, 440)
        self.setMinimumSize(400, 350)

        main_layout = QVBoxLayout()
        main_layout.setContentsMargins(15, 15, 15, 15)
        main_layout.setSpacing(15)

        header_layout = QHBoxLayout()
        logo_label = QLabel()
        logo_path = Path(__file__).parent / "sberhealf.png"
        if logo_path.exists():
            pixmap = QPixmap(str(logo_path))
            pixmap = pixmap.scaled(180, 80, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            logo_label.setPixmap(pixmap)
        header_layout.addWidget(logo_label)

        title_label = QLabel("–£—á—ë—Ç —Ä–∞–±–æ—á–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏")
        title_label.setStyleSheet("font-size: 18px; font-weight: bold;")
        header_layout.addWidget(title_label, alignment=Qt.AlignCenter)
        main_layout.addLayout(header_layout)

        self.info_label = QLabel()
        self.info_label.setStyleSheet("QLabel { background-color: #f5f5f5; border-radius: 5px; padding: 10px; }")
        self._update_info_text()
        main_layout.addWidget(self.info_label)

        self.comment_input = QTextEdit()
        self.comment_input.setPlaceholderText("–í–≤–µ–¥–∏—Ç–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π...")
        self.comment_input.setMaximumHeight(80)
        self.comment_input.setStyleSheet("QTextEdit { border: 1px solid #ddd; border-radius: 5px; padding: 5px; }")
        main_layout.addWidget(self.comment_input)

        self.time_label = QLabel("‚è± –í—Ä–µ–º—è –≤ —Å—Ç–∞—Ç—É—Å–µ: 00:00:00")
        self.time_label.setAlignment(Qt.AlignCenter)
        self.time_label.setStyleSheet("font-size: 14px;")
        main_layout.addWidget(self.time_label)

        self.shift_timer_label = QLabel("‚è∞ –í—Ä–µ–º—è —Å–º–µ–Ω—ã: 00:00:00")
        self.shift_timer_label.setAlignment(Qt.AlignCenter)
        self.shift_timer_label.setStyleSheet("font-size: 14px; color: #0069c0;")
        main_layout.addWidget(self.shift_timer_label)

        for group in STATUS_GROUPS:
            btn_layout = QHBoxLayout()
            btn_layout.setSpacing(10)
            for status in group:
                btn = QPushButton(status)
                btn.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
                btn.clicked.connect(lambda _, s=status: self.set_status(s))
                btn_layout.addWidget(btn)
                self.status_buttons[status] = btn
            main_layout.addLayout(btn_layout)

        self.finish_btn = QPushButton("–ó–∞–≤–µ—Ä—à–∏—Ç—å —Å–º–µ–Ω—É")
        self.finish_btn.setStyleSheet("""
            QPushButton {
                padding: 10px;
                border-radius: 5px;
                background-color: #f44336;
                color: white;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #d32f2f;
            }
        """)
        self.finish_btn.clicked.connect(self.finish_shift)
        main_layout.addWidget(self.finish_btn)

        self.setLayout(main_layout)
        self._update_button_states()

    def _init_timers(self):
        self.status_timer = QTimer(self)
        self.status_timer.timeout.connect(self._update_time_display)
        self.status_timer.start(1000)

        self.sync_timer = QTimer(self)
        self.sync_timer.timeout.connect(self._check_sync_status)
        self.sync_timer.start(60000)

    def _init_shift_check_timer(self):
        self.shift_check_timer = QTimer(self)
        self.shift_check_timer.timeout.connect(self._auto_check_shift_ended)
        self.shift_check_timer.start(30000)  # –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫
        self._auto_check_shift_ended()

    def _is_session_finished_remote(self) -> bool:
        """
        True ‚Äî –µ—Å–ª–∏ –≤ ActiveSessions —Ç–µ–∫—É—â–∞—è (–∏–ª–∏ –ø–æ—Å–ª–µ–¥–Ω—è—è –ø–æ email) —Å–µ—Å—Å–∏—è
        –∏–º–µ–µ—Ç —Å—Ç–∞—Ç—É—Å 'finished' –∏–ª–∏ 'kicked'.
        """
        try:
            if hasattr(sheets_api, "check_user_session_status"):
                st = str(sheets_api.check_user_session_status(self.email, self.session_id)).strip().lower()
                logger.debug(f"[ACTIVESESSIONS] status for {self.email}/{self.session_id}: {st}")
                if st in ("finished", "kicked"):
                    return True

            if hasattr(sheets_api, "get_all_active_sessions"):
                sessions = sheets_api.get_all_active_sessions() or []
                last_for_email = None
                for s in sessions:
                    if str(s.get("Email", "")).strip().lower() == self.email.lower():
                        last_for_email = s
                if last_for_email:
                    st2 = str(last_for_email.get("Status", "")).strip().lower()
                    logger.debug(f"[ACTIVESESSIONS] fallback status for {self.email}: {st2}")
                    return st2 in ("finished", "kicked")
        except Exception as e:
            logger.debug(f"_is_session_finished_remote error: {e}")
        return False

    def _auto_check_shift_ended(self):
        if self.shift_ended:
            return

        # 1) –ª–æ–∫–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
        if self._is_shift_ended():
            self.shift_ended = True
            self.finish_btn.setEnabled(False)
            for btn in self.status_buttons.values():
                btn.setEnabled(False)
            Notifier.show("WorkLog", "–°–º–µ–Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ (–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏, –ø–æ –¥–∞–Ω–Ω—ã–º —Å–∏—Å—Ç–µ–º—ã).")
            logger.info(f"[AUTO_LOGOUT_DETECT] –õ–æ–∫–∞–ª—å–Ω–æ –Ω–∞–π–¥–µ–Ω LOGOUT –¥–ª—è {self.email}")
            return

        # 2) —É–¥–∞–ª—ë–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ ActiveSessions
        if self._is_session_finished_remote():
            logger.info(f"[AUTO_LOGOUT_DETECT] –í ActiveSessions —Å—Ç–∞—Ç—É—Å –ù–ï active –¥–ª—è {self.email}, session={self.session_id}")
            self._closing_reason = "auto_logout"
            self.finish_btn.setEnabled(False)
            for btn in self.status_buttons.values():
                btn.setEnabled(False)
            Notifier.show("WorkLog", "–°–º–µ–Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.")
            try:
                self._log_shift_end("–†–∞–∑–ª–æ–≥–∏–Ω–µ–Ω –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º (—É–¥–∞–ª—ë–Ω–Ω–æ)", reason="admin")
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–≤—Ç–æ–ª–æ–≥–∞—É—Ç–∞—Ö –ø–æ —Å–∏–≥–Ω–∞–ª—É –∏–∑ Sheets: {e}")
            self.shift_ended = True
            self.close()

    def _update_info_text(self):
        info_text = (
            f"<b>–°–æ—Ç—Ä—É–¥–Ω–∏–∫:</b> {self.name}<br>"
            f"<b>–î–æ–ª–∂–Ω–æ—Å—Ç—å:</b> {self.role}<br>"
            f"<b>–ì—Ä—É–ø–ø–∞:</b> {self.group}<br>"
            f"<b>–°–º–µ–Ω–∞:</b> {self.shift_hours}<br>"
            f"<b>–¢–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å:</b> <span style='color: #2e7d32;'>{self.current_status}</span>"
        )
        self.info_label.setText(info_text)
        self.status_changed.emit(self.current_status)
        self._update_button_states()

    def _update_button_states(self):
        for status, btn in self.status_buttons.items():
            if status == self.current_status:
                btn.setStyleSheet("""
                    QPushButton {
                        padding: 8px;
                        border-radius: 5px;
                        background-color: #b3ffb3;
                        font-weight: bold;
                        border: 2px solid #2e7d32;
                    }
                    QPushButton:hover {
                        background-color: #a1e6a1;
                    }
                """)
                btn.setEnabled(False)
            else:
                btn.setStyleSheet("""
                    QPushButton {
                        padding: 8px;
                        border-radius: 5px;
                        background-color: #e0e0e0;
                    }
                    QPushButton:hover {
                        background-color: #d0d0d0;
                    }
                """)
                btn.setEnabled(True)
            if self.shift_ended:
                btn.setEnabled(False)

    def _update_time_display(self):
        time_in_status = datetime.now() - self.status_start_time
        hours, remainder = divmod(time_in_status.seconds, 3600)
        minutes, seconds = divmod(remainder, 60)
        self.time_label.setText(f"‚è± –í—Ä–µ–º—è –≤ —Å—Ç–∞—Ç—É—Å–µ: {hours:02d}:{minutes:02d}:{seconds:02d}")

        shift_time = datetime.now() - self.shift_start_time
        h, rem = divmod(shift_time.seconds, 3600)
        m, s = divmod(rem, 60)
        self.shift_timer_label.setText(f"‚è∞ –í—Ä–µ–º—è —Å–º–µ–Ω—ã: {h:02d}:{m:02d}:{s:02d}")

    def _check_sync_status(self):
        if self.last_sync_time:
            time_since_sync = datetime.now() - self.last_sync_time
            if time_since_sync > timedelta(hours=1):
                Notifier.show("WorkLog", "–î–∞–Ω–Ω—ã–µ –Ω–µ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–ª–∏—Å—å –±–æ–ª–µ–µ —á–∞—Å–∞")

    def _is_shift_ended(self) -> bool:
        try:
            return self.db.check_existing_logout(self.email, session_id=self.session_id)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Å–º–µ–Ω—ã: {e}")
            return False

    def set_status(self, new_status: str):
        if self.shift_ended:
            QMessageBox.warning(self, "–û—à–∏–±–∫–∞", "–°–º–µ–Ω–∞ —É–∂–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∞")
            return

        if new_status == self.current_status:
            QMessageBox.information(self, "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è", "–í—ã —É–∂–µ –Ω–∞—Ö–æ–¥–∏—Ç–µ—Å—å –≤ —ç—Ç–æ–º —Å—Ç–∞—Ç—É—Å–µ.")
            return

        comment = self.comment_input.toPlainText().strip()

        try:
            now = datetime.now().isoformat()
            
            # --- –®–ê–ì 1: –Ø–≤–Ω–æ –∑–∞–≤–µ—Ä—à–∞–µ–º –ü–û–°–õ–ï–î–ù–ò–ô —Å—Ç–∞—Ç—É—Å, —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—è end_time ---
            # –ù–∞—Ö–æ–¥–∏–º id –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Å—Ç–∞—Ç—É—Å–∞ (LOGIN –∏–ª–∏ STATUS_CHANGE)
            with self.db._lock:
                cursor = self.db.conn.execute(
                    "SELECT id, status FROM logs WHERE email=? AND session_id=? "
                    "AND status_end_time IS NULL "
                    "AND action_type IN ('LOGIN', 'STATUS_CHANGE') "
                    "ORDER BY id DESC LIMIT 1",
                    (self.email, self.session_id)
                )
                row = cursor.fetchone()
                if row:
                    prev_id, prev_status = row
                    # –Ø–≤–Ω–æ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Ä–µ–º—è –æ–∫–æ–Ω—á–∞–Ω–∏—è
                    self.db.conn.execute(
                        "UPDATE logs SET status_end_time=? WHERE id=?",
                        (now, prev_id)
                    )
                    self.db.conn.commit()
                    logger.info(f"–°—Ç–∞—Ç—É—Å '{prev_status}' (id={prev_id}) –∑–∞–≤–µ—Ä—à–µ–Ω –≤ {now}")
                    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å—Ç–∞—Ä—É—é –∑–∞–ø–∏—Å—å –≤ —Ñ–æ–Ω–µ
                    self._send_action_to_sheets(prev_id)
                else:
                    logger.warning("–ù–µ –Ω–∞–π–¥–µ–Ω –Ω–µ–∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–π —Å—Ç–∞—Ç—É—Å –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è end_time")

            # --- –®–ê–ì 2: –õ–æ–≥–∏—Ä—É–µ–º –ù–û–í–´–ô —Å—Ç–∞—Ç—É—Å ---
            record_id = self.db.log_action(
                email=self.email,
                name=self.name,
                status=new_status,
                action_type="STATUS_CHANGE",
                comment=comment if comment else None,
                immediate_sync=False,
                session_id=self.session_id,
                status_start_time=now,
                status_end_time=None
            )
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–æ–≤—É—é –∑–∞–ø–∏—Å—å –≤ —Ñ–æ–Ω–µ
            self._send_action_to_sheets(record_id)
            
            # --- –®–ê–ì 3: –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è ---
            self.current_status = new_status
            self.status_start_time = datetime.fromisoformat(now)
            self.comment_input.clear()
            self._update_info_text()
            Notifier.show("WorkLog", f"–°—Ç–∞—Ç—É—Å –∏–∑–º–µ–Ω–µ–Ω –Ω–∞: {new_status}")
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞: {e}")
            QMessageBox.critical(self, "–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–º–µ–Ω–∏—Ç—å —Å—Ç–∞—Ç—É—Å: {e}")

    def finish_shift(self):
        if self.shift_ended:
            QMessageBox.information(self, "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è", "–°–º–µ–Ω–∞ —É–∂–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∞")
            return

        reply = QMessageBox.question(
            self,
            "–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ",
            "–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –∑–∞–≤–µ—Ä—à–∏—Ç—å —Å–º–µ–Ω—É?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )

        if reply == QMessageBox.Yes:
            try:
                result = self._log_shift_end("–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Å–º–µ–Ω—ã (–Ω–æ—Ä–º–∞–ª—å–Ω–æ–µ)", reason="user", group=self.group, sync=False)
                if result:
                    logger.info(f"[LOGOUT] –ó–∞–ø–∏—Å—å LOGOUT —É—Å–ø–µ—à–Ω–æ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∞ –¥–ª—è {self.email}")
                else:
                    logger.warning(f"[LOGOUT] LOGOUT —É–∂–µ –±—ã–ª –∑–∞–ø–∏—Å–∞–Ω –¥–ª—è {self.email}")
                self.shift_ended = True
                self.finish_btn.setEnabled(False)
                for btn in self.status_buttons.values():
                    btn.setEnabled(False)
                try:
                    sheets_api.finish_active_session(self.email, self.session_id, datetime.now().isoformat())
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Å–µ—Å—Å–∏–∏ –≤ ActiveSessions: {e}")
                self.close()
            except LocalDBError as e:
                logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Å–º–µ–Ω—ã: {e}")
                QMessageBox.critical(self, "–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≤–µ—Ä—à–∏—Ç—å —Å–º–µ–Ω—É: {e}")

    def force_logout_by_admin(self):
        """–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—ã–π –≤—ã—Ö–æ–¥ –ø–æ –∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ —Å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        if self.shift_ended:
            logger.info(f"[ADMIN_LOGOUT] –ü–æ–ø—ã—Ç–∫–∞ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–≥–æ –≤—ã—Ö–æ–¥–∞ –¥–ª—è —É–∂–µ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω–æ–π —Å–º–µ–Ω—É: {self.email}")
            return
            
        self._closing_reason = "admin_logout"
        self.finish_btn.setEnabled(False)
        for btn in self.status_buttons.values():
            btn.setEnabled(False)
            
        try:
            # —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –ø–∏—à–µ–º —Å—Ç–∞—Ç—É—Å+LOGOUT –≤ WorkLog_–ì—Ä—É–ø–ø–∞
            self._log_shift_end("–†–∞–∑–ª–æ–≥–∏–Ω–µ–Ω –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º", reason="admin",
                                group=self.group, sync=True)
            # –∏ —Å—Ä–∞–∑—É –ø–æ–º–µ—á–∞–µ–º ActiveSessions –∫–∞–∫ "kicked"
            try:
                sheets_api.kick_active_session(self.email, self.session_id, datetime.now().isoformat())
            except Exception as e:
                logger.error(f"kick_active_session error: {e}")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–¥–º–∏–Ω—Å–∫–æ–º –≤—ã—Ö–æ–¥–µ: {e}")
            if self.on_logout_callback:
                self.on_logout_callback()

        self.shift_ended = True

        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–µ –æ–∫–Ω–æ (–Ω–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–µ)
        QMessageBox.information(
            self,
            "–°–º–µ–Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º",
            "–í–∞—à–∞ —Å–º–µ–Ω–∞ –±—ã–ª–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.\n\n–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –±—É–¥–µ—Ç –∑–∞–∫—Ä—ã—Ç–æ."
        )

        self.close()

    def _log_shift_end(self, comment: str, reason: str = "user", 
                       group: Optional[str] = None, sync: bool = False) -> bool:
        """
        –ó–∞–≤–µ—Ä—à–∞–µ—Ç —Å–º–µ–Ω—É –∏ –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç LOGOUT.
        :param comment: –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ –≤—ã—Ö–æ–¥—É.
        :param reason: –ü—Ä–∏—á–∏–Ω–∞ –≤—ã—Ö–æ–¥–∞ (user, admin, auto).
        :param group: –ì—Ä—É–ø–ø–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –≤—ã–±–æ—Ä–∞ –ª–∏—Å—Ç–∞ –≤ Google Sheets).
        :param sync: –°–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö (True –¥–ª—è –∞–¥–º–∏–Ω—Å–∫–æ–≥–æ –≤—ã—Ö–æ–¥–∞).
        """
        try:
            if self._is_shift_ended():
                logger.warning(f"[LOGOUT] –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ LOGOUT –¥–ª—è {self.email} ‚Äî –ø—Ä–æ–ø—É—Å–∫.")
                return False

            # 1) –∑–∞–∫—Ä—ã—Ç—å –ø—Ä–µ–¥—ã–¥—É—â–∏–π —Å—Ç–∞—Ç—É—Å
            prev_id = self.db.finish_last_status(self.email, self.session_id)
            if prev_id:
                if sync:
                    row = self.db.get_action_by_id(prev_id)
                    action = self._make_action_payload_from_row(row)
                    if sheets_api.log_user_actions([action], self.email, user_group=group or self.group):
                        self.db.mark_actions_synced([prev_id])
                else:
                    self._send_action_to_sheets(prev_id, user_group=group or self.group)

            # 2) –∑–∞–ø–∏—Å–∞—Ç—å LOGOUT
            now = datetime.now().isoformat()
            record_id = self.db.log_action(
                email=self.email,
                name=self.name,
                status="–ó–∞–≤–µ—Ä—à–µ–Ω–æ",
                action_type="LOGOUT",
                comment=comment,
                immediate_sync=False,
                session_id=self.session_id,
                status_start_time=now,
                status_end_time=now,
                reason=reason,
                user_group=group or self.group
            )

            if sync:
                row2 = self.db.get_action_by_id(record_id)
                action2 = self._make_action_payload_from_row(row2)
                if sheets_api.log_user_actions([action2], self.email, user_group=group or self.group):
                    self.db.mark_actions_synced([record_id])
            else:
                self._send_action_to_sheets(record_id, user_group=group or self.group)

            self.last_sync_time = datetime.now()
            self._check_sync_status()
            logger.info(f"[LOGOUT] –°–º–µ–Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞: {self.email}. –ü—Ä–∏—á–∏–Ω–∞: {comment}, reason={reason}")

            if self.on_logout_callback:
                self.on_logout_callback()
                
            return True
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏ LOGOUT: {e}")
            return False

    def closeEvent(self, event):
        if self._closing_reason == "admin_logout":
            # –ó–∞–∫—Ä—ã–≤–∞–µ–º –±–µ–∑ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
            event.accept()
            self._closing_reason = None
            return

        if self._closing_reason == "auto_logout":
            # –ú–æ–∂–Ω–æ –∑–∞–∫—Ä—ã—Ç—å –±–µ–∑ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∏–ª–∏ –ø–æ–∫–∞–∑–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
            event.accept()
            self._closing_reason = None
            return

        # –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø—ã—Ç–∞–µ—Ç—Å—è –∑–∞–∫—Ä—ã—Ç—å –æ–∫–Ω–æ –≤—Ä—É—á–Ω—É—é
        reply = QMessageBox.question(
            self,
            '–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–∏—è',
            '–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –∑–∞–∫—Ä—ã—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ? –°–º–µ–Ω–∞ –±—É–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∞...',
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )

        if reply == QMessageBox.Yes:
            self._closing_reason = "user_close"
            try:
                self._log_shift_end("–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ —á–µ—Ä–µ–∑ –∫—Ä–µ—Å—Ç–∏–∫", reason="user", group=self.group, sync=False)
                sheets_api.finish_active_session(self.email, self.session_id, datetime.now().isoformat())
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è: {e}")
            self.shift_ended = True
            event.accept()
            self._closing_reason = None
        else:
            event.ignore()

--------------------------------------------------------------------------------
# FILE: user_app\login_window.py
# SIZE: 11741 bytes | SHA256(text): 9a1004cc885cef2aef40a9f55518c02fa6b6d46f66ba1d948f3e8a68160e30fd
--------------------------------------------------------------------------------
import re
import logging
import sys
from pathlib import Path
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QLabel,
    QLineEdit, QPushButton, QMessageBox, QSpacerItem, QSizePolicy
)
from PyQt5.QtCore import Qt, pyqtSignal, QDateTime
from PyQt5.QtGui import QIcon, QPixmap, QFont

try:
    from config import validate_config
    from sheets_api import SheetsAPI
    from user_app.db_local import LocalDB
except ImportError:
    try:
        from roma.config import validate_config
        from roma.sheets_api import SheetsAPI
        from roma.user_app.db_local import LocalDB
    except ImportError:
        from config import validate_config
        from sheets_api import SheetsAPI
        from user_app.db_local import LocalDB

logger = logging.getLogger(__name__)

class LoginWindow(QDialog):
    login_success = pyqtSignal(dict)
    login_failed = pyqtSignal(str)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("–í—Ö–æ–¥ –≤ —Å–∏—Å—Ç–µ–º—É")
        self.setWindowIcon(QIcon(self._resource_path("user_app/sberhealf.png")))
        self.setFixedSize(440, 360)
        self.user_data = None
        self.sheets_api = SheetsAPI()
        self.auth_in_progress = False
        self._success_emitted = False
        self._showing_error = False
        logger.debug("LoginWindow: –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –æ–∫–Ω–∞ –≤—Ö–æ–¥–∞")
        self._init_ui()
        self._setup_shortcuts()

    def _resource_path(self, relative_path):
        if hasattr(sys, '_MEIPASS'):
            base_path = Path(sys._MEIPASS)
        else:
            base_path = Path(__file__).parent.parent
        return str(base_path / relative_path)

    def _init_ui(self):
        self.setFont(QFont("Segoe UI", 11))
        layout = QVBoxLayout()
        layout.setContentsMargins(30, 25, 30, 25)
        layout.setSpacing(18)

        logo_label = QLabel()
        try:
            pixmap = QPixmap(self._resource_path("user_app/sberhealf.png"))
            target_width = 170
            target_height = 70
            pixmap = pixmap.scaled(
                target_width, target_height,
                Qt.KeepAspectRatio, Qt.SmoothTransformation
            )
            logo_label.setPixmap(pixmap)
            logo_label.setAlignment(Qt.AlignCenter)
            layout.addWidget(logo_label)
        except Exception as e:
            logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –ª–æ–≥–æ—Ç–∏–ø: {e}")

        title_label = QLabel("–í—Ö–æ–¥ –≤ —Å–∏—Å—Ç–µ–º—É")
        title_label.setAlignment(Qt.AlignCenter)
        title_label.setStyleSheet("""
            font-size: 22px;
            font-weight: bold;
            color: #222;
            margin-bottom: 15px;
        """)
        layout.addWidget(title_label)

        layout.addSpacerItem(QSpacerItem(20, 10, QSizePolicy.Minimum, QSizePolicy.Fixed))

        self.email_input = QLineEdit()
        self.email_input.setPlaceholderText("–ö–æ—Ä–ø–æ—Ä–∞—Ç–∏–≤–Ω—ã–π email")
        self.email_input.setStyleSheet("""
            QLineEdit {
                padding: 11px;
                border: 1.5px solid #ccc;
                border-radius: 8px;
                font-size: 15px;
                min-width: 290px;
                max-width: 350px;
            }
        """)
        self.email_input.setMinimumWidth(290)
        self.email_input.setMaximumWidth(350)
        layout.addWidget(self.email_input, alignment=Qt.AlignCenter)

        layout.addSpacerItem(QSpacerItem(20, 8, QSizePolicy.Minimum, QSizePolicy.Fixed))

        self.login_btn = QPushButton("–í–æ–π—Ç–∏")
        self.login_btn.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                border: none;
                padding: 13px;
                font-size: 16px;
                border-radius: 9px;
                min-width: 180px;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
            QPushButton:disabled {
                background-color: #cccccc;
            }
        """)
        self.login_btn.setMinimumHeight(40)
        self.login_btn.setMaximumWidth(220)
        self.login_btn.clicked.connect(self._try_login)
        layout.addWidget(self.login_btn, alignment=Qt.AlignCenter)

        self.status_label = QLabel()
        self.status_label.setStyleSheet("""
            color: #666;
            font-size: 13px;
            margin-top: 12px;
            min-height: 18px;
        """)
        self.status_label.setAlignment(Qt.AlignCenter)
        layout.addWidget(self.status_label)

        layout.addStretch(1)
        self.setLayout(layout)
        logger.debug("LoginWindow: –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")

    def _setup_shortcuts(self):
        self.email_input.returnPressed.connect(self._try_login)

    def _validate_email(self, email: str) -> bool:
        logger.debug(f"LoginWindow: –≤–∞–ª–∏–¥–∞—Ü–∏—è email '{email}'")
        pattern = r"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$"
        return re.match(pattern, email) is not None

    def _try_login(self):
        logger.info("LoginWindow: —Å—Ç–∞—Ä—Ç –ª–æ–≥–∏–Ω–∞")
        if self.auth_in_progress or self._success_emitted:
            logger.debug(f"LoginWindow: –ø—Ä–æ–ø—É—Å–∫ –ø–æ–ø—ã—Ç–∫–∏ –ª–æ–≥–∏–Ω–∞ (auth_in_progress={self.auth_in_progress}, _success_emitted={self._success_emitted})")
            return
        self.auth_in_progress = True

        email = self.email_input.text().strip()
        logger.info(f"LoginWindow: –≤–≤–µ–¥—ë–Ω email: {email}")

        if not email:
            error_msg = "–í–≤–µ–¥–∏—Ç–µ email –∞–¥—Ä–µ—Å"
            logger.warning(f"LoginWindow: {error_msg}")
            self._show_error_once(error_msg)
            self.login_failed.emit(error_msg)
            self.auth_in_progress = False
            return

        if not self._validate_email(email):
            error_msg = "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç email"
            logger.warning(f"LoginWindow: {error_msg}")
            self._show_error_once(error_msg)
            self.login_failed.emit(error_msg)
            self.auth_in_progress = False
            return

        self._set_loading_state(True)

        try:
            logger.debug("LoginWindow: –≤—ã–∑–æ–≤ validate_config")
            validate_config()
            logger.debug("LoginWindow: –≤—ã–∑–æ–≤ get_user_by_email")
            user_data = self.sheets_api.get_user_by_email(email)

            if user_data:
                logger.info("LoginWindow: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–π–¥–µ–Ω, –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º")
                
                # --- –í–°–ï–ì–î–ê –ó–ê–í–ï–†–®–ê–ï–ú –°–¢–ê–†–£–Æ –°–ï–°–°–ò–Æ –ò –ù–ê–ß–ò–ù–ê–ï–ú –ù–û–í–£–Æ ---
                # 1. –ù–∞—Ö–æ–¥–∏–º –∞–∫—Ç–∏–≤–Ω—É—é —Å–µ—Å—Å–∏—é
                active_session = self.sheets_api.get_active_session(email)
                if active_session:
                    session_id = active_session.get("SessionID")
                    login_time = active_session.get("LoginTime")
                    # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–≤–µ—Ä—à–∞–µ–º —Å—Ç–∞—Ä—É—é —Å–µ—Å—Å–∏—é –±–µ–∑ –≤–æ–ø—Ä–æ—Å–∞
                    logger.info(f"LoginWindow: –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–≤–µ—Ä—à–∞–µ–º —Å—Ç–∞—Ä—É—é —Å–µ—Å—Å–∏—é –æ—Ç {login_time}")
                    logout_time = QDateTime.currentDateTime().toString(Qt.ISODate)
                    self.sheets_api.finish_active_session(email, session_id, logout_time)
                
                # 2. –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é —Å–µ—Å—Å–∏—é
                session_id = f"{email[:8]}_{QDateTime.currentDateTime().toString('yyyyMMddHHmmss')}"
                self.sheets_api.set_active_session(
                    email,
                    user_data.get("name", ""),
                    session_id,
                    QDateTime.currentDateTime().toString(Qt.ISODate)
                )
                login_was_performed = True
                # --- –ö–û–ù–ï–¶ ---
                
                # –§–æ—Ä–º–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –≤ GUI
                self.user_data = {
                    "email": user_data["email"],
                    "name": user_data["name"],
                    "role": user_data["role"],
                    "shift_hours": user_data["shift_hours"],
                    "telegram_login": user_data.get("telegram_login", ""),
                    "group": user_data.get("group", ""),
                    "login_was_performed": login_was_performed,
                    "session_id": session_id
                }
                
                # –ò—Å–ø—É—Å–∫–∞–µ–º —Å–∏–≥–Ω–∞–ª –∏ –∑–∞–∫—Ä—ã–≤–∞–µ–º –æ–∫–Ω–æ
                if not self._success_emitted:
                    logger.debug("LoginWindow: –∏—Å–ø—É—Å–∫–∞–µ–º login_success")
                    self._success_emitted = True
                    self.login_success.emit(self.user_data)
                else:
                    logger.debug("LoginWindow: login_success —É–∂–µ –∏—Å–ø—É—â–µ–Ω")
                self.accept()
            else:
                error_msg = "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ email –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."
                logger.error(f"LoginWindow: {error_msg}")
                self._show_error_once(error_msg)
                self.login_failed.emit(error_msg)

        except Exception as e:
            logger.error(f"LoginWindow: –û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏: {e}")
            error_msg = f"–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: {str(e).replace("'", "")}"
            self._show_error_once(error_msg)
            self.login_failed.emit(error_msg)
        finally:
            logger.debug("LoginWindow: –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ø–æ–ø—ã—Ç–∫–∏ –ª–æ–≥–∏–Ω–∞")
            self._set_loading_state(False)
            self.auth_in_progress = False

    def _set_loading_state(self, loading: bool):
        logger.debug(f"LoginWindow: —É—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è loading={loading}")
        self.login_btn.setDisabled(loading)
        self.email_input.setReadOnly(loading)
        self.login_btn.setText("–ü—Ä–æ–≤–µ—Ä–∫–∞..." if loading else "–í–æ–π—Ç–∏")
        self.status_label.setText("–ò–¥–µ—Ç –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–Ω–Ω—ã—Ö..." if loading else "")

    def _show_error_once(self, message: str):
        logger.debug(f"LoginWindow: _show_error_once –≤—ã–∑–≤–∞–Ω —Å message='{message}', _showing_error={self._showing_error}")
        if self._showing_error:
            logger.warning("LoginWindow: –ø–æ–ø—ã—Ç–∫–∞ –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –ø–æ–∫–∞–∑–∞ –æ—à–∏–±–∫–∏, –ø—Ä–æ–ø—É—Å–∫")
            return
        self._showing_error = True
        logger.info(f"LoginWindow: –ø–æ–∫–∞–∑—ã–≤–∞–µ–º QMessageBox.warning —Å —Ç–µ–∫—Å—Ç–æ–º: {message}")
        QMessageBox.warning(self, "–û—à–∏–±–∫–∞", message)
        self.status_label.setText(f'<span style="color: red;">{message}</span>')
        self._showing_error = False

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key_Return, Qt.Key_Enter):
            logger.debug("LoginWindow: –Ω–∞–∂–∞—Ç–∏–µ Enter/Return, –ø—Ä–æ–±—É–µ–º –ª–æ–≥–∏–Ω")
            self._try_login()
        else:
            super().keyPressEvent(event)

if __name__ == "__main__":
    from PyQt5.QtWidgets import QApplication
    logging.basicConfig(level=logging.DEBUG)
    app = QApplication(sys.argv)
    window = LoginWindow()
    window.show()
    sys.exit(app.exec_())

--------------------------------------------------------------------------------
# FILE: user_app\main.py
# SIZE: 8823 bytes | SHA256(text): 278a32ec4642a3e17031067d7e0099c3fc4a642a48a5c89a9bbc1d53b17bd3f2
--------------------------------------------------------------------------------
# user_app/main.py
import sys
import logging
from pathlib import Path
from typing import Dict, Any
from PyQt5.QtWidgets import QApplication, QMessageBox
from PyQt5.QtCore import QObject, pyqtSignal, QThread
import traceback
import atexit

# –î–æ–±–∞–≤–ª—è–µ–º –∫–æ—Ä–µ–Ω—å –ø—Ä–æ–µ–∫—Ç–∞ –≤ sys.path
ROOT = Path(__file__).parent.parent.resolve()
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —á–µ—Ä–µ–∑ –µ–¥–∏–Ω—ã–π –º–æ–¥—É–ª—å
from config import LOG_DIR, get_credentials_file
from logging_setup import setup_logging
from user_app.signals import SyncSignals
from sheets_api import SheetsAPI  # –Ø–≤–Ω—ã–π –∏–º–ø–æ—Ä—Ç –∫–ª–∞—Å—Å–∞ SheetsAPI
from auto_sync import SyncManager  # ‚Üê –¥–æ–±–∞–≤–∏–ª–∏

# ----- –°–∏–≥–Ω–∞–ª—ã –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è -----
class ApplicationSignals(QObject):
    app_started = pyqtSignal()
    app_shutdown = pyqtSignal()
    login_attempt = pyqtSignal(str)
    login_success = pyqtSignal(dict)
    login_failed = pyqtSignal(str)
    sync_status_changed = pyqtSignal(bool)
    sync_progress = pyqtSignal(int, int)
    sync_finished = pyqtSignal(bool)

# ----- –ú–µ–Ω–µ–¥–∂–µ—Ä –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è -----
class ApplicationManager(QObject):
    def __init__(self):
        super().__init__()
        self.app = QApplication(sys.argv)
        self.app.setStyle("Fusion")
        self.app.setApplicationName("WorkTimeTracker")
        self.app.setApplicationVersion("1.0.0")

        self.login_window = None
        self.main_window = None
        self.signals = ApplicationSignals()

        self.sync_thread: QThread | None = None
        self.sync_worker: SyncManager | None = None
        self.sync_signals = SyncSignals()  # —Å–∏–≥–Ω–∞–ª—ã –¥–æ—Å—Ç—É–ø–Ω—ã –∏ –¥–ª—è GUI, –∏ –¥–ª—è SyncManager

        sys.excepthook = self.handle_uncaught_exception

        try:
            self._initialize_resources()
            self._start_sync_service()
            self.signals.app_started.emit()
        except Exception as e:
            self._show_error("Initialization Error", f"Failed to initialize: {e}")
            sys.exit(1)

    # --- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–µ—Å—É—Ä—Å–æ–≤ ---
    def _initialize_resources(self):
        creds_path = get_credentials_file()
        if not creds_path.exists():
            raise FileNotFoundError(f"Credentials file not found: {creds_path}")
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–∞ Google Sheets
        try:
            self.sheets_api = SheetsAPI()
        except Exception as e:
            logging.getLogger(__name__).error("SheetsAPI init failed: %s", e)
            raise
        
        if not self.sheets_api.check_credentials():
            raise RuntimeError("Invalid Google Sheets credentials")

    # --- –§–æ–Ω–æ–≤–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è ---
    def _start_sync_service(self):
        try:
            logger = logging.getLogger(__name__)
            logger.info("=== –ó–ê–ü–£–°–ö –°–ï–†–í–ò–°–ê –°–ò–ù–•–†–û–ù–ò–ó–ê–¶–ò–ò ===")
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º —Å–µ—Ä–≤–∏—Å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –≤ —Ñ–æ–Ω–µ
            self.sync_manager = SyncManager(signals=self.sync_signals, background_mode=True)
            if hasattr(self.sync_manager, "start"):
                self.sync_manager.start()
            elif hasattr(self.sync_manager, "start_background"):
                self.sync_manager.start_background()
            
            logger.info("Sync service started")
        except Exception as e:
            logger.error(f"Failed to start sync service: {e}")

    # --- UI –ø–æ—Ç–æ–∫–∏ ---
    def show_login_window(self):
        try:
            from user_app.login_window import LoginWindow
            self.login_window = LoginWindow()
            self.login_window.login_success.connect(self.handle_login_success)
            self.login_window.login_failed.connect(self.handle_login_failed)
            self.login_window.show()
        except Exception as e:
            self._show_error("Login Error", f"Cannot show login window: {e}")
            self.quit_application()

    def handle_login_success(self, user_data: Dict[str, Any]):
        try:
            from user_app.gui import EmployeeApp

            # –∑–∞–∫—Ä—ã—Ç—å –æ–∫–Ω–æ –ª–æ–≥–∏–Ω–∞
            if self.login_window:
                try:
                    self.login_window.close()
                except Exception:
                    pass

            # –¥–æ—Å—Ç–∞—ë–º –¥–∞–Ω–Ω—ã–µ, –∫–æ—Ç–æ—Ä—ã–µ LoginWindow —É–∂–µ —Å–æ–±–∏—Ä–∞–µ—Ç
            session_id = None
            login_was_performed = True
            if user_data.get("unfinished_session"):
                session_id = user_data["unfinished_session"].get("session_id")
            if "login_was_performed" in user_data:
                login_was_performed = bool(user_data["login_was_performed"])

            def on_logout_wrapper():
                # –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –∑–∞–≤–µ—Ä—à–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –ø–æ –∑–∞–ø—Ä–æ—Å—É –∏–∑ EmployeeApp
                self.quit_application()

            # —Å–æ–∑–¥–∞—ë–º –≥–ª–∞–≤–Ω–æ–µ –æ–∫–Ω–æ –∫–∞–∫ —Ä–∞–Ω—å—à–µ
            self.main_window = EmployeeApp(
                email=user_data["email"],
                name=user_data["name"],
                role=user_data["role"],
                shift_hours=user_data["shift_hours"],
                telegram_login=user_data.get("telegram_login", ""),
                on_logout_callback=on_logout_wrapper,
                session_id=session_id,
                login_was_performed=login_was_performed,
                group=user_data.get("group", "")
            )
            self.main_window.show()

            # –ø–æ–¥–∫–ª—é—á–∞–µ–º ¬´–ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—ã–π —Ä–∞–∑–ª–æ–≥–∏–Ω¬ª –∏–∑ —Å–µ—Ä–≤–∏—Å–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
            self.sync_signals.force_logout.connect(self.main_window.force_logout_by_admin)
            logger = logging.getLogger(__name__)
            logger.info("force_logout —Å–∏–≥–Ω–∞–ª –ø–æ–¥–∫–ª—é—á—ë–Ω –∫ force_logout_by_admin")

        except Exception as e:
            self._show_error("Main Window Error", f"Cannot show main window: {e}")
            self.quit_application()

    def handle_login_failed(self, message: str):
        self._show_error("Login Failed", message)

    # --- –û–±—â–µ–µ ---
    def _show_error(self, title: str, message: str):
        QMessageBox.critical(None, title, message)
        logger = logging.getLogger(__name__)
        logger.error("%s: %s", title, message)

    def handle_uncaught_exception(self, exc_type, exc_value, exc_traceback):
        logger = logging.getLogger(__name__)
        logger.critical(
            "Unhandled exception",
            exc_info=(exc_type, exc_value, exc_traceback)
        )
        self._show_error("Critical Error", f"An unexpected error occurred:\n\n{exc_value}")
        self.quit_application()

    def quit_application(self):
        logger = logging.getLogger(__name__)
        logger.info("Shutting down application.")
        self.signals.app_shutdown.emit()

        # –∑–∞–∫—Ä—ã–≤–∞–µ–º –æ–∫–Ω–∞
        if self.main_window:
            try:
                self.main_window.close()
            except Exception as e:
                logger.error("Error on main_window.close(): %s", e)
            self.main_window = None

        if self.login_window:
            try:
                self.login_window.close()
            except Exception as e:
                logger.error("Error on login_window.close(): %s", e)
            self.login_window = None

        # –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–µ—Ä–≤–∏—Å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
        try:
            if self.sync_worker:
                self.sync_worker.stop()
        except Exception:
            pass
        if self.sync_thread and self.sync_thread.isRunning():
            self.sync_thread.quit()
            self.sync_thread.wait()

        self.app.quit()

    # —Ç–æ—á–∫–∞ –≤—Ö–æ–¥–∞ UI
    def run(self):
        self.show_login_window()
        sys.exit(self.app.exec_())

# ----- CLI -----
def main():
    try:
        # –µ–¥–∏–Ω—ã–π –ª–æ–≥–≥–µ—Ä
        log_path = setup_logging(app_name="wtt-user", log_dir=LOG_DIR)
        logger = logging.getLogger(__name__)
        logger.info("Logging initialized (path=%s)", log_path)
        
        app_manager = ApplicationManager()
        app_manager.run()
    except Exception as e:
        logging.critical(f"Fatal error: {e}\n{traceback.format_exc()}")
        QMessageBox.critical(None, "Fatal Error", f"Application failed to start:\n{e}")
        sys.exit(1)

if __name__ == "__main__":
    main()

--------------------------------------------------------------------------------
# FILE: user_app\signals.py
# SIZE: 543 bytes | SHA256(text): 398f86cb7ea6ca6a8362b6114b5d5af9172feea88b74243af669cf415c3a4d8f
--------------------------------------------------------------------------------
# user_app/signals.py
from PyQt5.QtCore import QObject, pyqtSignal


class SyncSignals(QObject):
    """
    –û–±—â–∏–µ —Å–∏–≥–Ω–∞–ª—ã —Å–∏–Ω–∫–∞/—É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–ª—è –ø—Ä–æ–∫–∏–¥—ã–≤–∞–Ω–∏—è –≤ GUI –∏ —Ñ–æ–Ω–æ–≤—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä.
    """
    # –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∑–∞–≤–µ—Ä—à–∏–ª —Å–µ—Å—Å–∏—é
    force_logout = pyqtSignal()
    # –¢–µ–ª–µ–º–µ—Ç—Ä–∏—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ (–æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –ø–æ—Å–ª–µ –∫–∞–∂–¥–æ–≥–æ —Ü–∏–∫–ª–∞)
    sync_status_updated = pyqtSignal(dict)

--------------------------------------------------------------------------------
# FILE: user_app\ui_helpers.py
# SIZE: 915 bytes | SHA256(text): 5e17c90fa5930c93d96d64d421c101987d71c21e69eda74c4093952e8ac4c4f5
--------------------------------------------------------------------------------
# user_app/ui_helpers.py
import re, time
from typing import Optional

EMAIL_RE = re.compile(r"^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$", re.IGNORECASE)

class MessageDebouncer:
    """
    –ë–ª–æ–∫–∏—Ä—É–µ—Ç –ø–æ–≤—Ç–æ—Ä –æ–¥–Ω–æ–≥–æ –∏ —Ç–æ–≥–æ –∂–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —Ç–µ—á–µ–Ω–∏–µ N —Å–µ–∫—É–Ω–¥,
    —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –¥—É–±–ª—è "e-mail –Ω–µ –Ω–∞–π–¥–µ–Ω".
    """
    def __init__(self, cooldown_sec: float = 1.0):
        self.cooldown = cooldown_sec
        self._last_key: Optional[str] = None
        self._last_ts: float = 0.0

    def should_show(self, key: str) -> bool:
        now = time.monotonic()
        if self._last_key == key and (now - self._last_ts) < self.cooldown:
            return False
        self._last_key, self._last_ts = key, now
        return True

def is_valid_email(email: str) -> bool:
    return bool(EMAIL_RE.match((email or "").strip()))

--------------------------------------------------------------------------------
# FILE: work_time_tracker.egg-info\dependency_links.txt
# SIZE: 1 bytes | SHA256(text): 01ba4719c80b6fe911b091a7c05124b64eeece964e09c058ef8f9805daca546b
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
# FILE: work_time_tracker.egg-info\entry_points.txt
# SIZE: 257 bytes | SHA256(text): dfbe78e5fd4cef48f42cf4aa4e603286c7b2945c2dd1afab51d031a858b4df22
--------------------------------------------------------------------------------
[console_scripts]
wtt-admin = admin_app.main_admin:main
wtt-archive = tools.archive_cli:main
wtt-doctor = tools.doctor:main
wtt-send = tools.tg_send:main
wtt-telebot = telegram_bot.main:main
wtt-tg-env = tools.tg_envcheck:main
wtt-user = user_app.main:main

--------------------------------------------------------------------------------
# FILE: work_time_tracker.egg-info\requires.txt
# SIZE: 131 bytes | SHA256(text): a5114a6ed8158dfe0c7811946380ce52a4810e2268e711431b4adba5869bdbce
--------------------------------------------------------------------------------
PyQt5>=5.15
gspread>=6.0.0
google-auth>=2.0.0
google-auth-oauthlib>=1.0.0
requests>=2.31
urllib3>=2.0
python-dateutil>=2.9.0.post0

--------------------------------------------------------------------------------
# FILE: work_time_tracker.egg-info\SOURCES.txt
# SIZE: 781 bytes | SHA256(text): 9a933f37829522dbc1a73c498771bf87ba0f855276edbd20f5aafa66a86577e0
--------------------------------------------------------------------------------
config.py
logging_setup.py
pyproject.toml
sheets_api.py
admin_app/gui_admin.py
admin_app/main_admin.py
admin_app/repo.py
admin_app/schedule_parser.py
sync/__init__.py
sync/network.py
sync/notifications.py
sync/sync_queue.py
telegram_bot/__init__.py
telegram_bot/main.py
telegram_bot/notifier.py
tools/doctor.py
tools/tg_envcheck.py
tools/tg_send.py
user_app/__init__.py
user_app/api.py
user_app/db_local.py
user_app/db_migrations.py
user_app/gui.py
user_app/login_window.py
user_app/main.py
user_app/signals.py
user_app/ui_helpers.py
work_time_tracker.egg-info/PKG-INFO
work_time_tracker.egg-info/SOURCES.txt
work_time_tracker.egg-info/dependency_links.txt
work_time_tracker.egg-info/entry_points.txt
work_time_tracker.egg-info/requires.txt
work_time_tracker.egg-info/top_level.txt

--------------------------------------------------------------------------------
# FILE: work_time_tracker.egg-info\top_level.txt
# SIZE: 75 bytes | SHA256(text): 60bedc573116b9f548d9b9860dc19f85ebdd1beeb2758883f7c48720aaac571d
--------------------------------------------------------------------------------
admin_app
config
logging_setup
sheets_api
sync
telegram_bot
tools
user_app
